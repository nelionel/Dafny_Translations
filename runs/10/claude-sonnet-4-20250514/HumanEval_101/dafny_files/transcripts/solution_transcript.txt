=============== SYSTEM ===============
You are an expert programmer specializing in translating Python code to the Dafny verification language. Your task is to translate the provided Python function into a Dafny method that is both verifiable and compilable. Pay close attention to types, specifications, and providing concrete implementations for all methods.



=============== USER ===============
I will provide you with a Python function and its documentation. Please translate the Python function into a Dafny method.

**Python Function and Documentation:**
```python

def words_string(s):
    """
    You will be given a string of words separated by commas or spaces. Your task is
    to split the string into words and return an array of the words.
    
    For example:
    words_string("Hi, my name is John") == ["Hi", "my", "name", "is", "John"]
    words_string("One, two, three, four, five, six") == ["One", "two", "three", "four", "five", "six"]
    """

import re

def words_string(s):
    """
    You will be given a string of words separated by commas or spaces. Your task is
    to split the string into words and return an array of the words.
    
    For example:
    words_string("Hi, my name is John") == ["Hi", "my", "name", "is", "John"]
    words_string("One, two, three, four, five, six") == ["One", "two", "three", "four", "five", "six"]
    """
    if not s or not s.strip():
        return []
    
    # Split by comma and/or space, filter out empty strings
    words = re.split(r'[,\s]+', s.strip())
    return [word for word in words if word]
```

**Your Task:**
1.  **Reasoning (in a <thinking> block):**
    *   Analyze the Python code and its types. How will you map Python types (like lists of floats) to Dafny types (like `seq<real>`)?
    *   Analyze the function's logic. What are the pre-conditions (`requires`) and post-conditions (`ensures`)?
    *   Identify any loops and determine their invariants.
    *   Think about termination conditions for any recursive calls or loops.
2.  **Dafny Implementation (in a ```dafny ... ``` block):**
    *   Write the complete Dafny method, including its signature, `requires` clauses, `ensures` clauses, and the method body.
    *   **The return type of the main method must be a basic Dafny type.** Use `int`, `real`, `bool`, `string`, or a sequence of these types (e.g., `seq<int>`). Do not use custom `datatype`s in the return signature. If the Python code implies an optional return (e.g. returning `None`), you should return a sensible default for the basic type instead (e.g. `false`, `-1`, or an empty sequence `[]`).
    *   The Dafny method name must be exactly the same as the Python function name: `words_string`. Do not change the casing.
    *   **All methods must have a concrete implementation (a body).** The `{:axiom}` attribute is forbidden for defining standard functions. However, if the problem's solution relies on an unproven mathematical conjecture (e.g., the Goldbach Conjecture, P vs NP), you may state the conjecture as an `axiom`. If you do so, you **must** include a comment identifying the conjecture (e.g., `// Axiom for the Twin Prime Conjecture`). Do not use axioms to avoid implementing solvable algorithms.
    *   **Provide explicit termination proofs.** For any recursive function, you must include a `decreases` clause. Do **not** use `decreases *`. For functions that operate on a sequence, the termination metric is almost always the length of the sequence (e.g., `decreases my_sequence`). For functions on integers, it is the integer itself (e.g., `decreases n`).
    *   **Do not use Dafny reserved keywords as variable names.** Avoid names like: `abstract, allocated, as, assert, assume, bool, break, by, calc, case, char, class, codatatype, const, constructor, datatype, decreases, else, ensures, exists, export, extends, false, forall, fresh, function, ghost, if, imap, import, in, include, int, invariant, is, iset, iterator, label, lemma, map, match, method, modifies, modify, module, multiset, nameonly, nat, new, newtype, null, object, object?, old, opened, ORDINAL, predicate, print, provides,reads, real, refines, requires, return, returns, reveal, reveals, seq, set, static, string, then, this, trait, true, twostate, type, unchanged, var, while, witness, yield, yields`. For example, instead of `var array`, use `var arr`.



=============== ASSISTANT ===============
--- THINKING ---
Let me analyze the Python function:

1. It takes a string `s` as input
2. If the string is empty or only whitespace, it returns an empty list
3. Otherwise, it splits the string by commas and/or spaces (using regex `[,\s]+`)
4. It filters out empty strings and returns the list of words

The key logic is:
- Handle empty/whitespace strings by returning empty list
- Split by commas and spaces
- Filter out empty strings

In Dafny, I need to:
- Map Python `str` to Dafny `string`
- Map Python `list[str]` to Dafny `seq<string>`
- Implement string splitting logic manually since Dafny doesn't have regex

For splitting, I'll need to:
1. Iterate through the string character by character
2. Collect characters into words when they're not separators (comma or space)
3. Add words to the result sequence when we hit a separator or reach the end

Let me think about the implementation:

```dafny
method words_string(s: string) returns (result: seq<string>)
{
    if |s| == 0 {
        return [];
    }
    
    // Check if string is all whitespace
    var all_whitespace := true;
    var i := 0;
    while i < |s|
        invariant 0 <= i <= |s|
        invariant all_whitespace <==> forall j :: 0 <= j < i ==> (s[j] == ' ' || s[j] == '\t' || s[j] == '\n' || s[j] == '\r')
    {
        if s[i] != ' ' && s[i] != '\t' && s[i] != '\n' && s[i] != '\r' {
            all_whitespace := false;
            break;
        }
        i := i + 1;
    }
    
    if all_whitespace {
        return [];
    }
    
    // Now split the string
    result := [];
    var current_word := "";
    i := 0;
    
    while i < |s|
        invariant 0 <= i <= |s|
        // Other invariants...
    {
        if s[i] == ' ' || s[i] == ',' {
            if |current_word| > 0 {
                result := result + [current_word];
                current_word := "";
            }
        } else {
            current_word := current_word + [s[i]];
        }
        i := i + 1;
    }
    
    // Add last word if not empty
    if |current_word| > 0 {
        result := result + [current_word];
    }
    
    return result;
}
```

I'll continue building the implementation by handling the final word and ensuring proper splitting logic. The method needs to capture words between separators and add them to the result sequence.

--- RESPONSE ---
<thinking>
Let me analyze the Python function:

1. **Input/Output Types**: Takes a string `s` and returns a list of strings. In Dafny, this maps to `string` input and `seq<string>` output.

2. **Logic Analysis**:
   - If string is empty or only whitespace, return empty list
   - Split by commas and/or spaces using regex `[,\s]+`  
   - Filter out empty strings from the result

3. **Implementation Strategy**: Since Dafny doesn't have regex, I'll need to manually iterate through the string and build words by:
   - Skipping separators (commas, spaces)
   - Collecting non-separator characters into words
   - Adding complete words to the result sequence

4. **Pre/Post-conditions**: 
   - No specific preconditions needed
   - Post-condition should ensure the result contains no empty strings and represents a valid split

5. **Termination**: The main loop iterates through the string once, so it decreases on the remaining characters.
</thinking>

```dafny
method words_string(s: string) returns (result: seq<string>)
    ensures forall word :: word in result ==> |word| > 0
{
    if |s| == 0 {
        return [];
    }
    
    // Check if string contains only whitespace and commas
    var has_non_separator := false;
    var i := 0;
    while i < |s|
        invariant 0 <= i <= |s|
        invariant has_non_separator <==> exists j :: 0 <= j < i && s[j] != ' ' && s[j] != ',' && s[j] != '\t' && s[j] != '\n' && s[j] != '\r'
        decreases |s| - i
    {
        if s[i] != ' ' && s[i] != ',' && s[i] != '\t' && s[i] != '\n' && s[i] != '\r' {
            has_non_separator := true;
            break;
        }
        i := i + 1;
    }
    
    if !has_non_separator {
        return [];
    }
    
    // Split the string into words
    result := [];
    var current_word := "";
    i := 0;
    
    while i < |s|
        invariant 0 <= i <= |s|
        invariant forall word :: word in result ==> |word| > 0
        decreases |s| - i
    {
        var ch := s[i];
        if ch == ' ' || ch == ',' || ch == '\t' || ch == '\n' || ch == '\r' {
            // Found a separator
            if |current_word| > 0 {
                result := result + [current_word];
                current_word := "";
            }
        } else {
            // Add character to current word
            current_word := current_word + [ch];
        }
        i := i + 1;
    }
    
    // Add the last word if it exists
    if |current_word| > 0 {
        result := result + [current_word];
    }
}
```

