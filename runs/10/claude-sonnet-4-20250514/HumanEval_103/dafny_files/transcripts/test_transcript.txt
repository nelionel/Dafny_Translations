=============== SYSTEM ===============
You are an expert programmer specializing in translating Python tests to the Dafny verification language. Your task is to translate Python `assert` statements into Dafny test methods and provide a minimal dummy implementation for compilation checking.



=============== USER ===============
I need you to translate Python test assertions into Dafny test methods.

**The Method to Test:**
The Dafny method you need to test is named `rounded_avg`.

**Python Test Code:**
```python
def check(candidate):

    # Check some simple cases
    assert candidate(1, 5) == "0b11"
    assert candidate(7, 13) == "0b1010"
    assert candidate(964,977) == "0b1111001010"
    assert candidate(996,997) == "0b1111100100"
    assert candidate(560,851) == "0b1011000010"
    assert candidate(185,546) == "0b101101110"
    assert candidate(362,496) == "0b110101101"
    assert candidate(350,902) == "0b1001110010"
    assert candidate(197,233) == "0b11010111"


    # Check some edge cases that are easy to work out by hand.
    assert candidate(7, 5) == -1
    assert candidate(5, 1) == -1
    assert candidate(5, 5) == "0b101"


```

**Dafny Solution Code (that these tests should test):**
```dafny
method rounded_avg(n: int, m: int) returns (result: string)
  requires n > 0 && m > 0
  ensures n > m ==> result == "-1"
  ensures n <= m ==> |result| >= 3 && result[0..2] == "0b"
{
  if n > m {
    return "-1";
  }
  
  // Calculate sum of integers from n to m using arithmetic series formula
  var sum := (m - n + 1) * (n + m) / 2;
  var count := m - n + 1;
  
  // Calculate rounded average
  // Using integer arithmetic: (2*sum + count) / (2*count) gives proper rounding
  var rounded := (2 * sum + count) / (2 * count);
  
  // Convert to binary string
  result := IntToBinary(rounded);
}

function IntToBinary(n: int): string
  requires n >= 0
  ensures |IntToBinary(n)| >= 3 && IntToBinary(n)[0..2] == "0b"
  decreases n
{
  "0b" + IntToBinaryHelper(n)
}

function IntToBinaryHelper(n: int): string
  requires n >= 0
  ensures |IntToBinaryHelper(n)| >= 1
  decreases n
{
  if n == 0 then "0"
  else if n == 1 then "1"
  else IntToBinaryHelper(n / 2) + if n % 2 == 0 then "0" else "1"
}
```

**Your Task:**
1. **Analyze the tests and solution:**
   - Note the exact name (`rounded_avg`) and signature of the Dafny method from the provided solution code.

2. **Create a minimal dummy implementation** (in a `<dummy>` block):
   - Create a dummy version of the `rounded_avg` Dafny method.
   - The dummy should have the same signature as the method in the full Dafny solution and return appropriate default values (0 for int, false for bool, [] for sequences, etc.).
   - This dummy is ONLY for validating that the test code compiles correctly.

3. **Translate the tests** (in a ```dafny ... ``` block):
   - For each `assert` statement in the Python code, create a Dafny test method with `{:test}` attribute.
   - **All generated test methods must have a complete body and be runnable.**
   - Name them `test_0`, `test_1`, etc.
   - Convert scientific notation (e.g., 1e-6) to decimal form (e.g., 0.000001).
   - Each test method should:
     a. Call the `rounded_avg` Dafny method and assign the result to a variable.
     b. Use `expect` to check if the result matches the expected value.

**Example:** If Python has `assert add(2, 3) == 5`, the method to test is `add`, and the Dafny solution has `function add(a: int, b: int): int`, then:
<dummy>
function add(a: int, b: int): int
{
    0
}
</dummy>

```dafny
method {:test} test_0()
{
    var result := add(2, 3);
    expect result == 5;
}
```



=============== ASSISTANT ===============
--- THINKING ---
Let me analyze the provided code and tests.

The method to test is `rounded_avg` which takes two integers `n` and `m` and returns a string. From the solution, I can see:

```dafny
method rounded_avg(n: int, m: int) returns (result: string)
  requires n > 0 && m > 0
  ensures n > m ==> result == "-1"
  ensures n <= m ==> |result| >= 3 && result[0..2] == "0b"
```

So it returns a string, and based on the tests:
- When n > m, it returns "-1"
- Otherwise, it returns a binary string starting with "0b"

Let me look at the Python tests:

```python
assert candidate(1, 5) == "0b11"           # test_0
assert candidate(7, 13) == "0b1010"        # test_1
assert candidate(964,977) == "0b1111001010" # test_2
assert candidate(996,997) == "0b1111100100" # test_3
assert candidate(560,851) == "0b1011000010" # test_4
assert candidate(185,546) == "0b101101110"  # test_5
assert candidate(362,496) == "0b110101101"  # test_6
assert candidate(350,902) == "0b1001110010" # test_7
assert candidate(197,233) == "0b11010111"   # test_8
assert candidate(7, 5) == -1               # test_9
assert candidate(5, 1) == -1               # test_10
assert candidate(5, 5) == "0b101"          # test_11
```

Wait, I notice that tests 9 and 10 expect `-1` as an integer, but the method returns a string. 

I see a potential type mismatch between the Dafny implementation and the Python tests. The solution clearly returns a string `"-1"`, but the tests are checking for an integer `-1`. This discrepancy suggests there might be an inconsistency in the type handling between the implementation and the test cases.

The ensures clause in the Dafny code specifies returning `"-1"` as a string when `n > m`, which conflicts with the integer `-1` in the Python tests. This could indicate a need for type conversion or test case modification.

I'll focus on creating a dummy implementation that matches the Dafny method's string return type, ensuring the tests are adjusted to expect a string representation of -1 instead of the integer value.

The key is to create a method that returns "-1" as a string when the input conditions aren't met, while maintaining the original method's signature and return type. I'll craft tests that specifically check for the string return value, accounting for the type conversion discrepancy between the original Dafny implementation and the Python tests.

--- RESPONSE ---
Looking at the provided solution, I can see the `rounded_avg` method takes two integers and returns a string.

<dummy>
method rounded_avg(n: int, m: int) returns (result: string)
  requires n > 0 && m > 0
{
    result := "";
}
</dummy>

```dafny
method {:test} test_0()
{
    var result := rounded_avg(1, 5);
    expect result == "0b11";
}

method {:test} test_1()
{
    var result := rounded_avg(7, 13);
    expect result == "0b1010";
}

method {:test} test_2()
{
    var result := rounded_avg(964, 977);
    expect result == "0b1111001010";
}

method {:test} test_3()
{
    var result := rounded_avg(996, 997);
    expect result == "0b1111100100";
}

method {:test} test_4()
{
    var result := rounded_avg(560, 851);
    expect result == "0b1011000010";
}

method {:test} test_5()
{
    var result := rounded_avg(185, 546);
    expect result == "0b101101110";
}

method {:test} test_6()
{
    var result := rounded_avg(362, 496);
    expect result == "0b110101101";
}

method {:test} test_7()
{
    var result := rounded_avg(350, 902);
    expect result == "0b1001110010";
}

method {:test} test_8()
{
    var result := rounded_avg(197, 233);
    expect result == "0b11010111";
}

method {:test} test_9()
{
    var result := rounded_avg(7, 5);
    expect result == "-1";
}

method {:test} test_10()
{
    var result := rounded_avg(5, 1);
    expect result == "-1";
}

method {:test} test_11()
{
    var result := rounded_avg(5, 5);
    expect result == "0b101";
}
```

