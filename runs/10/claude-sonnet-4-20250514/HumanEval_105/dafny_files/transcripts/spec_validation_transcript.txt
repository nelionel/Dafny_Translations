=============== SYSTEM ===============
You are an expert in formal verification and Dafny specifications. Your task is to analyze whether Dafny method specifications properly describe the behavior of the corresponding Python function.

You will be given:
1. A Python function with its behavior
2. A Dafny method translation with specifications (requires, ensures clauses)

Your job is to determine if the Dafny specifications fully and accurately capture the Python function's behavior. If not, you should improve the specifications.

IMPORTANT: You must respond with EXACTLY one of these phrases:
- "THE SCRIPT HAS PROPER SPECS" - if the specifications correctly describe the function
- "THE SCRIPT HAD NOT A PROPER SPEC" - if the specifications need improvement

After this phrase, provide the complete Dafny code (either unchanged or with improved specifications).



=============== USER ===============
Please analyze whether the Dafny specifications properly describe the Python function behavior.

**Python Function:**
```python
def by_length(arr):
    """
    Given an array of integers, sort the integers that are between 1 and 9 inclusive,
    reverse the resulting array, and then replace each digit by its corresponding name from
    "One", "Two", "Three", "Four", "Five", "Six", "Seven", "Eight", "Nine".

    For example:
      arr = [2, 1, 1, 4, 5, 8, 2, 3]   
            -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] 
            -> reverse arr -> [8, 5, 4, 3, 2, 2, 1, 1]
      return ["Eight", "Five", "Four", "Three", "Two", "Two", "One", "One"]
    
      If the array is empty, return an empty array:
      arr = []
      return []
    
      If the array has any strange number ignore it:
      arr = [1, -1 , 55] 
            -> sort arr -> [-1, 1, 55]
            -> reverse arr -> [55, 1, -1]
      return = ['One']
    """
    
    # Dictionary to map digits to their word names
    digit_to_word = {
        1: "One",
        2: "Two", 
        3: "Three",
        4: "Four",
        5: "Five",
        6: "Six",
        7: "Seven",
        8: "Eight",
        9: "Nine"
    }
    
    # Filter array to keep only integers between 1 and 9 inclusive
    valid_digits = [num for num in arr if 1 <= num <= 9]
    
    # Sort the valid digits
    valid_digits.sort()
    
    # Reverse the sorted array
    valid_digits.reverse()
    
    # Convert each digit to its corresponding word name
    result = [digit_to_word[digit] for digit in valid_digits]
    
    return result
```

**Current Dafny Code:**
```dafny
function DigitToWord(digit: int): string
    requires 1 <= digit <= 9
{
    match digit
        case 1 => "One"
        case 2 => "Two"
        case 3 => "Three"
        case 4 => "Four"
        case 5 => "Five"
        case 6 => "Six"
        case 7 => "Seven"
        case 8 => "Eight"
        case 9 => "Nine"
}

function CountValidDigits(arr: seq<int>): int
{
    if |arr| == 0 then 0
    else (if 1 <= arr[0] <= 9 then 1 else 0) + CountValidDigits(arr[1..])
}

method by_length(arr: seq<int>) returns (result: seq<string>)
    ensures |result| == CountValidDigits(arr)
    ensures forall i :: 0 <= i < |result| ==> result[i] in ["One", "Two", "Three", "Four", "Five", "Six", "Seven", "Eight", "Nine"]
{
    // Filter to keep only digits 1-9
    var validDigits: seq<int> := [];
    var i := 0;
    while i < |arr|
        invariant 0 <= i <= |arr|
        invariant forall j :: 0 <= j < |validDigits| ==> 1 <= validDigits[j] <= 9
        invariant |validDigits| == CountValidDigits(arr[..i])
        decreases |arr| - i
    {
        if 1 <= arr[i] <= 9 {
            validDigits := validDigits + [arr[i]];
        }
        i := i + 1;
    }

    // Sort using insertion sort
    var sorted := validDigits;
    var j := 1;
    while j < |sorted|
        invariant 1 <= j <= |sorted|
        invariant forall k, l :: 0 <= k < l < j ==> sorted[k] <= sorted[l]
        invariant multiset(sorted) == multiset(validDigits)
        invariant forall k :: 0 <= k < |sorted| ==> 1 <= sorted[k] <= 9
        decreases |sorted| - j
    {
        var key := sorted[j];
        var k := j - 1;
        
        // Find position to insert key
        while k >= 0 && sorted[k] > key
            invariant -1 <= k < j
            invariant forall l :: k + 1 < l <= j ==> sorted[l] > key
            decreases k + 1
        {
            k := k - 1;
        }
        
        // Shift elements and insert key
        var insertPos := k + 1;
        sorted := sorted[..insertPos] + [key] + sorted[insertPos..j] + sorted[j+1..];
        j := j + 1;
    }

    // Reverse the sorted array
    var reversed: seq<int> := [];
    var m := |sorted| - 1;
    while m >= 0
        invariant -1 <= m < |sorted|
        invariant |reversed| == |sorted| - 1 - m
        invariant forall n :: 0 <= n < |reversed| ==> reversed[n] == sorted[|sorted| - 1 - n]
        invariant forall n :: 0 <= n < |reversed| ==> 1 <= reversed[n] <= 9
        decreases m + 1
    {
        reversed := reversed + [sorted[m]];
        m := m - 1;
    }

    // Convert digits to words
    result := [];
    var p := 0;
    while p < |reversed|
        invariant 0 <= p <= |reversed|
        invariant |result| == p
        invariant forall q :: 0 <= q < p ==> result[q] == DigitToWord(reversed[q])
        invariant forall q :: 0 <= q < p ==> result[q] in ["One", "Two", "Three", "Four", "Five", "Six", "Seven", "Eight", "Nine"]
        decreases |reversed| - p
    {
        result := result + [DigitToWord(reversed[p])];
        p := p + 1;
    }
}
```

**Analysis Task:**
1. Compare the Python function's behavior with the Dafny specifications
2. Check if the `requires` clauses capture all preconditions
3. Check if the `ensures` clauses capture all postconditions and behavior
4. Verify that the specifications fully describe what the function does

**Response Format:**
Start with exactly one of these phrases:
- "THE SCRIPT HAS PROPER SPECS" (if specifications are adequate)
- "THE SCRIPT HAD NOT A PROPER SPEC" (if specifications need improvement)

Then provide the complete Dafny code. If improving specifications:
- Add missing `requires` clauses for preconditions
- Add missing `ensures` clauses for postconditions
- Ensure specifications capture the function's complete behavior
- Preserve the existing method implementation unchanged

 


=============== ASSISTANT ===============
--- THINKING ---
Let me analyze the Python function and the Dafny specifications to see if they match.

Python function behavior:
1. Takes an array of integers
2. Filters to keep only integers between 1 and 9 inclusive
3. Sorts the filtered array
4. Reverses the sorted array
5. Converts each digit to its corresponding word name
6. Returns the array of word names

The Python function essentially:
- Filters for valid digits (1-9)
- Sorts them in ascending order
- Reverses to get descending order
- Maps to word names

Let me check the Dafny specifications:

Current ensures clauses:
1. `ensures |result| == CountValidDigits(arr)` - This checks that the result length equals the count of valid digits in the input
2. `ensures forall i :: 0 <= i < |result| ==> result[i] in ["One", "Two", "Three", "Four", "Five", "Six", "Seven", "Eight", "Nine"]` - This checks that all elements in result are valid word names

What's missing from the specifications:
1. The specifications don't capture that the result should be in descending order of the corresponding digit values
2. The specifications don't capture that the result should contain exactly the same multiset of valid digits from the input (but as words and in descending order)

For example, if the input is [2, 1, 1, 4, 5, 8, 2, 3], the valid digits are [2, 1, 1, 4, 5, 8, 2, 3], sorted they become [1, 1, 2, 2, 3, 4, 5, 8], reversed they become [8, 5, 4, 3, 2, 2, 1, 1], and as words they become ["Eight", "Five", "Four", "Three", "Two", "Two", "One", "One"].
 
The specifications need refinement to precisely capture the function's complex transformation. I'll focus on creating ensures clauses that explicitly define the relationship between input and output, ensuring the exact mapping and ordering are preserved.

The key challenge is crafting specifications that guarantee:
- Correct filtering of valid digits
- Descending order preservation
- Exact word representation of the input's valid digits

I'll develop a strategy involving helper functions to validate the transformation, creating precise constraints that capture the nuanced requirements of digit-to-word conversion.

--- RESPONSE ---
THE SCRIPT HAD NOT A PROPER SPEC

```dafny
function DigitToWord(digit: int): string
    requires 1 <= digit <= 9
{
    match digit
        case 1 => "One"
        case 2 => "Two"
        case 3 => "Three"
        case 4 => "Four"
        case 5 => "Five"
        case 6 => "Six"
        case 7 => "Seven"
        case 8 => "Eight"
        case 9 => "Nine"
}

function WordToDigit(word: string): int
    requires word in ["One", "Two", "Three", "Four", "Five", "Six", "Seven", "Eight", "Nine"]
{
    match word
        case "One" => 1
        case "Two" => 2
        case "Three" => 3
        case "Four" => 4
        case "Five" => 5
        case "Six" => 6
        case "Seven" => 7
        case "Eight" => 8
        case "Nine" => 9
}

function CountValidDigits(arr: seq<int>): int
{
    if |arr| == 0 then 0
    else (if 1 <= arr[0] <= 9 then 1 else 0) + CountValidDigits(arr[1..])
}

function ExtractValidDigits(arr: seq<int>): seq<int>
{
    if |arr| == 0 then []
    else if 1 <= arr[0] <= 9 then [arr[0]] + ExtractValidDigits(arr[1..])
    else ExtractValidDigits(arr[1..])
}

predicate IsSorted(s: seq<int>)
{
    forall i, j :: 0 <= i < j < |s| ==> s[i] <= s[j]
}

predicate IsReverseSorted(s: seq<int>)
{
    forall i, j :: 0 <= i < j < |s| ==> s[i] >= s[j]
}

method by_length(arr: seq<int>) returns (result: seq<string>)
    ensures |result| == CountValidDigits(arr)
    ensures forall i :: 0 <= i < |result| ==> result[i] in ["One", "Two", "Three", "Four", "Five", "Six", "Seven", "Eight", "Nine"]
    ensures var validDigits := ExtractValidDigits(arr);
            multiset(result) == multiset(seq(|validDigits|, i requires 0 <= i < |validDigits| => DigitToWord(validDigits[i])))
    ensures |result| > 0 ==> IsReverseSorted(seq(|result|, i requires 0 <= i < |result| => WordToDigit(result[i])))
{
    // Filter to keep only digits 1-9
    var validDigits: seq<int> := [];
    var i := 0;
    while i < |arr|
        invariant 0 <= i <= |arr|
        invariant forall j :: 0 <= j < |validDigits| ==> 1 <= validDigits[j] <= 9
        invariant |validDigits| == CountValidDigits(arr[..i])
        decreases |arr| - i
    {
        if 1 <= arr[i] <= 9 {
            validDigits := validDigits + [arr[i]];
        }
        i := i + 1;
    }

    // Sort using insertion sort
    var sorted := validDigits;
    var j := 1;
    while j < |sorted|
        invariant 1 <= j <= |sorted|
        invariant forall k, l :: 0 <= k < l < j ==> sorted[k] <= sorted[l]
        invariant multiset(sorted) == multiset(validDigits)
        invariant forall k :: 0 <= k < |sorted| ==> 1 <= sorted[k] <= 9
        decreases |sorted| - j
    {
        var key := sorted[j];
        var k := j - 1;
        
        // Find position to insert key
        while k >= 0 && sorted[k] > key
            invariant -1 <= k < j
            invariant forall l :: k + 1 < l <= j ==> sorted[l] > key
            decreases k + 1
        {
            k := k - 1;
        }
        
        // Shift elements and insert key
        var insertPos := k + 1;
        sorted := sorted[..insertPos] + [key] + sorted[insertPos..j] + sorted[j+1..];
        j := j + 1;
    }

    // Reverse the sorted array
    var reversed: seq<int> := [];
    var m := |sorted| - 1;
    while m >= 0
        invariant -1 <= m < |sorted|
        invariant |reversed| == |sorted| - 1 - m
        invariant forall n :: 0 <= n < |reversed| ==> reversed[n] == sorted[|sorted| - 1 - n]
        invariant forall n :: 0 <= n < |reversed| ==> 1 <= reversed[n] <= 9
        decreases m + 1
    {
        reversed := reversed + [sorted[m]];
        m := m - 1;
    }

    // Convert digits to words
    result := [];
    var p := 0;
    while p < |reversed|
        invariant 0 <= p <= |reversed|
        invariant |result| == p
        invariant forall q :: 0 <= q < p ==> result[q] == DigitToWord(reversed[q])
        invariant forall q :: 0 <= q < p ==> result[q] in ["One", "Two", "Three", "Four", "Five", "Six", "Seven", "Eight", "Nine"]
        decreases |reversed| - p
    {
        result := result + [DigitToWord(reversed[p])];
        p := p + 1;
    }
}
```


=============== USER ===============
Please analyze whether the Dafny specifications properly describe the Python function behavior.

**Python Function:**
```python
def by_length(arr):
    """
    Given an array of integers, sort the integers that are between 1 and 9 inclusive,
    reverse the resulting array, and then replace each digit by its corresponding name from
    "One", "Two", "Three", "Four", "Five", "Six", "Seven", "Eight", "Nine".

    For example:
      arr = [2, 1, 1, 4, 5, 8, 2, 3]   
            -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] 
            -> reverse arr -> [8, 5, 4, 3, 2, 2, 1, 1]
      return ["Eight", "Five", "Four", "Three", "Two", "Two", "One", "One"]
    
      If the array is empty, return an empty array:
      arr = []
      return []
    
      If the array has any strange number ignore it:
      arr = [1, -1 , 55] 
            -> sort arr -> [-1, 1, 55]
            -> reverse arr -> [55, 1, -1]
      return = ['One']
    """
    
    # Dictionary to map digits to their word names
    digit_to_word = {
        1: "One",
        2: "Two", 
        3: "Three",
        4: "Four",
        5: "Five",
        6: "Six",
        7: "Seven",
        8: "Eight",
        9: "Nine"
    }
    
    # Filter array to keep only integers between 1 and 9 inclusive
    valid_digits = [num for num in arr if 1 <= num <= 9]
    
    # Sort the valid digits
    valid_digits.sort()
    
    # Reverse the sorted array
    valid_digits.reverse()
    
    # Convert each digit to its corresponding word name
    result = [digit_to_word[digit] for digit in valid_digits]
    
    return result
```

**Current Dafny Code:**
```dafny
function DigitToWord(digit: int): string
    requires 1 <= digit <= 9
{
    match digit
        case 1 => "One"
        case 2 => "Two"
        case 3 => "Three"
        case 4 => "Four"
        case 5 => "Five"
        case 6 => "Six"
        case 7 => "Seven"
        case 8 => "Eight"
        case 9 => "Nine"
}

function WordToDigit(word: string): int
    requires word in ["One", "Two", "Three", "Four", "Five", "Six", "Seven", "Eight", "Nine"]
{
    match word
        case "One" => 1
        case "Two" => 2
        case "Three" => 3
        case "Four" => 4
        case "Five" => 5
        case "Six" => 6
        case "Seven" => 7
        case "Eight" => 8
        case "Nine" => 9
}

function CountValidDigits(arr: seq<int>): int
{
    if |arr| == 0 then 0
    else (if 1 <= arr[0] <= 9 then 1 else 0) + CountValidDigits(arr[1..])
}

function ExtractValidDigits(arr: seq<int>): seq<int>
{
    if |arr| == 0 then []
    else if 1 <= arr[0] <= 9 then [arr[0]] + ExtractValidDigits(arr[1..])
    else ExtractValidDigits(arr[1..])
}

predicate IsSorted(s: seq<int>)
{
    forall i, j :: 0 <= i < j < |s| ==> s[i] <= s[j]
}

predicate IsReverseSorted(s: seq<int>)
{
    forall i, j :: 0 <= i < j < |s| ==> s[i] >= s[j]
}

method by_length(arr: seq<int>) returns (result: seq<string>)
    ensures |result| == CountValidDigits(arr)
    ensures forall i :: 0 <= i < |result| ==> result[i] in ["One", "Two", "Three", "Four", "Five", "Six", "Seven", "Eight", "Nine"]
    ensures var validDigits := ExtractValidDigits(arr);
            multiset(result) == multiset(seq(|validDigits|, i requires 0 <= i < |validDigits| => DigitToWord(validDigits[i])))
    ensures |result| > 0 ==> IsReverseSorted(seq(|result|, i requires 0 <= i < |result| => WordToDigit(result[i])))
{
    // Filter to keep only digits 1-9
    var validDigits: seq<int> := [];
    var i := 0;
    while i < |arr|
        invariant 0 <= i <= |arr|
        invariant forall j :: 0 <= j < |validDigits| ==> 1 <= validDigits[j] <= 9
        invariant |validDigits| == CountValidDigits(arr[..i])
        decreases |arr| - i
    {
        if 1 <= arr[i] <= 9 {
            validDigits := validDigits + [arr[i]];
        }
        i := i + 1;
    }

    // Sort using insertion sort
    var sorted := validDigits;
    var j := 1;
    while j < |sorted|
        invariant 1 <= j <= |sorted|
        invariant forall k, l :: 0 <= k < l < j ==> sorted[k] <= sorted[l]
        invariant multiset(sorted) == multiset(validDigits)
        invariant forall k :: 0 <= k < |sorted| ==> 1 <= sorted[k] <= 9
        decreases |sorted| - j
    {
        var key := sorted[j];
        var k := j - 1;
        
        // Find position to insert key
        while k >= 0 && sorted[k] > key
            invariant -1 <= k < j
            invariant forall l :: k + 1 < l <= j ==> sorted[l] > key
            decreases k + 1
        {
            k := k - 1;
        }
        
        // Shift elements and insert key
        var insertPos := k + 1;
        sorted := sorted[..insertPos] + [key] + sorted[insertPos..j] + sorted[j+1..];
        j := j + 1;
    }

    // Reverse the sorted array
    var reversed: seq<int> := [];
    var m := |sorted| - 1;
    while m >= 0
        invariant -1 <= m < |sorted|
        invariant |reversed| == |sorted| - 1 - m
        invariant forall n :: 0 <= n < |reversed| ==> reversed[n] == sorted[|sorted| - 1 - n]
        invariant forall n :: 0 <= n < |reversed| ==> 1 <= reversed[n] <= 9
        decreases m + 1
    {
        reversed := reversed + [sorted[m]];
        m := m - 1;
    }

    // Convert digits to words
    result := [];
    var p := 0;
    while p < |reversed|
        invariant 0 <= p <= |reversed|
        invariant |result| == p
        invariant forall q :: 0 <= q < p ==> result[q] == DigitToWord(reversed[q])
        invariant forall q :: 0 <= q < p ==> result[q] in ["One", "Two", "Three", "Four", "Five", "Six", "Seven", "Eight", "Nine"]
        decreases |reversed| - p
    {
        result := result + [DigitToWord(reversed[p])];
        p := p + 1;
    }
}
```

**Analysis Task:**
1. Compare the Python function's behavior with the Dafny specifications
2. Check if the `requires` clauses capture all preconditions
3. Check if the `ensures` clauses capture all postconditions and behavior
4. Verify that the specifications fully describe what the function does

**Response Format:**
Start with exactly one of these phrases:
- "THE SCRIPT HAS PROPER SPECS" (if specifications are adequate)
- "THE SCRIPT HAD NOT A PROPER SPEC" (if specifications need improvement)

Then provide the complete Dafny code. If improving specifications:
- Add missing `requires` clauses for preconditions
- Add missing `ensures` clauses for postconditions
- Ensure specifications capture the function's complete behavior
- Preserve the existing method implementation unchanged



This is attempt 2 to improve the specifications. Please analyze the current version and improve it further if needed. 


=============== ASSISTANT ===============
--- THINKING ---
Let me analyze the Python function and the current Dafny specifications.

The Python function `by_length`:
1. Takes an array of integers
2. Filters to keep only integers between 1 and 9 inclusive
3. Sorts the valid digits
4. Reverses the sorted array 
5. Converts each digit to its corresponding word name
6. Returns the result

Let me check the current Dafny specifications:

1. `ensures |result| == CountValidDigits(arr)` - This is correct, the result length should equal the count of valid digits in the input.

2. `ensures forall i :: 0 <= i < |result| ==> result[i] in ["One", "Two", "Three", "Four", "Five", "Six", "Seven", "Eight", "Nine"]` - This is correct, all elements in the result should be valid digit words.

3. `ensures var validDigits := ExtractValidDigits(arr); multiset(result) == multiset(seq(|validDigits|, i requires 0 <= i < |validDigits| => DigitToWord(validDigits[i])))` - This ensures that the result contains the same elements as converting the valid digits to words, but it doesn't ensure the ordering.

4. `ensures |result| > 0 ==> IsReverseSorted(seq(|result|, i requires 0 <= i < |result| => WordToDigit(result[i])))` - This ensures that if the result is non-empty, then the corresponding digits are in reverse sorted order.

Let me think about what the specification is missing:

The key behavior is:
1. Filter valid digits (1-9)
2. Sort them
3. Reverse the sorted sequence
4. Convert to words

The current specification captures:
- Length correctness
- All elements are valid words
- The multiset of elements is correct (same elements as converting valid digits)


- The ordering is reverse sorted

I realize the specifications comprehensively cover the function's behavior. The combination of multiset equality and reverse sorting ensures we have exactly the right elements in the precise order required. Each specification addresses a critical aspect of the function's transformation process.

The specifications elegantly capture the entire transformation: filtering, sorting, reversing, and converting digits to words. No additional constraints seem necessary to fully define the function's expected output.

The key mechanism involves extracting valid digits, maintaining their original count through multiset comparison, then systematically arranging them in descending order after conversion to words. This approach guarantees precise, predictable results across different input sequences.

--- RESPONSE ---
THE SCRIPT HAS PROPER SPECS

```dafny
function DigitToWord(digit: int): string
    requires 1 <= digit <= 9
{
    match digit
        case 1 => "One"
        case 2 => "Two"
        case 3 => "Three"
        case 4 => "Four"
        case 5 => "Five"
        case 6 => "Six"
        case 7 => "Seven"
        case 8 => "Eight"
        case 9 => "Nine"
}

function WordToDigit(word: string): int
    requires word in ["One", "Two", "Three", "Four", "Five", "Six", "Seven", "Eight", "Nine"]
{
    match word
        case "One" => 1
        case "Two" => 2
        case "Three" => 3
        case "Four" => 4
        case "Five" => 5
        case "Six" => 6
        case "Seven" => 7
        case "Eight" => 8
        case "Nine" => 9
}

function CountValidDigits(arr: seq<int>): int
{
    if |arr| == 0 then 0
    else (if 1 <= arr[0] <= 9 then 1 else 0) + CountValidDigits(arr[1..])
}

function ExtractValidDigits(arr: seq<int>): seq<int>
{
    if |arr| == 0 then []
    else if 1 <= arr[0] <= 9 then [arr[0]] + ExtractValidDigits(arr[1..])
    else ExtractValidDigits(arr[1..])
}

predicate IsSorted(s: seq<int>)
{
    forall i, j :: 0 <= i < j < |s| ==> s[i] <= s[j]
}

predicate IsReverseSorted(s: seq<int>)
{
    forall i, j :: 0 <= i < j < |s| ==> s[i] >= s[j]
}

method by_length(arr: seq<int>) returns (result: seq<string>)
    ensures |result| == CountValidDigits(arr)
    ensures forall i :: 0 <= i < |result| ==> result[i] in ["One", "Two", "Three", "Four", "Five", "Six", "Seven", "Eight", "Nine"]
    ensures var validDigits := ExtractValidDigits(arr);
            multiset(result) == multiset(seq(|validDigits|, i requires 0 <= i < |validDigits| => DigitToWord(validDigits[i])))
    ensures |result| > 0 ==> IsReverseSorted(seq(|result|, i requires 0 <= i < |result| => WordToDigit(result[i])))
{
    // Filter to keep only digits 1-9
    var validDigits: seq<int> := [];
    var i := 0;
    while i < |arr|
        invariant 0 <= i <= |arr|
        invariant forall j :: 0 <= j < |validDigits| ==> 1 <= validDigits[j] <= 9
        invariant |validDigits| == CountValidDigits(arr[..i])
        decreases |arr| - i
    {
        if 1 <= arr[i] <= 9 {
            validDigits := validDigits + [arr[i]];
        }
        i := i + 1;
    }

    // Sort using insertion sort
    var sorted := validDigits;
    var j := 1;
    while j < |sorted|
        invariant 1 <= j <= |sorted|
        invariant forall k, l :: 0 <= k < l < j ==> sorted[k] <= sorted[l]
        invariant multiset(sorted) == multiset(validDigits)
        invariant forall k :: 0 <= k < |sorted| ==> 1 <= sorted[k] <= 9
        decreases |sorted| - j
    {
        var key := sorted[j];
        var k := j - 1;
        
        // Find position to insert key
        while k >= 0 && sorted[k] > key
            invariant -1 <= k < j
            invariant forall l :: k + 1 < l <= j ==> sorted[l] > key
            decreases k + 1
        {
            k := k - 1;
        }
        
        // Shift elements and insert key
        var insertPos := k + 1;
        sorted := sorted[..insertPos] + [key] + sorted[insertPos..j] + sorted[j+1..];
        j := j + 1;
    }

    // Reverse the sorted array
    var reversed: seq<int> := [];
    var m := |sorted| - 1;
    while m >= 0
        invariant -1 <= m < |sorted|
        invariant |reversed| == |sorted| - 1 - m
        invariant forall n :: 0 <= n < |reversed| ==> reversed[n] == sorted[|sorted| - 1 - n]
        invariant forall n :: 0 <= n < |reversed| ==> 1 <= reversed[n] <= 9
        decreases m + 1
    {
        reversed := reversed + [sorted[m]];
        m := m - 1;
    }

    // Convert digits to words
    result := [];
    var p := 0;
    while p < |reversed|
        invariant 0 <= p <= |reversed|
        invariant |result| == p
        invariant forall q :: 0 <= q < p ==> result[q] == DigitToWord(reversed[q])
        invariant forall q :: 0 <= q < p ==> result[q] in ["One", "Two", "Three", "Four", "Five", "Six", "Seven", "Eight", "Nine"]
        decreases |reversed| - p
    {
        result := result + [DigitToWord(reversed[p])];
        p := p + 1;
    }
}
```

