=============== SYSTEM ===============
You are an expert in formal verification and Dafny specifications. Your task is to analyze whether Dafny method specifications properly describe the behavior of the corresponding Python function.

You will be given:
1. A Python function with its behavior
2. A Dafny method translation with specifications (requires, ensures clauses)

Your job is to determine if the Dafny specifications fully and accurately capture the Python function's behavior. If not, you should improve the specifications.

IMPORTANT: You must respond with EXACTLY one of these phrases:
- "THE SCRIPT HAS PROPER SPECS" - if the specifications correctly describe the function
- "THE SCRIPT HAD NOT A PROPER SPEC" - if the specifications need improvement

After this phrase, provide the complete Dafny code (either unchanged or with improved specifications).



=============== USER ===============
Please analyze whether the Dafny specifications properly describe the Python function behavior.

**Python Function:**
```python
def odd_count(lst):
    """Given a list of strings, where each string consists of only digits, return a list.
    Each element i of the output should be "the number of odd elements in the
    string i of the input." where all the i's should be replaced by the number
    of odd digits in the i'th string of the input.

    >>> odd_count(['1234567'])
    ["the number of odd elements 4n the str4ng 4 of the 4nput."]
    >>> odd_count(['3',"11111111"])
    ["the number of odd elements 1n the str1ng 1 of the 1nput.",
     "the number of odd elements 8n the str8ng 8 of the 8nput."]
    """
    result = []
    template = "the number of odd elements in the string i of the input."
    
    for string in lst:
        # Count odd digits in the current string
        odd_count = 0
        for char in string:
            if char.isdigit() and int(char) % 2 == 1:
                odd_count += 1
        
        # Replace all 'i' characters with the count
        formatted_string = template.replace('i', str(odd_count))
        result.append(formatted_string)
    
    return result
```

**Current Dafny Code:**
```dafny
method odd_count(lst: seq<string>) returns (result: seq<string>)
    ensures |result| == |lst|
{
    result := [];
    var template := "the number of odd elements in the string i of the input.";
    
    for i := 0 to |lst|
        invariant |result| == i
    {
        var current_string := lst[i];
        var odd_count_val := CountOddDigits(current_string);
        var count_str := IntToString(odd_count_val);
        var formatted_string := ReplaceChar(template, 'i', count_str);
        result := result + [formatted_string];
    }
}

function IsDigit(c: char): bool
{
    '0' <= c <= '9'
}

function IsOddDigit(c: char): bool
    requires IsDigit(c)
{
    c == '1' || c == '3' || c == '5' || c == '7' || c == '9'
}

function CountOddDigits(s: string): int
    ensures CountOddDigits(s) >= 0
{
    if |s| == 0 then 0
    else
        var first_char := s[0];
        var rest_count := CountOddDigits(s[1..]);
        if IsDigit(first_char) && IsOddDigit(first_char) then
            1 + rest_count
        else
            rest_count
}

function ReplaceChar(s: string, old_char: char, new_str: string): string
    decreases |s|
{
    if |s| == 0 then ""
    else if s[0] == old_char then
        new_str + ReplaceChar(s[1..], old_char, new_str)
    else
        [s[0]] + ReplaceChar(s[1..], old_char, new_str)
}

function IntToString(n: int): string
    requires n >= 0
    decreases n
{
    if n < 10 then
        [DigitToChar(n)]
    else
        IntToString(n / 10) + [DigitToChar(n % 10)]
}

function DigitToChar(digit: int): char
    requires 0 <= digit <= 9
{
    match digit
    case 0 => '0'
    case 1 => '1'
    case 2 => '2'
    case 3 => '3'
    case 4 => '4'
    case 5 => '5'
    case 6 => '6'
    case 7 => '7'
    case 8 => '8'
    case 9 => '9'
}
```

**Analysis Task:**
1. Compare the Python function's behavior with the Dafny specifications
2. Check if the `requires` clauses capture all preconditions
3. Check if the `ensures` clauses capture all postconditions and behavior
4. Verify that the specifications fully describe what the function does

**Response Format:**
Start with exactly one of these phrases:
- "THE SCRIPT HAS PROPER SPECS" (if specifications are adequate)
- "THE SCRIPT HAD NOT A PROPER SPEC" (if specifications need improvement)

Then provide the complete Dafny code. If improving specifications:
- Add missing `requires` clauses for preconditions
- Add missing `ensures` clauses for postconditions
- Ensure specifications capture the function's complete behavior
- Preserve the existing method implementation unchanged

 


=============== ASSISTANT ===============
--- THINKING ---
Let me analyze the Python function behavior and compare it with the Dafny specifications:

**Python Function Behavior:**
1. Takes a list of strings
2. Each string consists of only digits (according to docstring)
3. For each string, counts the number of odd digits in it
4. Creates a formatted string by replacing all 'i' characters in the template with the count of odd digits
5. Returns a list of formatted strings with the same length as the input list

**Current Dafny Specifications:**
Looking at the main method `odd_count`:
- Only has one ensures clause: `ensures |result| == |lst|`
- This only captures that the result has the same length as the input

**Missing Specifications:**
1. The method should specify that each element in the result is the template string with 'i' replaced by the count of odd digits in the corresponding input string
2. The method should specify what the template string is
3. The method should specify the relationship between input strings and their corresponding output strings

The current specification is too weak. It only guarantees the length but doesn't specify what the actual contents of the result should be.

Looking at the helper functions:
- `CountOddDigits` has proper specification with ensures clause about non-negativity
- `IsDigit` and `IsOddDigit` seem fine
- `ReplaceChar` doesn't have postcondition specifications
- `IntToString` has a precondition but no postcondition
- `DigitToChar` has proper precondition

The main issue is that the `odd_count` method doesn't specify the relationship between input and output elements. It should specify that each result[i] is the template with 'i' replaced by the string representation of the count of odd digits in lst[i].

I should add more comprehensive ensures clauses to capture the complete behavior.

--- RESPONSE ---
THE SCRIPT HAD NOT A PROPER SPEC

```dafny
method odd_count(lst: seq<string>) returns (result: seq<string>)
    ensures |result| == |lst|
    ensures forall i :: 0 <= i < |lst| ==> 
        result[i] == ReplaceChar("the number of odd elements in the string i of the input.", 'i', IntToString(CountOddDigits(lst[i])))
{
    result := [];
    var template := "the number of odd elements in the string i of the input.";
    
    for i := 0 to |lst|
        invariant |result| == i
        invariant forall j :: 0 <= j < i ==> 
            result[j] == ReplaceChar(template, 'i', IntToString(CountOddDigits(lst[j])))
    {
        var current_string := lst[i];
        var odd_count_val := CountOddDigits(current_string);
        var count_str := IntToString(odd_count_val);
        var formatted_string := ReplaceChar(template, 'i', count_str);
        result := result + [formatted_string];
    }
}

function IsDigit(c: char): bool
{
    '0' <= c <= '9'
}

function IsOddDigit(c: char): bool
    requires IsDigit(c)
{
    c == '1' || c == '3' || c == '5' || c == '7' || c == '9'
}

function CountOddDigits(s: string): int
    ensures CountOddDigits(s) >= 0
{
    if |s| == 0 then 0
    else
        var first_char := s[0];
        var rest_count := CountOddDigits(s[1..]);
        if IsDigit(first_char) && IsOddDigit(first_char) then
            1 + rest_count
        else
            rest_count
}

function ReplaceChar(s: string, old_char: char, new_str: string): string
    decreases |s|
{
    if |s| == 0 then ""
    else if s[0] == old_char then
        new_str + ReplaceChar(s[1..], old_char, new_str)
    else
        [s[0]] + ReplaceChar(s[1..], old_char, new_str)
}

function IntToString(n: int): string
    requires n >= 0
    decreases n
    ensures |IntToString(n)| > 0
{
    if n < 10 then
        [DigitToChar(n)]
    else
        IntToString(n / 10) + [DigitToChar(n % 10)]
}

function DigitToChar(digit: int): char
    requires 0 <= digit <= 9
{
    match digit
    case 0 => '0'
    case 1 => '1'
    case 2 => '2'
    case 3 => '3'
    case 4 => '4'
    case 5 => '5'
    case 6 => '6'
    case 7 => '7'
    case 8 => '8'
    case 9 => '9'
}
```


=============== USER ===============
Please analyze whether the Dafny specifications properly describe the Python function behavior.

**Python Function:**
```python
def odd_count(lst):
    """Given a list of strings, where each string consists of only digits, return a list.
    Each element i of the output should be "the number of odd elements in the
    string i of the input." where all the i's should be replaced by the number
    of odd digits in the i'th string of the input.

    >>> odd_count(['1234567'])
    ["the number of odd elements 4n the str4ng 4 of the 4nput."]
    >>> odd_count(['3',"11111111"])
    ["the number of odd elements 1n the str1ng 1 of the 1nput.",
     "the number of odd elements 8n the str8ng 8 of the 8nput."]
    """
    result = []
    template = "the number of odd elements in the string i of the input."
    
    for string in lst:
        # Count odd digits in the current string
        odd_count = 0
        for char in string:
            if char.isdigit() and int(char) % 2 == 1:
                odd_count += 1
        
        # Replace all 'i' characters with the count
        formatted_string = template.replace('i', str(odd_count))
        result.append(formatted_string)
    
    return result
```

**Current Dafny Code:**
```dafny
method odd_count(lst: seq<string>) returns (result: seq<string>)
    ensures |result| == |lst|
    ensures forall i :: 0 <= i < |lst| ==> 
        result[i] == ReplaceChar("the number of odd elements in the string i of the input.", 'i', IntToString(CountOddDigits(lst[i])))
{
    result := [];
    var template := "the number of odd elements in the string i of the input.";
    
    for i := 0 to |lst|
        invariant |result| == i
        invariant forall j :: 0 <= j < i ==> 
            result[j] == ReplaceChar(template, 'i', IntToString(CountOddDigits(lst[j])))
    {
        var current_string := lst[i];
        var odd_count_val := CountOddDigits(current_string);
        var count_str := IntToString(odd_count_val);
        var formatted_string := ReplaceChar(template, 'i', count_str);
        result := result + [formatted_string];
    }
}

function IsDigit(c: char): bool
{
    '0' <= c <= '9'
}

function IsOddDigit(c: char): bool
    requires IsDigit(c)
{
    c == '1' || c == '3' || c == '5' || c == '7' || c == '9'
}

function CountOddDigits(s: string): int
    ensures CountOddDigits(s) >= 0
{
    if |s| == 0 then 0
    else
        var first_char := s[0];
        var rest_count := CountOddDigits(s[1..]);
        if IsDigit(first_char) && IsOddDigit(first_char) then
            1 + rest_count
        else
            rest_count
}

function ReplaceChar(s: string, old_char: char, new_str: string): string
    decreases |s|
{
    if |s| == 0 then ""
    else if s[0] == old_char then
        new_str + ReplaceChar(s[1..], old_char, new_str)
    else
        [s[0]] + ReplaceChar(s[1..], old_char, new_str)
}

function IntToString(n: int): string
    requires n >= 0
    decreases n
    ensures |IntToString(n)| > 0
{
    if n < 10 then
        [DigitToChar(n)]
    else
        IntToString(n / 10) + [DigitToChar(n % 10)]
}

function DigitToChar(digit: int): char
    requires 0 <= digit <= 9
{
    match digit
    case 0 => '0'
    case 1 => '1'
    case 2 => '2'
    case 3 => '3'
    case 4 => '4'
    case 5 => '5'
    case 6 => '6'
    case 7 => '7'
    case 8 => '8'
    case 9 => '9'
}
```

**Analysis Task:**
1. Compare the Python function's behavior with the Dafny specifications
2. Check if the `requires` clauses capture all preconditions
3. Check if the `ensures` clauses capture all postconditions and behavior
4. Verify that the specifications fully describe what the function does

**Response Format:**
Start with exactly one of these phrases:
- "THE SCRIPT HAS PROPER SPECS" (if specifications are adequate)
- "THE SCRIPT HAD NOT A PROPER SPEC" (if specifications need improvement)

Then provide the complete Dafny code. If improving specifications:
- Add missing `requires` clauses for preconditions
- Add missing `ensures` clauses for postconditions
- Ensure specifications capture the function's complete behavior
- Preserve the existing method implementation unchanged



This is attempt 2 to improve the specifications. Please analyze the current version and improve it further if needed. 


=============== ASSISTANT ===============
--- THINKING ---
Let me analyze the Python function and the Dafny specifications:

**Python Function Analysis:**
1. Takes a list of strings where each string consists of only digits
2. For each string, counts the number of odd digits 
3. Creates a result string by replacing all 'i' characters in the template "the number of odd elements in the string i of the input." with the count of odd digits
4. Returns a list of these formatted strings

**Current Dafny Specifications Analysis:**

The method signature is:
```dafny
method odd_count(lst: seq<string>) returns (result: seq<string>)
    ensures |result| == |lst|
    ensures forall i :: 0 <= i < |lst| ==> 
        result[i] == ReplaceChar("the number of odd elements in the string i of the input.", 'i', IntToString(CountOddDigits(lst[i])))
```

Let me check if this captures the behavior:

1. **Length preservation**: `ensures |result| == |lst|` - ✓ This is correct
2. **Result format**: The ensures clause says each result[i] should be the template with 'i' replaced by the string representation of the count of odd digits in lst[i] - ✓ This looks correct

**Preconditions**: The Python function assumes that each string consists of only digits. However, the Dafny specification doesn't have any `requires` clause that enforces this constraint. Looking at the CountOddDigits function, it handles non-digit characters by just ignoring them (not counting them as odd). But the Python function's docstring says "each string consists of only digits", so this should be a precondition.

Let me check the helper functions:
- `IsDigit(c)` - looks correct
- `IsOddDigit(c)` - has a precondition that c must be a digit, which is good


- `CountOddDigits(s)` handles non-digit characters by simply not counting them
- `ReplaceChar` appears to work as expected
- `IntToString` meets its precondition with non-negative numbers
- `DigitToChar` seems appropriate

The specification lacks a crucial precondition ensuring all input strings contain only digits. This diverges from the Python function's explicit requirement, potentially allowing unexpected behavior with non-digit strings.

The CountOddDigits function demonstrates flexibility by silently ignoring non-digit characters, which might mask potential input validation issues.

The proposed precondition using a universal quantifier comprehensively validates each character in every input string, ensuring strict digit-only input across the entire list.

--- RESPONSE ---
THE SCRIPT HAD NOT A PROPER SPEC

```dafny
method odd_count(lst: seq<string>) returns (result: seq<string>)
    requires forall i :: 0 <= i < |lst| ==> forall j :: 0 <= j < |lst[i]| ==> IsDigit(lst[i][j])
    ensures |result| == |lst|
    ensures forall i :: 0 <= i < |lst| ==> 
        result[i] == ReplaceChar("the number of odd elements in the string i of the input.", 'i', IntToString(CountOddDigits(lst[i])))
{
    result := [];
    var template := "the number of odd elements in the string i of the input.";
    
    for i := 0 to |lst|
        invariant |result| == i
        invariant forall j :: 0 <= j < i ==> 
            result[j] == ReplaceChar(template, 'i', IntToString(CountOddDigits(lst[j])))
    {
        var current_string := lst[i];
        var odd_count_val := CountOddDigits(current_string);
        var count_str := IntToString(odd_count_val);
        var formatted_string := ReplaceChar(template, 'i', count_str);
        result := result + [formatted_string];
    }
}

function IsDigit(c: char): bool
{
    '0' <= c <= '9'
}

function IsOddDigit(c: char): bool
    requires IsDigit(c)
{
    c == '1' || c == '3' || c == '5' || c == '7' || c == '9'
}

function CountOddDigits(s: string): int
    ensures CountOddDigits(s) >= 0
{
    if |s| == 0 then 0
    else
        var first_char := s[0];
        var rest_count := CountOddDigits(s[1..]);
        if IsDigit(first_char) && IsOddDigit(first_char) then
            1 + rest_count
        else
            rest_count
}

function ReplaceChar(s: string, old_char: char, new_str: string): string
    decreases |s|
{
    if |s| == 0 then ""
    else if s[0] == old_char then
        new_str + ReplaceChar(s[1..], old_char, new_str)
    else
        [s[0]] + ReplaceChar(s[1..], old_char, new_str)
}

function IntToString(n: int): string
    requires n >= 0
    decreases n
    ensures |IntToString(n)| > 0
{
    if n < 10 then
        [DigitToChar(n)]
    else
        IntToString(n / 10) + [DigitToChar(n % 10)]
}

function DigitToChar(digit: int): char
    requires 0 <= digit <= 9
{
    match digit
    case 0 => '0'
    case 1 => '1'
    case 2 => '2'
    case 3 => '3'
    case 4 => '4'
    case 5 => '5'
    case 6 => '6'
    case 7 => '7'
    case 8 => '8'
    case 9 => '9'
}
```


=============== USER ===============
Please analyze whether the Dafny specifications properly describe the Python function behavior.

**Python Function:**
```python
def odd_count(lst):
    """Given a list of strings, where each string consists of only digits, return a list.
    Each element i of the output should be "the number of odd elements in the
    string i of the input." where all the i's should be replaced by the number
    of odd digits in the i'th string of the input.

    >>> odd_count(['1234567'])
    ["the number of odd elements 4n the str4ng 4 of the 4nput."]
    >>> odd_count(['3',"11111111"])
    ["the number of odd elements 1n the str1ng 1 of the 1nput.",
     "the number of odd elements 8n the str8ng 8 of the 8nput."]
    """
    result = []
    template = "the number of odd elements in the string i of the input."
    
    for string in lst:
        # Count odd digits in the current string
        odd_count = 0
        for char in string:
            if char.isdigit() and int(char) % 2 == 1:
                odd_count += 1
        
        # Replace all 'i' characters with the count
        formatted_string = template.replace('i', str(odd_count))
        result.append(formatted_string)
    
    return result
```

**Current Dafny Code:**
```dafny
method odd_count(lst: seq<string>) returns (result: seq<string>)
    requires forall i :: 0 <= i < |lst| ==> forall j :: 0 <= j < |lst[i]| ==> IsDigit(lst[i][j])
    ensures |result| == |lst|
    ensures forall i :: 0 <= i < |lst| ==> 
        result[i] == ReplaceChar("the number of odd elements in the string i of the input.", 'i', IntToString(CountOddDigits(lst[i])))
{
    result := [];
    var template := "the number of odd elements in the string i of the input.";
    
    for i := 0 to |lst|
        invariant |result| == i
        invariant forall j :: 0 <= j < i ==> 
            result[j] == ReplaceChar(template, 'i', IntToString(CountOddDigits(lst[j])))
    {
        var current_string := lst[i];
        var odd_count_val := CountOddDigits(current_string);
        var count_str := IntToString(odd_count_val);
        var formatted_string := ReplaceChar(template, 'i', count_str);
        result := result + [formatted_string];
    }
}

function IsDigit(c: char): bool
{
    '0' <= c <= '9'
}

function IsOddDigit(c: char): bool
    requires IsDigit(c)
{
    c == '1' || c == '3' || c == '5' || c == '7' || c == '9'
}

function CountOddDigits(s: string): int
    ensures CountOddDigits(s) >= 0
{
    if |s| == 0 then 0
    else
        var first_char := s[0];
        var rest_count := CountOddDigits(s[1..]);
        if IsDigit(first_char) && IsOddDigit(first_char) then
            1 + rest_count
        else
            rest_count
}

function ReplaceChar(s: string, old_char: char, new_str: string): string
    decreases |s|
{
    if |s| == 0 then ""
    else if s[0] == old_char then
        new_str + ReplaceChar(s[1..], old_char, new_str)
    else
        [s[0]] + ReplaceChar(s[1..], old_char, new_str)
}

function IntToString(n: int): string
    requires n >= 0
    decreases n
    ensures |IntToString(n)| > 0
{
    if n < 10 then
        [DigitToChar(n)]
    else
        IntToString(n / 10) + [DigitToChar(n % 10)]
}

function DigitToChar(digit: int): char
    requires 0 <= digit <= 9
{
    match digit
    case 0 => '0'
    case 1 => '1'
    case 2 => '2'
    case 3 => '3'
    case 4 => '4'
    case 5 => '5'
    case 6 => '6'
    case 7 => '7'
    case 8 => '8'
    case 9 => '9'
}
```

**Analysis Task:**
1. Compare the Python function's behavior with the Dafny specifications
2. Check if the `requires` clauses capture all preconditions
3. Check if the `ensures` clauses capture all postconditions and behavior
4. Verify that the specifications fully describe what the function does

**Response Format:**
Start with exactly one of these phrases:
- "THE SCRIPT HAS PROPER SPECS" (if specifications are adequate)
- "THE SCRIPT HAD NOT A PROPER SPEC" (if specifications need improvement)

Then provide the complete Dafny code. If improving specifications:
- Add missing `requires` clauses for preconditions
- Add missing `ensures` clauses for postconditions
- Ensure specifications capture the function's complete behavior
- Preserve the existing method implementation unchanged



This is attempt 3 to improve the specifications. Please analyze the current version and improve it further if needed. 


=============== ASSISTANT ===============
--- THINKING ---
Let me analyze the Python function and the Dafny specifications:

**Python Function Analysis:**
1. Takes a list of strings where each string consists of only digits
2. For each string, counts the number of odd digits
3. Uses a template "the number of odd elements in the string i of the input."
4. Replaces all occurrences of 'i' in the template with the count of odd digits
5. Returns a list of formatted strings

**Current Dafny Specifications Analysis:**

**Requires clause:**
```dafny
requires forall i :: 0 <= i < |lst| ==> forall j :: 0 <= j < |lst[i]| ==> IsDigit(lst[i][j])
```
This correctly captures that all characters in all strings must be digits.

**Ensures clauses:**
```dafny
ensures |result| == |lst|
ensures forall i :: 0 <= i < |lst| ==> 
    result[i] == ReplaceChar("the number of odd elements in the string i of the input.", 'i', IntToString(CountOddDigits(lst[i])))
```

This looks correct:
1. The result has the same length as the input
2. Each element in the result is the template string with 'i' replaced by the count of odd digits in the corresponding input string

Let me check if the helper functions are correct:

**IsDigit:** Correctly checks if a character is a digit ('0' to '9')

**IsOddDigit:** Correctly checks if a digit character is odd (1, 3, 5, 7, 9)

**CountOddDigits:** Recursively counts odd digits in a string. This looks correct.

**ReplaceChar:** Recursively replaces all occurrences of a character with a string. This looks correct.

**IntToString:** Converts a non-negative integer to its string representation. 

I verify the additional helper function's correctness and confirm the overall specification's alignment with the Python function's behavior. The implementation ensures precise digit manipulation and string transformation, capturing the core logic of counting odd digits and formatting the output string.

The verification process reveals a robust approach to specifying the function's requirements and guarantees, demonstrating a comprehensive translation from Python to Dafny's formal specification.

--- RESPONSE ---
THE SCRIPT HAS PROPER SPECS

```dafny
method odd_count(lst: seq<string>) returns (result: seq<string>)
    requires forall i :: 0 <= i < |lst| ==> forall j :: 0 <= j < |lst[i]| ==> IsDigit(lst[i][j])
    ensures |result| == |lst|
    ensures forall i :: 0 <= i < |lst| ==> 
        result[i] == ReplaceChar("the number of odd elements in the string i of the input.", 'i', IntToString(CountOddDigits(lst[i])))
{
    result := [];
    var template := "the number of odd elements in the string i of the input.";
    
    for i := 0 to |lst|
        invariant |result| == i
        invariant forall j :: 0 <= j < i ==> 
            result[j] == ReplaceChar(template, 'i', IntToString(CountOddDigits(lst[j])))
    {
        var current_string := lst[i];
        var odd_count_val := CountOddDigits(current_string);
        var count_str := IntToString(odd_count_val);
        var formatted_string := ReplaceChar(template, 'i', count_str);
        result := result + [formatted_string];
    }
}

function IsDigit(c: char): bool
{
    '0' <= c <= '9'
}

function IsOddDigit(c: char): bool
    requires IsDigit(c)
{
    c == '1' || c == '3' || c == '5' || c == '7' || c == '9'
}

function CountOddDigits(s: string): int
    ensures CountOddDigits(s) >= 0
{
    if |s| == 0 then 0
    else
        var first_char := s[0];
        var rest_count := CountOddDigits(s[1..]);
        if IsDigit(first_char) && IsOddDigit(first_char) then
            1 + rest_count
        else
            rest_count
}

function ReplaceChar(s: string, old_char: char, new_str: string): string
    decreases |s|
{
    if |s| == 0 then ""
    else if s[0] == old_char then
        new_str + ReplaceChar(s[1..], old_char, new_str)
    else
        [s[0]] + ReplaceChar(s[1..], old_char, new_str)
}

function IntToString(n: int): string
    requires n >= 0
    decreases n
    ensures |IntToString(n)| > 0
{
    if n < 10 then
        [DigitToChar(n)]
    else
        IntToString(n / 10) + [DigitToChar(n % 10)]
}

function DigitToChar(digit: int): char
    requires 0 <= digit <= 9
{
    match digit
    case 0 => '0'
    case 1 => '1'
    case 2 => '2'
    case 3 => '3'
    case 4 => '4'
    case 5 => '5'
    case 6 => '6'
    case 7 => '7'
    case 8 => '8'
    case 9 => '9'
}
```

