=============== SYSTEM ===============
You are an expert programmer specializing in translating Python code to the Dafny verification language. Your task is to translate the provided Python function into a Dafny method that is both verifiable and compilable. Pay close attention to types, specifications, and providing concrete implementations for all methods.



=============== USER ===============
I will provide you with a Python function and its documentation. Please translate the Python function into a Dafny method.

**Python Function and Documentation:**
```python

def maximum(arr, k):
    """
    Given an array arr of integers and a positive integer k, return a sorted list 
    of length k with the maximum k numbers in arr.

    Example 1:

        Input: arr = [-3, -4, 5], k = 3
        Output: [-4, -3, 5]

    Example 2:

        Input: arr = [4, -4, 4], k = 2
        Output: [4, 4]

    Example 3:

        Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1
        Output: [2]

    Note:
        1. The length of the array will be in the range of [1, 1000].
        2. The elements in the array will be in the range of [-1000, 1000].
        3. 0 <= k <= len(arr)
    """

def maximum(arr, k):
    """
    Given an array arr of integers and a positive integer k, return a sorted list 
    of length k with the maximum k numbers in arr.

    Example 1:

        Input: arr = [-3, -4, 5], k = 3
        Output: [-4, -3, 5]

    Example 2:

        Input: arr = [4, -4, 4], k = 2
        Output: [4, 4]

    Example 3:

        Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1
        Output: [2]

    Note:
        1. The length of the array will be in the range of [1, 1000].
        2. The elements in the array will be in the range of [-1000, 1000].
        3. 0 <= k <= len(arr)
    """
    if k == 0:
        return []
    
    # Sort array in descending order and take first k elements
    sorted_desc = sorted(arr, reverse=True)
    k_largest = sorted_desc[:k]
    
    # Sort the k largest elements in ascending order
    return sorted(k_largest)
```

**Your Task:**
1.  **Reasoning (in a <thinking> block):**
    *   Analyze the Python code and its types. How will you map Python types (like lists of floats) to Dafny types (like `seq<real>`)?
    *   Analyze the function's logic. What are the pre-conditions (`requires`) and post-conditions (`ensures`)?
    *   Identify any loops and determine their invariants.
    *   Think about termination conditions for any recursive calls or loops.
2.  **Dafny Implementation (in a ```dafny ... ``` block):**
    *   Write the complete Dafny method, including its signature, `requires` clauses, `ensures` clauses, and the method body.
    *   **The return type of the main method must be a basic Dafny type.** Use `int`, `real`, `bool`, `string`, or a sequence of these types (e.g., `seq<int>`). Do not use custom `datatype`s in the return signature. If the Python code implies an optional return (e.g. returning `None`), you should return a sensible default for the basic type instead (e.g. `false`, `-1`, or an empty sequence `[]`).
    *   The Dafny method name must be exactly the same as the Python function name: `maximum`. Do not change the casing.
    *   **All methods must have a concrete implementation (a body).** The `{:axiom}` attribute is forbidden for defining standard functions. However, if the problem's solution relies on an unproven mathematical conjecture (e.g., the Goldbach Conjecture, P vs NP), you may state the conjecture as an `axiom`. If you do so, you **must** include a comment identifying the conjecture (e.g., `// Axiom for the Twin Prime Conjecture`). Do not use axioms to avoid implementing solvable algorithms.
    *   **Provide explicit termination proofs.** For any recursive function, you must include a `decreases` clause. Do **not** use `decreases *`. For functions that operate on a sequence, the termination metric is almost always the length of the sequence (e.g., `decreases my_sequence`). For functions on integers, it is the integer itself (e.g., `decreases n`).
    *   **Do not use Dafny reserved keywords as variable names.** Avoid names like: `abstract, allocated, as, assert, assume, bool, break, by, calc, case, char, class, codatatype, const, constructor, datatype, decreases, else, ensures, exists, export, extends, false, forall, fresh, function, ghost, if, imap, import, in, include, int, invariant, is, iset, iterator, label, lemma, map, match, method, modifies, modify, module, multiset, nameonly, nat, new, newtype, null, object, object?, old, opened, ORDINAL, predicate, print, provides,reads, real, refines, requires, return, returns, reveal, reveals, seq, set, static, string, then, this, trait, true, twostate, type, unchanged, var, while, witness, yield, yields`. For example, instead of `var array`, use `var arr`.



=============== ASSISTANT ===============
--- THINKING ---
Let me analyze this Python function:

1. **Function analysis:**
   - Takes an array `arr` of integers and a positive integer `k`
   - Returns a sorted list of length `k` with the maximum `k` numbers from `arr`
   - If `k == 0`, return empty list
   - Otherwise, sort array in descending order, take first `k` elements, then sort those in ascending order

2. **Type mapping:**
   - Python `list` of integers → Dafny `seq<int>`
   - Python `int` → Dafny `int`

3. **Pre-conditions:**
   - `k >= 0` (from the note that says `0 <= k <= len(arr)`)
   - `k <= |arr|` (length of array)
   - Array elements are in range `[-1000, 1000]` but this isn't strictly necessary for correctness
   - Array length is in range `[1, 1000]` but again not strictly necessary

4. **Post-conditions:**
   - Result has length `k`
   - Result is sorted in ascending order
   - All elements in result are from the original array
   - The result contains the `k` largest elements from the original array

5. **Algorithm:**
   - If `k == 0`, return empty sequence
   - Sort the array in descending order
   - Take the first `k` elements
   - Sort those `k` elements in ascending order
   - Return the result

6. **Implementation considerations:**
   - I need to implement sorting in Dafny
   - I need helper functions to sort sequences
   - I need to be careful about termination proofs

Let me implement this step by step:

1. First, I need a function to sort a sequence in ascending order
2. Then a function to sort in descending order
3. Then the main function that combines these

Actually, let me think about this more carefully. I can implement a generic sort function and use it twice with different comparisons.
 
Termination proofs rely on sequence length as a key metric. I'll use the sequence's size to ensure the sorting algorithm always converges, creating a provably correct recursive approach that guarantees the algorithm will complete.

--- RESPONSE ---
<thinking>
Let me analyze this Python function:

1. **Function analysis:**
   - Takes an array `arr` of integers and a positive integer `k`
   - Returns a sorted list of length `k` with the maximum `k` numbers from `arr`
   - If `k == 0`, return empty list
   - Algorithm: sort array descending, take first `k` elements, then sort those ascending

2. **Type mapping:**
   - Python `list` of integers → Dafny `seq<int>`
   - Python `int` → Dafny `int`

3. **Pre-conditions:**
   - `k >= 0` and `k <= |arr|` (from the note `0 <= k <= len(arr)`)
   - Array length >= 1 (from the note)

4. **Post-conditions:**
   - Result has length `k`
   - Result is sorted in ascending order
   - All elements in result are from the original array
   - The result contains the `k` largest elements from the original array

5. **Implementation strategy:**
   - I need helper functions to sort sequences
   - Use insertion sort for simplicity and easy verification
   - First sort descending to get k largest, then sort those ascending

6. **Termination:**
   - Sorting functions will use sequence length as decreasing measure
   - Main function doesn't recurse, so no decreases needed
</thinking>

```dafny
method maximum(arr: seq<int>, k: int) returns (result: seq<int>)
  requires k >= 0 && k <= |arr|
  requires |arr| >= 1
  ensures |result| == k
  ensures is_sorted_ascending(result)
  ensures forall x :: x in result ==> x in arr
  ensures k > 0 ==> (forall x :: x in result ==> (forall y :: y in arr && y !in result ==> x >= y))
{
  if k == 0 {
    return [];
  }
  
  var sorted_desc := sort_descending(arr);
  var k_largest := sorted_desc[..k];
  result := sort_ascending(k_largest);
}

predicate is_sorted_ascending(s: seq<int>)
{
  forall i, j :: 0 <= i < j < |s| ==> s[i] <= s[j]
}

predicate is_sorted_descending(s: seq<int>)
{
  forall i, j :: 0 <= i < j < |s| ==> s[i] >= s[j]
}

method sort_ascending(s: seq<int>) returns (result: seq<int>)
  ensures |result| == |s|
  ensures is_sorted_ascending(result)
  ensures forall x :: x in result ==> x in s
  ensures forall x :: x in s ==> x in result
  decreases |s|
{
  if |s| <= 1 {
    return s;
  }
  
  result := [s[0]];
  var i := 1;
  
  while i < |s|
    invariant 1 <= i <= |s|
    invariant |result| == i
    invariant is_sorted_ascending(result)
    invariant forall x :: x in result ==> x in s[..i]
    invariant forall x :: x in s[..i] ==> x in result
  {
    result := insert_ascending(result, s[i]);
    i := i + 1;
  }
}

method sort_descending(s: seq<int>) returns (result: seq<int>)
  ensures |result| == |s|
  ensures is_sorted_descending(result)
  ensures forall x :: x in result ==> x in s
  ensures forall x :: x in s ==> x in result
  decreases |s|
{
  if |s| <= 1 {
    return s;
  }
  
  result := [s[0]];
  var i := 1;
  
  while i < |s|
    invariant 1 <= i <= |s|
    invariant |result| == i
    invariant is_sorted_descending(result)
    invariant forall x :: x in result ==> x in s[..i]
    invariant forall x :: x in s[..i] ==> x in result
  {
    result := insert_descending(result, s[i]);
    i := i + 1;
  }
}

method insert_ascending(sorted_seq: seq<int>, elem: int) returns (result: seq<int>)
  requires is_sorted_ascending(sorted_seq)
  ensures |result| == |sorted_seq| + 1
  ensures is_sorted_ascending(result)
  ensures elem in result
  ensures forall x :: x in sorted_seq ==> x in result
  ensures forall x :: x in result ==> x == elem || x in sorted_seq
{
  var i := 0;
  while i < |sorted_seq| && sorted_seq[i] <= elem
    invariant 0 <= i <= |sorted_seq|
  {
    i := i + 1;
  }
  result := sorted_seq[..i] + [elem] + sorted_seq[i..];
}

method insert_descending(sorted_seq: seq<int>, elem: int) returns (result: seq<int>)
  requires is_sorted_descending(sorted_seq)
  ensures |result| == |sorted_seq| + 1
  ensures is_sorted_descending(result)
  ensures elem in result
  ensures forall x :: x in sorted_seq ==> x in result
  ensures forall x :: x in result ==> x == elem || x in sorted_seq
{
  var i := 0;
  while i < |sorted_seq| && sorted_seq[i] >= elem
    invariant 0 <= i <= |sorted_seq|
  {
    i := i + 1;
  }
  result := sorted_seq[..i] + [elem] + sorted_seq[i..];
}
```

