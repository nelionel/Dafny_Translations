=============== SYSTEM ===============
You are an expert programmer specializing in translating Python tests to the Dafny verification language. Your task is to translate Python `assert` statements into Dafny test methods and provide a minimal dummy implementation for compilation checking.



=============== USER ===============
I need you to translate Python test assertions into Dafny test methods.

**The Method to Test:**
The Dafny method you need to test is named `maximum`.

**Python Test Code:**
```python
def check(candidate):

    # Check some simple cases
    assert candidate([-3, -4, 5], 3) == [-4, -3, 5]
    assert candidate([4, -4, 4], 2) == [4, 4]
    assert candidate([-3, 2, 1, 2, -1, -2, 1], 1) == [2]
    assert candidate([123, -123, 20, 0 , 1, 2, -3], 3) == [2, 20, 123]
    assert candidate([-123, 20, 0 , 1, 2, -3], 4) == [0, 1, 2, 20]
    assert candidate([5, 15, 0, 3, -13, -8, 0], 7) == [-13, -8, 0, 0, 3, 5, 15]
    assert candidate([-1, 0, 2, 5, 3, -10], 2) == [3, 5]
    assert candidate([1, 0, 5, -7], 1) == [5]
    assert candidate([4, -4], 2) == [-4, 4]
    assert candidate([-10, 10], 2) == [-10, 10]

    # Check some edge cases that are easy to work out by hand.
    assert candidate([1, 2, 3, -23, 243, -400, 0], 0) == []


```

**Dafny Solution Code (that these tests should test):**
```dafny
method maximum(arr: seq<int>, k: int) returns (result: seq<int>)
  requires k >= 0 && k <= |arr|
  requires |arr| >= 1
  ensures |result| == k
  ensures is_sorted_ascending(result)
  ensures forall x :: x in result ==> x in arr
  ensures k > 0 ==> (forall x :: x in result ==> (forall y :: y in arr && y !in result ==> x >= y))
{
  if k == 0 {
    return [];
  }
  
  var sorted_desc := sort_descending(arr);
  var k_largest := sorted_desc[..k];
  result := sort_ascending(k_largest);
}

predicate is_sorted_ascending(s: seq<int>)
{
  forall i, j :: 0 <= i < j < |s| ==> s[i] <= s[j]
}

predicate is_sorted_descending(s: seq<int>)
{
  forall i, j :: 0 <= i < j < |s| ==> s[i] >= s[j]
}

method sort_ascending(s: seq<int>) returns (result: seq<int>)
  ensures |result| == |s|
  ensures is_sorted_ascending(result)
  ensures forall x :: x in result ==> x in s
  ensures forall x :: x in s ==> x in result
  decreases |s|
{
  if |s| <= 1 {
    return s;
  }
  
  result := [s[0]];
  var i := 1;
  
  while i < |s|
    invariant 1 <= i <= |s|
    invariant |result| == i
    invariant is_sorted_ascending(result)
    invariant forall x :: x in result ==> x in s[..i]
    invariant forall x :: x in s[..i] ==> x in result
  {
    result := insert_ascending(result, s[i]);
    i := i + 1;
  }
}

method sort_descending(s: seq<int>) returns (result: seq<int>)
  ensures |result| == |s|
  ensures is_sorted_descending(result)
  ensures forall x :: x in result ==> x in s
  ensures forall x :: x in s ==> x in result
  decreases |s|
{
  if |s| <= 1 {
    return s;
  }
  
  result := [s[0]];
  var i := 1;
  
  while i < |s|
    invariant 1 <= i <= |s|
    invariant |result| == i
    invariant is_sorted_descending(result)
    invariant forall x :: x in result ==> x in s[..i]
    invariant forall x :: x in s[..i] ==> x in result
  {
    result := insert_descending(result, s[i]);
    i := i + 1;
  }
}

method insert_ascending(sorted_seq: seq<int>, elem: int) returns (result: seq<int>)
  requires is_sorted_ascending(sorted_seq)
  ensures |result| == |sorted_seq| + 1
  ensures is_sorted_ascending(result)
  ensures elem in result
  ensures forall x :: x in sorted_seq ==> x in result
  ensures forall x :: x in result ==> x == elem || x in sorted_seq
{
  var i := 0;
  while i < |sorted_seq| && sorted_seq[i] <= elem
    invariant 0 <= i <= |sorted_seq|
  {
    i := i + 1;
  }
  result := sorted_seq[..i] + [elem] + sorted_seq[i..];
}

method insert_descending(sorted_seq: seq<int>, elem: int) returns (result: seq<int>)
  requires is_sorted_descending(sorted_seq)
  ensures |result| == |sorted_seq| + 1
  ensures is_sorted_descending(result)
  ensures elem in result
  ensures forall x :: x in sorted_seq ==> x in result
  ensures forall x :: x in result ==> x == elem || x in sorted_seq
{
  var i := 0;
  while i < |sorted_seq| && sorted_seq[i] >= elem
    invariant 0 <= i <= |sorted_seq|
  {
    i := i + 1;
  }
  result := sorted_seq[..i] + [elem] + sorted_seq[i..];
}
```

**Your Task:**
1. **Analyze the tests and solution:**
   - Note the exact name (`maximum`) and signature of the Dafny method from the provided solution code.

2. **Create a minimal dummy implementation** (in a `<dummy>` block):
   - Create a dummy version of the `maximum` Dafny method.
   - The dummy should have the same signature as the method in the full Dafny solution and return appropriate default values (0 for int, false for bool, [] for sequences, etc.).
   - This dummy is ONLY for validating that the test code compiles correctly.

3. **Translate the tests** (in a ```dafny ... ``` block):
   - For each `assert` statement in the Python code, create a Dafny test method with `{:test}` attribute.
   - **All generated test methods must have a complete body and be runnable.**
   - Name them `test_0`, `test_1`, etc.
   - Convert scientific notation (e.g., 1e-6) to decimal form (e.g., 0.000001).
   - Each test method should:
     a. Call the `maximum` Dafny method and assign the result to a variable.
     b. Use `expect` to check if the result matches the expected value.

**Example:** If Python has `assert add(2, 3) == 5`, the method to test is `add`, and the Dafny solution has `function add(a: int, b: int): int`, then:
<dummy>
function add(a: int, b: int): int
{
    0
}
</dummy>

```dafny
method {:test} test_0()
{
    var result := add(2, 3);
    expect result == 5;
}
```



=============== ASSISTANT ===============
--- THINKING ---
Let me analyze the Python test code and the Dafny solution code to understand what I need to do.

1. First, I need to look at the Dafny method signature:
   - Method name: `maximum`
   - Parameters: `arr: seq<int>, k: int`
   - Returns: `result: seq<int>`

2. Now I need to look at the Python test cases:
   - `candidate([-3, -4, 5], 3) == [-4, -3, 5]`
   - `candidate([4, -4, 4], 2) == [4, 4]`
   - `candidate([-3, 2, 1, 2, -1, -2, 1], 1) == [2]`
   - `candidate([123, -123, 20, 0 , 1, 2, -3], 3) == [2, 20, 123]`
   - `candidate([-123, 20, 0 , 1, 2, -3], 4) == [0, 1, 2, 20]`
   - `candidate([5, 15, 0, 3, -13, -8, 0], 7) == [-13, -8, 0, 0, 3, 5, 15]`
   - `candidate([-1, 0, 2, 5, 3, -10], 2) == [3, 5]`
   - `candidate([1, 0, 5, -7], 1) == [5]`
   - `candidate([4, -4], 2) == [-4, 4]`
   - `candidate([-10, 10], 2) == [-10, 10]`
   - `candidate([1, 2, 3, -23, 243, -400, 0], 0) == []`
   
I'll start by implementing a basic placeholder method that returns an empty sequence. I'll create Dafny test methods to verify the implementation, translating each Python test case into a corresponding Dafny test with `expect` assertions.

The dummy implementation will simply return an empty sequence, matching the method signature with a default return value. I'll then begin converting the test cases, starting with the first few test scenarios to ensure the method signature and basic structure are correct.

Each test method will call the `maximum` method with different input sequences and specified k values, checking the returned result against the expected output using `expect` statements. This approach allows systematic verification of the method's behavior across various input scenarios.

The tests cover different input types: sequences with positive and negative numbers, varying lengths, and different k values to ensure comprehensive method validation.

Key test scenarios include:
- Extracting top k elements from mixed number lists
- Handling edge cases like zero-length result
- Verifying correct sorting and selection of maximum values

The test suite methodically explores the `maximum` method's functionality through diverse input configurations.

--- RESPONSE ---
Looking at the Dafny solution code, I can see the method signature:
- Method name: `maximum`
- Parameters: `arr: seq<int>, k: int`  
- Returns: `result: seq<int>`

<dummy>
method maximum(arr: seq<int>, k: int) returns (result: seq<int>)
{
    return [];
}
</dummy>

```dafny
method {:test} test_0()
{
    var result := maximum([-3, -4, 5], 3);
    expect result == [-4, -3, 5];
}

method {:test} test_1()
{
    var result := maximum([4, -4, 4], 2);
    expect result == [4, 4];
}

method {:test} test_2()
{
    var result := maximum([-3, 2, 1, 2, -1, -2, 1], 1);
    expect result == [2];
}

method {:test} test_3()
{
    var result := maximum([123, -123, 20, 0, 1, 2, -3], 3);
    expect result == [2, 20, 123];
}

method {:test} test_4()
{
    var result := maximum([-123, 20, 0, 1, 2, -3], 4);
    expect result == [0, 1, 2, 20];
}

method {:test} test_5()
{
    var result := maximum([5, 15, 0, 3, -13, -8, 0], 7);
    expect result == [-13, -8, 0, 0, 3, 5, 15];
}

method {:test} test_6()
{
    var result := maximum([-1, 0, 2, 5, 3, -10], 2);
    expect result == [3, 5];
}

method {:test} test_7()
{
    var result := maximum([1, 0, 5, -7], 1);
    expect result == [5];
}

method {:test} test_8()
{
    var result := maximum([4, -4], 2);
    expect result == [-4, 4];
}

method {:test} test_9()
{
    var result := maximum([-10, 10], 2);
    expect result == [-10, 10];
}

method {:test} test_10()
{
    var result := maximum([1, 2, 3, -23, 243, -400, 0], 0);
    expect result == [];
}
```

