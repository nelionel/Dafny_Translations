=============== SYSTEM ===============
You are an expert programmer specializing in translating Python code to the Dafny verification language. Your task is to translate the provided Python function into a Dafny method that is both verifiable and compilable. Pay close attention to types, specifications, and providing concrete implementations for all methods.



=============== USER ===============
I will provide you with a Python function and its documentation. Please translate the Python function into a Dafny method.

**Python Function and Documentation:**
```python

def valid_date(date):
    """You have to write a function which validates a given date string and
    returns True if the date is valid otherwise False.
    The date is valid if all of the following rules are satisfied:
    1. The date string is not empty.
    2. The number of days is not less than 1 or higher than 31 days for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher than 30 days for months 4,6,9,11. And, the number of days is not less than 1 or higher than 29 for the month 2.
    3. The months should not be less than 1 or higher than 12.
    4. The date should be in the format: mm-dd-yyyy

    for example: 
    valid_date('03-11-2000') => True

    valid_date('15-01-2012') => False

    valid_date('04-0-2040') => False

    valid_date('06-04-2020') => True

    valid_date('06/04/2020') => False
    """

def valid_date(date):
    """You have to write a function which validates a given date string and
    returns True if the date is valid otherwise False.
    The date is valid if all of the following rules are satisfied:
    1. The date string is not empty.
    2. The number of days is not less than 1 or higher than 31 days for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher than 30 days for months 4,6,9,11. And, the number of days is not less than 1 or higher than 29 for the month 2.
    3. The months should not be less than 1 or higher than 12.
    4. The date should be in the format: mm-dd-yyyy

    for example: 
    valid_date('03-11-2000') => True

    valid_date('15-01-2012') => False

    valid_date('04-0-2040') => False

    valid_date('06-04-2020') => True

    valid_date('06/04/2020') => False
    """
    
    # Rule 1: Check if date string is not empty
    if not date:
        return False
    
    # Rule 4: Check if date is in correct format (mm-dd-yyyy)
    if date.count('-') != 2:
        return False
    
    parts = date.split('-')
    if len(parts) != 3:
        return False
    
    month_str, day_str, year_str = parts
    
    # Check if all parts are numeric
    if not (month_str.isdigit() and day_str.isdigit() and year_str.isdigit()):
        return False
    
    # Check if month and day have proper length (at least 1 digit)
    if len(month_str) == 0 or len(day_str) == 0 or len(year_str) == 0:
        return False
    
    # Convert to integers
    try:
        month = int(month_str)
        day = int(day_str)
        year = int(year_str)
    except ValueError:
        return False
    
    # Rule 3: Check if month is valid (1-12)
    if month < 1 or month > 12:
        return False
    
    # Rule 2: Check if day is valid based on the month
    # Months with 31 days: 1,3,5,7,8,10,12
    if month in [1, 3, 5, 7, 8, 10, 12]:
        if day < 1 or day > 31:
            return False
    # Months with 30 days: 4,6,9,11
    elif month in [4, 6, 9, 11]:
        if day < 1 or day > 30:
            return False
    # February (month 2) - max 29 days
    elif month == 2:
        if day < 1 or day > 29:
            return False
    
    return True
```

**Your Task:**
1.  **Reasoning (in a <thinking> block):**
    *   Analyze the Python code and its types. How will you map Python types (like lists of floats) to Dafny types (like `seq<real>`)?
    *   Analyze the function's logic. What are the pre-conditions (`requires`) and post-conditions (`ensures`)?
    *   Identify any loops and determine their invariants.
    *   Think about termination conditions for any recursive calls or loops.
2.  **Dafny Implementation (in a ```dafny ... ``` block):**
    *   Write the complete Dafny method, including its signature, `requires` clauses, `ensures` clauses, and the method body.
    *   **The return type of the main method must be a basic Dafny type.** Use `int`, `real`, `bool`, `string`, or a sequence of these types (e.g., `seq<int>`). Do not use custom `datatype`s in the return signature. If the Python code implies an optional return (e.g. returning `None`), you should return a sensible default for the basic type instead (e.g. `false`, `-1`, or an empty sequence `[]`).
    *   The Dafny method name must be exactly the same as the Python function name: `valid_date`. Do not change the casing.
    *   **All methods must have a concrete implementation (a body).** The `{:axiom}` attribute is forbidden for defining standard functions. However, if the problem's solution relies on an unproven mathematical conjecture (e.g., the Goldbach Conjecture, P vs NP), you may state the conjecture as an `axiom`. If you do so, you **must** include a comment identifying the conjecture (e.g., `// Axiom for the Twin Prime Conjecture`). Do not use axioms to avoid implementing solvable algorithms.
    *   **Provide explicit termination proofs.** For any recursive function, you must include a `decreases` clause. Do **not** use `decreases *`. For functions that operate on a sequence, the termination metric is almost always the length of the sequence (e.g., `decreases my_sequence`). For functions on integers, it is the integer itself (e.g., `decreases n`).
    *   **Do not use Dafny reserved keywords as variable names.** Avoid names like: `abstract, allocated, as, assert, assume, bool, break, by, calc, case, char, class, codatatype, const, constructor, datatype, decreases, else, ensures, exists, export, extends, false, forall, fresh, function, ghost, if, imap, import, in, include, int, invariant, is, iset, iterator, label, lemma, map, match, method, modifies, modify, module, multiset, nameonly, nat, new, newtype, null, object, object?, old, opened, ORDINAL, predicate, print, provides,reads, real, refines, requires, return, returns, reveal, reveals, seq, set, static, string, then, this, trait, true, twostate, type, unchanged, var, while, witness, yield, yields`. For example, instead of `var array`, use `var arr`.



=============== ASSISTANT ===============
--- THINKING ---
Let me analyze the Python function to understand what it does:

1. The function validates a date string and returns True if valid, False otherwise.
2. It checks:
   - The date string is not empty
   - The date is in format mm-dd-yyyy (with dashes, not slashes)
   - The month is between 1-12
   - The day is valid for the given month (31 days for months 1,3,5,7,8,10,12; 30 days for months 4,6,9,11; 29 days for month 2)

Now I need to translate this to Dafny:

1. The input will be a `string` and the output will be a `bool`
2. I need to implement string parsing functionality
3. I need helper functions to check if a string is all digits, to convert string to int, etc.

Let me think about the structure:
- I'll need a helper function to check if a string contains only digits
- I'll need a helper function to convert a string to an integer (if valid)
- I'll need to split the string by dashes
- I'll need to validate each part

For string operations in Dafny, I'll need to work with sequences of characters.

Let me start writing the Dafny code:

```dafny
method valid_date(date: string) returns (result: bool)
{
    // Rule 1: Check if date string is not empty
    if |date| == 0 {
        return false;
    }
    
    // Rule 4: Check if date is in correct format (mm-dd-yyyy)
    // Count dashes
    var dash_count := 0;
    var i := 0;
    while i < |date|
        invariant 0 <= i <= |date|
        invariant dash_count >= 0
    {
        if date[i] == '-' {
            dash_count := dash_count + 1;
        }
        i := i + 1;
    }
    
    if dash_count != 2 {
        return false;
    }
    
    // Split by dashes
    var parts := SplitByDash(date);
    if |parts| != 3 {
        return false;
    }
    
    var month_str := parts[0];
    var day_str := parts[1];
    var year_str := parts[2];
    
    // Validate that each part is non-empty and contains only numeric characters
    if |month_str| == 0 || |day_str| == 0 || |year_str| == 0 {
        return false;
    }
    
    if !IsAllDigits(month_str) || !IsAllDigits(day_str) || !IsAllDigits(year_str) {
        return false;
    }
    
    // Transform string components into integer values
    var month := StringToInt(month_str);
    var day := StringToInt(day_str);
    var year := StringToInt(year_str);
    
    // Validate month range
    if month < 1 || month > 12 {
        return false;
    }
    
    // Validate day range based on specific month constraints
    if month == 1 || month == 3 || month == 5 || month == 7 || month == 8 || month == 10 || month == 12 {
        if day < 1 || day > 31 {
            return false;
        }
    } else if month == 4 || month == 6 || month == 9 || month == 11 {
        if day < 1 || day > 30 {
            return false;
        }
    } else if month == 2 {
        if day < 1 || day > 29 {
            return false;
        }
    }
    
    return true;
}
```

I'll create utility functions to support date parsing and validation. These helper methods will break down strings, verify digit composition, and convert text to numeric values.

--- RESPONSE ---

--- THINKING ---
Let me analyze the Python function:

1. **Input/Output**: Takes a string, returns a boolean
2. **Logic**: 
   - Check if string is not empty
   - Check if format is mm-dd-yyyy (exactly 2 dashes)
   - Split by dashes and validate each part is numeric
   - Check month is 1-12
   - Check day is valid for the given month (31 days for 1,3,5,7,8,10,12; 30 days for 4,6,9,11; 29 days for 2)

For Dafny, I need:
- Helper functions to work with strings (check digits, convert to int, split by delimiter)
- Main validation logic

The key challenges:
- String manipulation in Dafny (working with sequences of chars)
- Parsing integers from strings
- Splitting strings by delimiter

Let me implement the helper functions first, then the main function.

--- RESPONSE ---
<thinking>
Let me analyze the Python function step by step:

1. **Input/Output**: Takes a string date, returns a boolean indicating validity
2. **Validation Rules**:
   - Date string must not be empty
   - Must be in format mm-dd-yyyy (exactly 2 dashes)
   - Month must be 1-12
   - Day must be valid for the month (31 days for 1,3,5,7,8,10,12; 30 days for 4,6,9,11; 29 days for 2)
   - All parts must be numeric

For Dafny implementation, I need:
- Helper functions for string operations (checking digits, converting to int, splitting by dashes)
- Main validation logic following the same structure as Python

Key considerations:
- Dafny strings are sequences of characters
- Need to handle string parsing carefully
- Need proper loop invariants for string processing
- Need decreases clauses for any recursive functions
</thinking>

```dafny
method IsAllDigits(s: string) returns (result: bool)
    requires |s| > 0
    ensures result <==> (forall i :: 0 <= i < |s| ==> '0' <= s[i] <= '9')
{
    var i := 0;
    while i < |s|
        invariant 0 <= i <= |s|
        invariant forall j :: 0 <= j < i ==> '0' <= s[j] <= '9'
    {
        if s[i] < '0' || s[i] > '9' {
            return false;
        }
        i := i + 1;
    }
    return true;
}

method StringToInt(s: string) returns (result: int)
    requires |s| > 0
    requires forall i :: 0 <= i < |s| ==> '0' <= s[i] <= '9'
    ensures result >= 0
{
    var i := 0;
    var value := 0;
    while i < |s|
        invariant 0 <= i <= |s|
        invariant value >= 0
    {
        var digit := (s[i] as int) - ('0' as int);
        value := value * 10 + digit;
        i := i + 1;
    }
    return value;
}

method SplitByDash(s: string) returns (parts: seq<string>)
    ensures |parts| >= 1
{
    if |s| == 0 {
        return [s];
    }
    
    var result := [];
    var start := 0;
    var i := 0;
    
    while i < |s|
        invariant 0 <= start <= i <= |s|
        invariant |result| >= 0
    {
        if s[i] == '-' {
            var part := s[start..i];
            result := result + [part];
            start := i + 1;
        }
        i := i + 1;
    }
    
    // Add the last part
    var last_part := s[start..];
    result := result + [last_part];
    
    return result;
}

method CountDashes(s: string) returns (count: int)
    ensures count >= 0
    ensures count <= |s|
{
    var i := 0;
    var dash_count := 0;
    
    while i < |s|
        invariant 0 <= i <= |s|
        invariant dash_count >= 0
    {
        if s[i] == '-' {
            dash_count := dash_count + 1;
        }
        i := i + 1;
    }
    
    return dash_count;
}

method valid_date(date: string) returns (result: bool)
{
    // Rule 1: Check if date string is not empty
    if |date| == 0 {
        return false;
    }
    
    // Rule 4: Check if date is in correct format (mm-dd-yyyy)
    var dash_count := CountDashes(date);
    if dash_count != 2 {
        return false;
    }
    
    // Split by dashes
    var parts := SplitByDash(date);
    if |parts| != 3 {
        return false;
    }
    
    var month_str := parts[0];
    var day_str := parts[1];
    var year_str := parts[2];
    
    // Check if all parts are non-empty
    if |month_str| == 0 || |day_str| == 0 || |year_str| == 0 {
        return false;
    }
    
    // Check if all parts are numeric
    var month_is_digits := IsAllDigits(month_str);
    var day_is_digits := IsAllDigits(day_str);
    var year_is_digits := IsAllDigits(year_str);
    
    if !month_is_digits || !day_is_digits || !year_is_digits {
        return false;
    }
    
    // Convert to integers
    var month := StringToInt(month_str);
    var day := StringToInt(day_str);
    var year := StringToInt(year_str);
    
    // Rule 3: Check if month is valid (1-12)
    if month < 1 || month > 12 {
        return false;
    }
    
    // Rule 2: Check if day is valid based on the month
    // Months with 31 days: 1,3,5,7,8,10,12
    if month == 1 || month == 3 || month == 5 || month == 7 || 
       month == 8 || month == 10 || month == 12 {
        if day < 1 || day > 31 {
            return false;
        }
    }
    // Months with 30 days: 4,6,9,11
    else if month == 4 || month == 6 || month == 9 || month == 11 {
        if day < 1 || day > 30 {
            return false;
        }
    }
    // February (month 2) - max 29 days
    else if month == 2 {
        if day < 1 || day > 29 {
            return false;
        }
    }
    
    return true;
}
```

