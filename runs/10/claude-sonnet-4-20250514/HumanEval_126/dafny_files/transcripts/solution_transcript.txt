=============== SYSTEM ===============
You are an expert programmer specializing in translating Python code to the Dafny verification language. Your task is to translate the provided Python function into a Dafny method that is both verifiable and compilable. Pay close attention to types, specifications, and providing concrete implementations for all methods.



=============== USER ===============
I will provide you with a Python function and its documentation. Please translate the Python function into a Dafny method.

**Python Function and Documentation:**
```python

def is_sorted(lst):
    '''
    Given a list of numbers, return whether or not they are sorted
    in ascending order. If list has more than 1 duplicate of the same
    number, return False. Assume no negative numbers and only integers.

    Examples
    is_sorted([5]) ➞ True
    is_sorted([1, 2, 3, 4, 5]) ➞ True
    is_sorted([1, 3, 2, 4, 5]) ➞ False
    is_sorted([1, 2, 3, 4, 5, 6]) ➞ True
    is_sorted([1, 2, 3, 4, 5, 6, 7]) ➞ True
    is_sorted([1, 3, 2, 4, 5, 6, 7]) ➞ False
    is_sorted([1, 2, 2, 3, 3, 4]) ➞ True
    is_sorted([1, 2, 2, 2, 3, 4]) ➞ False
    '''

def is_sorted(lst):
    '''
    Given a list of numbers, return whether or not they are sorted
    in ascending order. If list has more than 1 duplicate of the same
    number, return False. Assume no negative numbers and only integers.

    Examples
    is_sorted([5]) ➞ True
    is_sorted([1, 2, 3, 4, 5]) ➞ True
    is_sorted([1, 3, 2, 4, 5]) ➞ False
    is_sorted([1, 2, 3, 4, 5, 6]) ➞ True
    is_sorted([1, 2, 3, 4, 5, 6, 7]) ➞ True
    is_sorted([1, 3, 2, 4, 5, 6, 7]) ➞ False
    is_sorted([1, 2, 2, 3, 3, 4]) ➞ True
    is_sorted([1, 2, 2, 2, 3, 4]) ➞ False
    '''
    # Handle empty list or single element
    if len(lst) <= 1:
        return True
    
    # Check if list is sorted in ascending order
    for i in range(1, len(lst)):
        if lst[i] < lst[i-1]:
            return False
    
    # Count occurrences of each number
    from collections import Counter
    counts = Counter(lst)
    
    # Check if any number appears more than twice
    for count in counts.values():
        if count > 2:
            return False
    
    return True
```

**Your Task:**
1.  **Reasoning (in a <thinking> block):**
    *   Analyze the Python code and its types. How will you map Python types (like lists of floats) to Dafny types (like `seq<real>`)?
    *   Analyze the function's logic. What are the pre-conditions (`requires`) and post-conditions (`ensures`)?
    *   Identify any loops and determine their invariants.
    *   Think about termination conditions for any recursive calls or loops.
2.  **Dafny Implementation (in a ```dafny ... ``` block):**
    *   Write the complete Dafny method, including its signature, `requires` clauses, `ensures` clauses, and the method body.
    *   **The return type of the main method must be a basic Dafny type.** Use `int`, `real`, `bool`, `string`, or a sequence of these types (e.g., `seq<int>`). Do not use custom `datatype`s in the return signature. If the Python code implies an optional return (e.g. returning `None`), you should return a sensible default for the basic type instead (e.g. `false`, `-1`, or an empty sequence `[]`).
    *   The Dafny method name must be exactly the same as the Python function name: `is_sorted`. Do not change the casing.
    *   **All methods must have a concrete implementation (a body).** The `{:axiom}` attribute is forbidden for defining standard functions. However, if the problem's solution relies on an unproven mathematical conjecture (e.g., the Goldbach Conjecture, P vs NP), you may state the conjecture as an `axiom`. If you do so, you **must** include a comment identifying the conjecture (e.g., `// Axiom for the Twin Prime Conjecture`). Do not use axioms to avoid implementing solvable algorithms.
    *   **Provide explicit termination proofs.** For any recursive function, you must include a `decreases` clause. Do **not** use `decreases *`. For functions that operate on a sequence, the termination metric is almost always the length of the sequence (e.g., `decreases my_sequence`). For functions on integers, it is the integer itself (e.g., `decreases n`).
    *   **Do not use Dafny reserved keywords as variable names.** Avoid names like: `abstract, allocated, as, assert, assume, bool, break, by, calc, case, char, class, codatatype, const, constructor, datatype, decreases, else, ensures, exists, export, extends, false, forall, fresh, function, ghost, if, imap, import, in, include, int, invariant, is, iset, iterator, label, lemma, map, match, method, modifies, modify, module, multiset, nameonly, nat, new, newtype, null, object, object?, old, opened, ORDINAL, predicate, print, provides,reads, real, refines, requires, return, returns, reveal, reveals, seq, set, static, string, then, this, trait, true, twostate, type, unchanged, var, while, witness, yield, yields`. For example, instead of `var array`, use `var arr`.



=============== ASSISTANT ===============
--- THINKING ---
Let me analyze the Python function:

1. The function takes a list of integers
2. It returns True if:
   - The list is empty or has 1 element, OR
   - The list is sorted in ascending order AND no number appears more than 2 times
3. It returns False otherwise

Key observations:
- Input: sequence of integers (non-negative based on assumption)
- Output: boolean
- Logic: Check ascending order + check no element appears more than twice

For Dafny:
- Input type: `seq<int>` (sequence of integers)
- Output type: `bool`
- Need helper functions to count occurrences

Let me think about the algorithm:
1. Handle empty/single element case
2. Check if sorted in ascending order
3. Check if any element appears more than twice

For the counting part, I'll need a helper function to count occurrences of an element in a sequence.

Loop invariants for the sorting check:
- All elements from 0 to i-1 are in ascending order

Termination: The loop goes from 1 to length of sequence, so it terminates.

Let me write this out:

--- RESPONSE ---
<thinking>
Let me analyze the Python code:

1. **Types**: The function takes a list of integers and returns a boolean. In Dafny, this maps to `seq<int>` for the input and `bool` for the output.

2. **Logic Analysis**: 
   - Returns `True` for empty lists or single-element lists
   - Checks if the list is sorted in ascending order (non-decreasing)
   - Counts occurrences of each number and returns `False` if any number appears more than twice
   - Returns `True` if both conditions are satisfied

3. **Pre-conditions**: The function assumes non-negative integers only, so I should add a `requires` clause for this.

4. **Post-conditions**: The function should return `true` if and only if the sequence is non-decreasing and no element appears more than twice.

5. **Loop invariants**: For the sorting check loop, I need to maintain that all previously checked adjacent pairs are in non-decreasing order.

6. **Helper functions needed**: I need a function to count occurrences of an element in a sequence.

7. **Termination**: The main loop iterates through the sequence once, so it terminates when `i` reaches the length of the sequence.
</thinking>

```dafny
method is_sorted(lst: seq<int>) returns (result: bool)
    requires forall i :: 0 <= i < |lst| ==> lst[i] >= 0  // assume no negative numbers
    ensures result <==> (|lst| <= 1 || (IsSortedAscending(lst) && NoMoreThanTwoDuplicates(lst)))
{
    // Handle empty list or single element
    if |lst| <= 1 {
        return true;
    }
    
    // Check if list is sorted in ascending order
    var i := 1;
    while i < |lst|
        invariant 1 <= i <= |lst|
        invariant forall j :: 1 <= j < i ==> lst[j-1] <= lst[j]
        decreases |lst| - i
    {
        if lst[i] < lst[i-1] {
            return false;
        }
        i := i + 1;
    }
    
    // Check if any number appears more than twice
    i := 0;
    while i < |lst|
        invariant 0 <= i <= |lst|
        invariant forall j :: 0 <= j < i ==> CountOccurrences(lst, lst[j]) <= 2
        decreases |lst| - i
    {
        var count := CountOccurrences(lst, lst[i]);
        if count > 2 {
            return false;
        }
        i := i + 1;
    }
    
    return true;
}

function CountOccurrences(s: seq<int>, x: int): int
    ensures CountOccurrences(s, x) >= 0
    decreases s
{
    if |s| == 0 then 0
    else if s[0] == x then 1 + CountOccurrences(s[1..], x)
    else CountOccurrences(s[1..], x)
}

predicate IsSortedAscending(s: seq<int>)
{
    forall i :: 1 <= i < |s| ==> s[i-1] <= s[i]
}

predicate NoMoreThanTwoDuplicates(s: seq<int>)
{
    forall i :: 0 <= i < |s| ==> CountOccurrences(s, s[i]) <= 2
}
```

