=============== SYSTEM ===============
You are an expert in formal verification and Dafny specifications. Your task is to analyze whether Dafny method specifications properly describe the behavior of the corresponding Python function.

You will be given:
1. A Python function with its behavior
2. A Dafny method translation with specifications (requires, ensures clauses)

Your job is to determine if the Dafny specifications fully and accurately capture the Python function's behavior. If not, you should improve the specifications.

IMPORTANT: You must respond with EXACTLY one of these phrases:
- "THE SCRIPT HAS PROPER SPECS" - if the specifications correctly describe the function
- "THE SCRIPT HAD NOT A PROPER SPEC" - if the specifications need improvement

After this phrase, provide the complete Dafny code (either unchanged or with improved specifications).



=============== USER ===============
Please analyze whether the Dafny specifications properly describe the Python function behavior.

**Python Function:**
```python
def is_sorted(lst):
    '''
    Given a list of numbers, return whether or not they are sorted
    in ascending order. If list has more than 1 duplicate of the same
    number, return False. Assume no negative numbers and only integers.

    Examples
    is_sorted([5]) ➞ True
    is_sorted([1, 2, 3, 4, 5]) ➞ True
    is_sorted([1, 3, 2, 4, 5]) ➞ False
    is_sorted([1, 2, 3, 4, 5, 6]) ➞ True
    is_sorted([1, 2, 3, 4, 5, 6, 7]) ➞ True
    is_sorted([1, 3, 2, 4, 5, 6, 7]) ➞ False
    is_sorted([1, 2, 2, 3, 3, 4]) ➞ True
    is_sorted([1, 2, 2, 2, 3, 4]) ➞ False
    '''
    # Handle empty list or single element
    if len(lst) <= 1:
        return True
    
    # Check if list is sorted in ascending order
    for i in range(1, len(lst)):
        if lst[i] < lst[i-1]:
            return False
    
    # Count occurrences of each number
    from collections import Counter
    counts = Counter(lst)
    
    # Check if any number appears more than twice
    for count in counts.values():
        if count > 2:
            return False
    
    return True
```

**Current Dafny Code:**
```dafny
method is_sorted(lst: seq<int>) returns (result: bool)
    requires forall i :: 0 <= i < |lst| ==> lst[i] >= 0  // assume no negative numbers
    ensures result <==> (|lst| <= 1 || (IsSortedAscending(lst) && NoMoreThanTwoDuplicates(lst)))
{
    // Handle empty list or single element
    if |lst| <= 1 {
        return true;
    }
    
    // Check if list is sorted in ascending order
    var i := 1;
    while i < |lst|
        invariant 1 <= i <= |lst|
        invariant forall j :: 1 <= j < i ==> lst[j-1] <= lst[j]
        decreases |lst| - i
    {
        if lst[i] < lst[i-1] {
            return false;
        }
        i := i + 1;
    }
    
    // Check if any number appears more than twice
    i := 0;
    while i < |lst|
        invariant 0 <= i <= |lst|
        invariant forall j :: 0 <= j < i ==> CountOccurrences(lst, lst[j]) <= 2
        decreases |lst| - i
    {
        var count := CountOccurrences(lst, lst[i]);
        if count > 2 {
            return false;
        }
        i := i + 1;
    }
    
    return true;
}

function CountOccurrences(s: seq<int>, x: int): int
    ensures CountOccurrences(s, x) >= 0
    decreases s
{
    if |s| == 0 then 0
    else if s[0] == x then 1 + CountOccurrences(s[1..], x)
    else CountOccurrences(s[1..], x)
}

predicate IsSortedAscending(s: seq<int>)
{
    forall i :: 1 <= i < |s| ==> s[i-1] <= s[i]
}

predicate NoMoreThanTwoDuplicates(s: seq<int>)
{
    forall i :: 0 <= i < |s| ==> CountOccurrences(s, s[i]) <= 2
}
```

**Analysis Task:**
1. Compare the Python function's behavior with the Dafny specifications
2. Check if the `requires` clauses capture all preconditions
3. Check if the `ensures` clauses capture all postconditions and behavior
4. Verify that the specifications fully describe what the function does

**Response Format:**
Start with exactly one of these phrases:
- "THE SCRIPT HAS PROPER SPECS" (if specifications are adequate)
- "THE SCRIPT HAD NOT A PROPER SPEC" (if specifications need improvement)

Then provide the complete Dafny code. If improving specifications:
- Add missing `requires` clauses for preconditions
- Add missing `ensures` clauses for postconditions
- Ensure specifications capture the function's complete behavior
- Preserve the existing method implementation unchanged

 


=============== ASSISTANT ===============
--- THINKING ---
Let me analyze the Python function and the Dafny specifications carefully.

The Python function `is_sorted` does the following:
1. Returns True if the list has 0 or 1 elements
2. Checks if the list is sorted in ascending order (non-decreasing)
3. Counts occurrences of each number and returns False if any number appears more than twice
4. Returns True if both conditions above are satisfied

Looking at the Dafny specifications:

```dafny
requires forall i :: 0 <= i < |lst| ==> lst[i] >= 0  // assume no negative numbers
ensures result <==> (|lst| <= 1 || (IsSortedAscending(lst) && NoMoreThanTwoDuplicates(lst)))
```

The `requires` clause captures the precondition that there are no negative numbers, which matches the Python function's assumption.

The `ensures` clause says that the result is true if and only if:
- The list has length <= 1, OR
- The list is sorted in ascending order AND has no more than two duplicates of any number

Let me check if this matches the Python behavior:

1. If `len(lst) <= 1`, Python returns `True` - this matches the Dafny spec
2. For longer lists, Python checks:
   - If sorted in ascending order (non-decreasing)  
   - If no number appears more than twice
   - Returns True only if both conditions are met

The `IsSortedAscending` predicate is defined as:
```dafny
predicate IsSortedAscending(s: seq<int>)
{
    forall i :: 1 <= i < |s| ==> s[i-1] <= s[i]
}
```

This correctly captures non-decreasing order (which is ascending order allowing equal elements).

The `NoMoreThanTwoDuplicates` predicate is defined as:


```dafny
predicate NoMoreThanTwoDuplicates(s: seq<int>)
{
    forall i :: 0 <= i < |s| ==> CountOccurrences(s, s[i]) <= 2
}
```

I'll verify the predicate's logic for tracking element occurrences. It ensures that for each element in the sequence, its count does not exceed two. This matches the Python function's requirement of no more than two duplicates for any number.

The specification precisely captures the constraints of the original Python implementation, checking both the sorting order and duplicate count conditions systematically.

The test cases validate the predicate's behavior across different scenarios - single elements, strictly ascending sequences, sequences with repeated elements, and edge cases where an element appears more than twice.

--- RESPONSE ---
THE SCRIPT HAS PROPER SPECS

```dafny
method is_sorted(lst: seq<int>) returns (result: bool)
    requires forall i :: 0 <= i < |lst| ==> lst[i] >= 0  // assume no negative numbers
    ensures result <==> (|lst| <= 1 || (IsSortedAscending(lst) && NoMoreThanTwoDuplicates(lst)))
{
    // Handle empty list or single element
    if |lst| <= 1 {
        return true;
    }
    
    // Check if list is sorted in ascending order
    var i := 1;
    while i < |lst|
        invariant 1 <= i <= |lst|
        invariant forall j :: 1 <= j < i ==> lst[j-1] <= lst[j]
        decreases |lst| - i
    {
        if lst[i] < lst[i-1] {
            return false;
        }
        i := i + 1;
    }
    
    // Check if any number appears more than twice
    i := 0;
    while i < |lst|
        invariant 0 <= i <= |lst|
        invariant forall j :: 0 <= j < i ==> CountOccurrences(lst, lst[j]) <= 2
        decreases |lst| - i
    {
        var count := CountOccurrences(lst, lst[i]);
        if count > 2 {
            return false;
        }
        i := i + 1;
    }
    
    return true;
}

function CountOccurrences(s: seq<int>, x: int): int
    ensures CountOccurrences(s, x) >= 0
    decreases s
{
    if |s| == 0 then 0
    else if s[0] == x then 1 + CountOccurrences(s[1..], x)
    else CountOccurrences(s[1..], x)
}

predicate IsSortedAscending(s: seq<int>)
{
    forall i :: 1 <= i < |s| ==> s[i-1] <= s[i]
}

predicate NoMoreThanTwoDuplicates(s: seq<int>)
{
    forall i :: 0 <= i < |s| ==> CountOccurrences(s, s[i]) <= 2
}
```

