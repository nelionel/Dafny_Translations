=============== SYSTEM ===============
You are an expert programmer specializing in translating Python code to the Dafny verification language. Your task is to translate the provided Python function into a Dafny method that is both verifiable and compilable. Pay close attention to types, specifications, and providing concrete implementations for all methods.



=============== USER ===============
I will provide you with a Python function and its documentation. Please translate the Python function into a Dafny method.

**Python Function and Documentation:**
```python

def prod_signs(arr):
    """
    You are given an array arr of integers and you need to return
    sum of magnitudes of integers multiplied by product of all signs
    of each number in the array, represented by 1, -1 or 0.
    Note: return None for empty arr.

    Example:
    >>> prod_signs([1, 2, 2, -4]) == -9
    >>> prod_signs([0, 1]) == 0
    >>> prod_signs([]) == None
    """

def prod_signs(arr):
    """
    You are given an array arr of integers and you need to return
    sum of magnitudes of integers multiplied by product of all signs
    of each number in the array, represented by 1, -1 or 0.
    Note: return None for empty arr.

    Example:
    >>> prod_signs([1, 2, 2, -4]) == -9
    >>> prod_signs([0, 1]) == 0
    >>> prod_signs([]) == None
    """
    if not arr:
        return None
    
    sum_of_magnitudes = sum(abs(num) for num in arr)
    
    product_of_signs = 1
    for num in arr:
        if num > 0:
            product_of_signs *= 1
        elif num < 0:
            product_of_signs *= -1
        else:  # num == 0
            product_of_signs *= 0
    
    return sum_of_magnitudes * product_of_signs
```

**Your Task:**
1.  **Reasoning (in a <thinking> block):**
    *   Analyze the Python code and its types. How will you map Python types (like lists of floats) to Dafny types (like `seq<real>`)?
    *   Analyze the function's logic. What are the pre-conditions (`requires`) and post-conditions (`ensures`)?
    *   Identify any loops and determine their invariants.
    *   Think about termination conditions for any recursive calls or loops.
2.  **Dafny Implementation (in a ```dafny ... ``` block):**
    *   Write the complete Dafny method, including its signature, `requires` clauses, `ensures` clauses, and the method body.
    *   **The return type of the main method must be a basic Dafny type.** Use `int`, `real`, `bool`, `string`, or a sequence of these types (e.g., `seq<int>`). Do not use custom `datatype`s in the return signature. If the Python code implies an optional return (e.g. returning `None`), you should return a sensible default for the basic type instead (e.g. `false`, `-1`, or an empty sequence `[]`).
    *   The Dafny method name must be exactly the same as the Python function name: `prod_signs`. Do not change the casing.
    *   **All methods must have a concrete implementation (a body).** The `{:axiom}` attribute is forbidden for defining standard functions. However, if the problem's solution relies on an unproven mathematical conjecture (e.g., the Goldbach Conjecture, P vs NP), you may state the conjecture as an `axiom`. If you do so, you **must** include a comment identifying the conjecture (e.g., `// Axiom for the Twin Prime Conjecture`). Do not use axioms to avoid implementing solvable algorithms.
    *   **Provide explicit termination proofs.** For any recursive function, you must include a `decreases` clause. Do **not** use `decreases *`. For functions that operate on a sequence, the termination metric is almost always the length of the sequence (e.g., `decreases my_sequence`). For functions on integers, it is the integer itself (e.g., `decreases n`).
    *   **Do not use Dafny reserved keywords as variable names.** Avoid names like: `abstract, allocated, as, assert, assume, bool, break, by, calc, case, char, class, codatatype, const, constructor, datatype, decreases, else, ensures, exists, export, extends, false, forall, fresh, function, ghost, if, imap, import, in, include, int, invariant, is, iset, iterator, label, lemma, map, match, method, modifies, modify, module, multiset, nameonly, nat, new, newtype, null, object, object?, old, opened, ORDINAL, predicate, print, provides,reads, real, refines, requires, return, returns, reveal, reveals, seq, set, static, string, then, this, trait, true, twostate, type, unchanged, var, while, witness, yield, yields`. For example, instead of `var array`, use `var arr`.



=============== ASSISTANT ===============
--- THINKING ---
Let me analyze the Python function:

1. The function `prod_signs` takes an array of integers as input.
2. If the array is empty, it returns `None`.
3. Otherwise, it:
   - Computes the sum of absolute values (magnitudes) of all integers in the array
   - Computes the product of signs of all integers (1 for positive, -1 for negative, 0 for zero)
   - Returns the product of these two values

For the Dafny translation:
- Input: `seq<int>` (sequence of integers)
- Output: Since Python can return `None` for empty arrays, but Dafny needs a basic type, I'll return an `int`. For empty arrays, I can return 0 or some sentinel value like -1. Let me think... actually, looking at the examples, when there's a 0 in the array, the result is 0. So returning 0 for empty arrays seems reasonable.

Let me trace through the examples:
1. `prod_signs([1, 2, 2, -4])`:
   - sum of magnitudes: |1| + |2| + |2| + |-4| = 1 + 2 + 2 + 4 = 9
   - product of signs: 1 * 1 * 1 * (-1) = -1
   - result: 9 * (-1) = -9 ✓

2. `prod_signs([0, 1])`:
   - sum of magnitudes: |0| + |1| = 0 + 1 = 1
   - product of signs: 0 * 1 = 0
   - result: 1 * 0 = 0 ✓

3. `prod_signs([])`:
   - returns None in Python, but I'll return 0 in Dafny
   
I'll focus on designing a method that handles sign computation and magnitude summation efficiently. The key challenges will be creating a robust sign detection mechanism and managing array traversal to compute the required values. I'll need to carefully track both the sign product and magnitude sum during a single pass through the input sequence.

The implementation strategy will involve creating helper functions to determine number signs and aggregate the required computational components. This approach ensures a clean, modular solution that can handle various input scenarios systematically.

My core implementation will include special handling for empty arrays, using 0 as a sensible default return value. The method will track sign products and magnitude sums simultaneously, providing a comprehensive approach to the computational requirements.

I'll iterate through the array, carefully managing sign calculations and magnitude accumulation. The sign tracking uses multiplication to determine the overall sign, while magnitude tracking uses absolute value transformations. Each iteration updates these aggregate values systematically, ensuring comprehensive array processing.

The implementation maintains precise control flow, distinguishing between positive, negative, and zero elements through targeted conditional logic. This allows nuanced tracking of array characteristics while preserving computational efficiency.

I'm considering adding verification constraints to formalize the algorithm's expected behavior, potentially leveraging Dafny's specification capabilities to validate the method's correctness and boundary conditions.

--- RESPONSE ---
<thinking>
Let me analyze the Python function:

1. **Input/Output Types**: The function takes a list of integers and returns either an integer or None. In Dafny, I'll use `seq<int>` for the input and return `int`. Since Python returns `None` for empty arrays, I'll return 0 as a sensible default.

2. **Logic Analysis**: 
   - If array is empty, return None (I'll return 0)
   - Calculate sum of absolute values (magnitudes)
   - Calculate product of signs (1 for positive, -1 for negative, 0 for zero)
   - Return their product

3. **Examples verification**:
   - `[1, 2, 2, -4]`: sum_magnitudes = 9, product_signs = -1, result = -9
   - `[0, 1]`: sum_magnitudes = 1, product_signs = 0, result = 0
   - `[]`: return 0 (instead of None)

4. **Loop invariants**: I'll need to track the partial sums and products as I iterate through the array.

5. **Termination**: The while loop decreases by the remaining elements in the sequence.
</thinking>

```dafny
method prod_signs(arr: seq<int>) returns (result: int)
    ensures |arr| == 0 ==> result == 0
    ensures |arr| > 0 ==> result == sum_of_magnitudes(arr) * product_of_signs(arr)
{
    if |arr| == 0 {
        return 0;
    }
    
    var sum_of_magnitudes := 0;
    var product_of_signs := 1;
    var i := 0;
    
    while i < |arr|
        invariant 0 <= i <= |arr|
        invariant sum_of_magnitudes == sum_magnitudes_up_to(arr, i)
        invariant product_of_signs == product_signs_up_to(arr, i)
        decreases |arr| - i
    {
        // Add absolute value to sum
        sum_of_magnitudes := sum_of_magnitudes + (if arr[i] >= 0 then arr[i] else -arr[i]);
        
        // Multiply by sign
        if arr[i] > 0 {
            product_of_signs := product_of_signs * 1;
        } else if arr[i] < 0 {
            product_of_signs := product_of_signs * (-1);
        } else {
            product_of_signs := product_of_signs * 0;
        }
        
        i := i + 1;
    }
    
    result := sum_of_magnitudes * product_of_signs;
}

// Helper function to compute sum of magnitudes
function sum_of_magnitudes(arr: seq<int>): int
{
    if |arr| == 0 then 0
    else (if arr[0] >= 0 then arr[0] else -arr[0]) + sum_of_magnitudes(arr[1..])
}

// Helper function to compute product of signs
function product_of_signs(arr: seq<int>): int
{
    if |arr| == 0 then 1
    else sign(arr[0]) * product_of_signs(arr[1..])
}

// Helper function to get sign of a number
function sign(x: int): int
{
    if x > 0 then 1
    else if x < 0 then -1
    else 0
}

// Helper function for loop invariant - sum of magnitudes up to index i
function sum_magnitudes_up_to(arr: seq<int>, i: int): int
    requires 0 <= i <= |arr|
{
    if i == 0 then 0
    else sum_magnitudes_up_to(arr, i-1) + (if arr[i-1] >= 0 then arr[i-1] else -arr[i-1])
}

// Helper function for loop invariant - product of signs up to index i
function product_signs_up_to(arr: seq<int>, i: int): int
    requires 0 <= i <= |arr|
{
    if i == 0 then 1
    else product_signs_up_to(arr, i-1) * sign(arr[i-1])
}
```

