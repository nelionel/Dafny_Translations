=============== SYSTEM ===============
You are an expert programmer specializing in translating Python code to the Dafny verification language. Your task is to translate the provided Python function into a Dafny method that is both verifiable and compilable. Pay close attention to types, specifications, and providing concrete implementations for all methods.



=============== USER ===============
I will provide you with a Python function and its documentation. Please translate the Python function into a Dafny method.

**Python Function and Documentation:**
```python

def is_nested(string):
    '''
    Create a function that takes a string as input which contains only square brackets.
    The function should return True if and only if there is a valid subsequence of brackets 
    where at least one bracket in the subsequence is nested.

    is_nested('[[]]') ➞ True
    is_nested('[]]]]]]][[[[[]') ➞ False
    is_nested('[][]') ➞ False
    is_nested('[]') ➞ False
    is_nested('[[][]]') ➞ True
    is_nested('[[]][[') ➞ True
    '''

def is_nested(string):
    '''
    Create a function that takes a string as input which contains only square brackets.
    The function should return True if and only if there is a valid subsequence of brackets 
    where at least one bracket in the subsequence is nested.
    '''
    stack = []
    max_depth = 0
    current_depth = 0
    
    for char in string:
        if char == '[':
            stack.append(char)
            current_depth += 1
            max_depth = max(max_depth, current_depth)
        elif char == ']':
            if stack:  # Only pop if there's a matching opening bracket
                stack.pop()
                current_depth -= 1
    
    # We need at least one complete pair AND max depth > 1
    # If max_depth > current_depth, it means we had some complete pairs
    return max_depth > 1 and max_depth > current_depth
```

**Your Task:**
1.  **Reasoning (in a <thinking> block):**
    *   Analyze the Python code and its types. How will you map Python types (like lists of floats) to Dafny types (like `seq<real>`)?
    *   Analyze the function's logic. What are the pre-conditions (`requires`) and post-conditions (`ensures`)?
    *   Identify any loops and determine their invariants.
    *   Think about termination conditions for any recursive calls or loops.
2.  **Dafny Implementation (in a ```dafny ... ``` block):**
    *   Write the complete Dafny method, including its signature, `requires` clauses, `ensures` clauses, and the method body.
    *   **The return type of the main method must be a basic Dafny type.** Use `int`, `real`, `bool`, `string`, or a sequence of these types (e.g., `seq<int>`). Do not use custom `datatype`s in the return signature. If the Python code implies an optional return (e.g. returning `None`), you should return a sensible default for the basic type instead (e.g. `false`, `-1`, or an empty sequence `[]`).
    *   The Dafny method name must be exactly the same as the Python function name: `is_nested`. Do not change the casing.
    *   **All methods must have a concrete implementation (a body).** The `{:axiom}` attribute is forbidden for defining standard functions. However, if the problem's solution relies on an unproven mathematical conjecture (e.g., the Goldbach Conjecture, P vs NP), you may state the conjecture as an `axiom`. If you do so, you **must** include a comment identifying the conjecture (e.g., `// Axiom for the Twin Prime Conjecture`). Do not use axioms to avoid implementing solvable algorithms.
    *   **Provide explicit termination proofs.** For any recursive function, you must include a `decreases` clause. Do **not** use `decreases *`. For functions that operate on a sequence, the termination metric is almost always the length of the sequence (e.g., `decreases my_sequence`). For functions on integers, it is the integer itself (e.g., `decreases n`).
    *   **Do not use Dafny reserved keywords as variable names.** Avoid names like: `abstract, allocated, as, assert, assume, bool, break, by, calc, case, char, class, codatatype, const, constructor, datatype, decreases, else, ensures, exists, export, extends, false, forall, fresh, function, ghost, if, imap, import, in, include, int, invariant, is, iset, iterator, label, lemma, map, match, method, modifies, modify, module, multiset, nameonly, nat, new, newtype, null, object, object?, old, opened, ORDINAL, predicate, print, provides,reads, real, refines, requires, return, returns, reveal, reveals, seq, set, static, string, then, this, trait, true, twostate, type, unchanged, var, while, witness, yield, yields`. For example, instead of `var array`, use `var arr`.



=============== ASSISTANT ===============
--- THINKING ---
Let me analyze the Python function:

1. The function takes a string input and returns a boolean
2. The string contains only square brackets '[' and ']'
3. It should return True if there's a valid subsequence of brackets where at least one bracket is nested
4. The logic uses a stack to track opening brackets and keeps track of current depth and max depth
5. It returns true if max_depth > 1 AND max_depth > current_depth

Let me understand the algorithm:
- For each '[', we push to stack and increment current_depth, updating max_depth
- For each ']', if there's a matching '[' in stack, we pop and decrement current_depth
- The condition `max_depth > 1 and max_depth > current_depth` means:
  - max_depth > 1: We had at least 2 levels of nesting at some point
  - max_depth > current_depth: We had some complete pairs (since current_depth represents unmatched opening brackets)

For Dafny:
- Input: string (which maps to Dafny string)
- Output: bool
- I need to implement the stack logic using a sequence
- I need loop invariants for the for loop

Let me think about the invariants:
- The stack length should equal current_depth
- max_depth should be >= current_depth
- current_depth should be >= 0
- max_depth should be >= 0

For the requires clause:
- The string should only contain '[' and ']' characters

For the ensures clause:
- The result should be true iff there's a valid nested bracket subsequence

Let me implement this step by step:

```dafny
method is_nested(s: string) returns (result: bool)
    requires forall i :: 0 <= i < |s| ==> s[i] == '[' || s[i] == ']'
    ensures result <==> (exists max_d, final_d :: max_d > 1 && max_d > final_d && 
                         ValidBracketAnalysis(s, max_d, final_d))
{
    var stack: seq<char> := [];
    var max_depth := 0;
    var current_depth := 0;
    var i := 0;
    
    while i < |s|
        invariant 0 <= i <= |s|
        invariant |stack| == current_depth
        invariant current_depth >= 0
        invariant max_depth >= current_depth
        invariant max_depth >= 0
    {
        if s[i] == '[' {
            stack := stack + ['['];
            current_depth := current_depth + 1;
            max_depth := if current_depth > max_depth then current_depth else max_depth;
        } else {
            if |stack| > 0 {
                stack := stack[..|stack|-1];
                current_depth := current_depth - 1;
            }
        }
        i := i + 1;
    }

I'll continue tracking the stack's state, ensuring proper bracket matching and depth tracking. The key is maintaining the invariants while processing each character, updating the stack, current depth, and max depth accordingly.

--- RESPONSE ---
<thinking>
Let me analyze the Python function:

1. **Input/Output Types**: The function takes a string and returns a boolean. In Dafny, this maps to `string` input and `bool` output.

2. **Algorithm Logic**: 
   - Uses a stack to track opening brackets
   - Tracks current depth (number of unmatched opening brackets) and maximum depth reached
   - Returns true if max_depth > 1 AND max_depth > current_depth
   - The condition means: we had nesting (depth > 1) AND we had some complete bracket pairs (max_depth > remaining unmatched brackets)

3. **Preconditions**: The string should only contain '[' and ']' characters.

4. **Loop Invariants**: 
   - Stack size equals current_depth
   - current_depth >= 0 
   - max_depth >= current_depth
   - Loop index bounds

5. **Postconditions**: The result should correctly identify when there's valid nesting.

The algorithm essentially checks if we ever reached a depth > 1 and also had some brackets properly close (indicated by max_depth > current_depth at the end).
</thinking>

```dafny
method is_nested(s: string) returns (result: bool)
    requires forall i :: 0 <= i < |s| ==> s[i] == '[' || s[i] == ']'
    ensures result <==> (exists max_d, final_d :: max_d > 1 && max_d > final_d && ValidDepthAnalysis(s, max_d, final_d))
{
    var stack: seq<char> := [];
    var max_depth := 0;
    var current_depth := 0;
    var i := 0;
    
    while i < |s|
        invariant 0 <= i <= |s|
        invariant |stack| == current_depth
        invariant current_depth >= 0
        invariant max_depth >= current_depth
        invariant forall j :: 0 <= j < |stack| ==> stack[j] == '['
        decreases |s| - i
    {
        if s[i] == '[' {
            stack := stack + ['['];
            current_depth := current_depth + 1;
            if current_depth > max_depth {
                max_depth := current_depth;
            }
        } else { // s[i] == ']' by precondition
            if |stack| > 0 {
                stack := stack[..|stack|-1];
                current_depth := current_depth - 1;
            }
        }
        i := i + 1;
    }
    
    result := max_depth > 1 && max_depth > current_depth;
}

predicate ValidDepthAnalysis(s: string, max_d: int, final_d: int)
    requires forall i :: 0 <= i < |s| ==> s[i] == '[' || s[i] == ']'
{
    var depths := ComputeDepths(s);
    |depths| == |s| + 1 && 
    max_d == MaxInSeq(depths) &&
    final_d == depths[|depths|-1]
}

function ComputeDepths(s: string): seq<int>
    requires forall i :: 0 <= i < |s| ==> s[i] == '[' || s[i] == ']'
    decreases s
{
    if |s| == 0 then [0]
    else
        var prev_depths := ComputeDepths(s[..|s|-1]);
        var last_depth := prev_depths[|prev_depths|-1];
        if s[|s|-1] == '[' then
            prev_depths + [last_depth + 1]
        else // s[|s|-1] == ']'
            prev_depths + [if last_depth > 0 then last_depth - 1 else 0]
}

function MaxInSeq(depths: seq<int>): int
    requires |depths| > 0
    decreases depths
{
    if |depths| == 1 then depths[0]
    else
        var rest_max := MaxInSeq(depths[1..]);
        if depths[0] > rest_max then depths[0] else rest_max
}
```

