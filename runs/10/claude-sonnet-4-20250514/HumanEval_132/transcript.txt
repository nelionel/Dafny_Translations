======SYSTEM PROMPT======
You are a Python coding assistant. Your task is to write a Python script with the full implementation of the function described in the user prompt. The implementation should be inside a markdown code block.

======USER PROMPT======

def is_nested(string):
    '''
    Create a function that takes a string as input which contains only square brackets.
    The function should return True if and only if there is a valid subsequence of brackets 
    where at least one bracket in the subsequence is nested.

    is_nested('[[]]') ➞ True
    is_nested('[]]]]]]][[[[[]') ➞ False
    is_nested('[][]') ➞ False
    is_nested('[]') ➞ False
    is_nested('[[][]]') ➞ True
    is_nested('[[]][[') ➞ True
    '''


======MODEL OUTPUT======
Looking at this problem, I need to find if there's a valid subsequence of brackets where at least one bracket is nested (i.e., has depth > 1).

Let me analyze the examples:
- `'[[]]'` → True (inner brackets are nested inside outer ones)
- `'[]]]]]]][[[[[]'` → False (no valid complete nesting)
- `'[][]'` → False (no nesting, just adjacent pairs)
- `'[]'` → False (single pair, no nesting)
- `'[[][]]'` → True (middle `[]` is nested)
- `'[[]][[`' → True (first part has nesting)

The key insight is that I need to:
1. Find a valid subsequence of brackets (properly matched)
2. Check if any bracket in that subsequence has a nesting depth > 1

My approach:
1. Use a greedy algorithm to find the longest valid bracket subsequence
2. Track the maximum depth reached during the matching process
3. Return True if max depth > 1

```python
def is_nested(string):
    '''
    Create a function that takes a string as input which contains only square brackets.
    The function should return True if and only if there is a valid subsequence of brackets 
    where at least one bracket in the subsequence is nested.
    '''
    stack = []
    max_depth = 0
    current_depth = 0
    
    for char in string:
        if char == '[':
            stack.append(char)
            current_depth += 1
            max_depth = max(max_depth, current_depth)
        elif char == ']':
            if stack:  # Only pop if there's a matching opening bracket
                stack.pop()
                current_depth -= 1
    
    # We need at least one complete pair AND max depth > 1
    # If max_depth > current_depth, it means we had some complete pairs
    return max_depth > 1 and max_depth > current_depth
```