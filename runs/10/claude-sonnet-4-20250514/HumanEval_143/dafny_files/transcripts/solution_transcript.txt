=============== SYSTEM ===============
You are an expert programmer specializing in translating Python code to the Dafny verification language. Your task is to translate the provided Python function into a Dafny method that is both verifiable and compilable. Pay close attention to types, specifications, and providing concrete implementations for all methods.



=============== USER ===============
I will provide you with a Python function and its documentation. Please translate the Python function into a Dafny method.

**Python Function and Documentation:**
```python

def words_in_sentence(sentence):
    """
    You are given a string representing a sentence,
    the sentence contains some words separated by a space,
    and you have to return a string that contains the words from the original sentence,
    whose lengths are prime numbers,
    the order of the words in the new string should be the same as the original one.

    Example 1:
        Input: sentence = "This is a test"
        Output: "is"

    Example 2:
        Input: sentence = "lets go for swimming"
        Output: "go for"

    Constraints:
        * 1 <= len(sentence) <= 100
        * sentence contains only letters
    """

def words_in_sentence(sentence):
    """
    You are given a string representing a sentence,
    the sentence contains some words separated by a space,
    and you have to return a string that contains the words from the original sentence,
    whose lengths are prime numbers,
    the order of the words in the new string should be the same as the original one.

    Example 1:
        Input: sentence = "This is a test"
        Output: "is"

    Example 2:
        Input: sentence = "lets go for swimming"
        Output: "go for"

    Constraints:
        * 1 <= len(sentence) <= 100
        * sentence contains only letters
    """
    def is_prime(n):
        """Check if a number is prime"""
        if n < 2:
            return False
        if n == 2:
            return True
        if n % 2 == 0:
            return False
        
        # Check odd divisors up to sqrt(n)
        for i in range(3, int(n**0.5) + 1, 2):
            if n % i == 0:
                return False
        return True
    
    # Split sentence into words
    words = sentence.split()
    
    # Filter words whose lengths are prime numbers
    prime_length_words = []
    for word in words:
        if is_prime(len(word)):
            prime_length_words.append(word)
    
    # Join the filtered words back into a string
    return " ".join(prime_length_words)
```

**Your Task:**
1.  **Reasoning (in a <thinking> block):**
    *   Analyze the Python code and its types. How will you map Python types (like lists of floats) to Dafny types (like `seq<real>`)?
    *   Analyze the function's logic. What are the pre-conditions (`requires`) and post-conditions (`ensures`)?
    *   Identify any loops and determine their invariants.
    *   Think about termination conditions for any recursive calls or loops.
2.  **Dafny Implementation (in a ```dafny ... ``` block):**
    *   Write the complete Dafny method, including its signature, `requires` clauses, `ensures` clauses, and the method body.
    *   **The return type of the main method must be a basic Dafny type.** Use `int`, `real`, `bool`, `string`, or a sequence of these types (e.g., `seq<int>`). Do not use custom `datatype`s in the return signature. If the Python code implies an optional return (e.g. returning `None`), you should return a sensible default for the basic type instead (e.g. `false`, `-1`, or an empty sequence `[]`).
    *   The Dafny method name must be exactly the same as the Python function name: `words_in_sentence`. Do not change the casing.
    *   **All methods must have a concrete implementation (a body).** The `{:axiom}` attribute is forbidden for defining standard functions. However, if the problem's solution relies on an unproven mathematical conjecture (e.g., the Goldbach Conjecture, P vs NP), you may state the conjecture as an `axiom`. If you do so, you **must** include a comment identifying the conjecture (e.g., `// Axiom for the Twin Prime Conjecture`). Do not use axioms to avoid implementing solvable algorithms.
    *   **Provide explicit termination proofs.** For any recursive function, you must include a `decreases` clause. Do **not** use `decreases *`. For functions that operate on a sequence, the termination metric is almost always the length of the sequence (e.g., `decreases my_sequence`). For functions on integers, it is the integer itself (e.g., `decreases n`).
    *   **Do not use Dafny reserved keywords as variable names.** Avoid names like: `abstract, allocated, as, assert, assume, bool, break, by, calc, case, char, class, codatatype, const, constructor, datatype, decreases, else, ensures, exists, export, extends, false, forall, fresh, function, ghost, if, imap, import, in, include, int, invariant, is, iset, iterator, label, lemma, map, match, method, modifies, modify, module, multiset, nameonly, nat, new, newtype, null, object, object?, old, opened, ORDINAL, predicate, print, provides,reads, real, refines, requires, return, returns, reveal, reveals, seq, set, static, string, then, this, trait, true, twostate, type, unchanged, var, while, witness, yield, yields`. For example, instead of `var array`, use `var arr`.



=============== ASSISTANT ===============
--- THINKING ---
Let me analyze the Python code step by step:

1. **Types analysis:**
   - Input: `sentence` is a string
   - Output: a string (filtered words joined by spaces)
   - The function uses string operations like `split()` and `join()`
   - It uses a helper function `is_prime()` that takes an int and returns bool

2. **Logic analysis:**
   - Split the sentence into words by spaces
   - For each word, check if its length is a prime number
   - Keep words whose lengths are prime
   - Join them back with spaces

3. **Pre-conditions:**
   - The constraint says 1 <= len(sentence) <= 100
   - The sentence contains only letters (and spaces)

4. **Post-conditions:**
   - The result should contain only words from the original sentence whose lengths are prime
   - The order should be preserved
   - Words should be separated by single spaces

5. **Loops:**
   - There's a loop in `is_prime()` that checks divisors
   - There's a loop that iterates through words

Let me think about the Dafny implementation:

1. I need to implement a helper method `is_prime(n: int) -> bool`
2. I need to split the string into words - Dafny doesn't have a built-in split, so I'll need to implement this
3. I need to filter words based on prime length
4. I need to join them back

For string splitting in Dafny, I'll need to iterate through characters and build words.

Let me structure this:

```dafny
method words_in_sentence(sentence: string) returns (result: string)
  requires |sentence| >= 1 && |sentence| <= 100
{
  // First, split sentence into words
  var words := split_by_space(sentence);
  
  // Filter words whose lengths are prime
  var prime_words: seq<string> := [];
  
  I'll implement a loop to iterate through words, checking their length for primality. The loop will build a sequence of prime-length words by adding qualifying words. This approach ensures we preserve the original order while filtering based on word length. The invariant will track the current index and the growing sequence of prime-length words.

  for i := 0 to |words|
    invariant 0 <= i <= |words|
    invariant |prime_words| <= i
  {
    if is_prime(|words[i]|) {
      prime_words := prime_words + [words[i]];
    }
  }
  
  // Join back with spaces
  result := join_with_space(prime_words);
}
```

I'll focus on implementing the core helper methods needed for this function. The key challenge is creating custom string manipulation methods in Dafny that mimic Python's built-in string operations.

method is_prime(n: int) returns (result: bool)
  requires n >= 0
{
  if n < 2 {
    result := false;
  } else if n == 2 {
    result := true;
  } else if n % 2 == 0 {
    result := false;
  } else {
    result := true;
    var i := 3;
    while i * i <= n
      invariant i >= 3
      invariant i % 2 == 1
      invariant result ==> forall k :: 3 <= k < i && k % 2 == 1 ==> n % k != 0
      decreases n - i * i
    {
      if n % i == 0 {
        result := false;
        break;
      }
      i := i + 2;
    }
  }
}

For splitting, I nee

I'll implement a method to break a string into words by iterating through its characters. The approach tracks the current word, adding it to a sequence when a space is encountered. It handles edge cases like empty strings and ensures the last word is captured if the string doesn't end with a space.

The method maintains an invariant tracking the current index and builds a sequence of words dynamically. It carefully manages word construction by appending characters and resetting the current word when spaces are found.

Joining words involves concatenating them with spaces between, carefully handling the first word to avoid leading spaces.

--- RESPONSE ---
<thinking>
Let me analyze the Python code step by step:

1. **Types analysis:**
   - Input: `sentence` is a string
   - Output: a string (filtered words joined by spaces)
   - The function uses a helper `is_prime()` that takes an int and returns bool

2. **Logic analysis:**
   - Split the sentence into words by spaces
   - For each word, check if its length is a prime number
   - Keep words whose lengths are prime
   - Join them back with spaces

3. **Pre-conditions:**
   - The constraint says 1 <= len(sentence) <= 100
   - The sentence contains only letters and spaces

4. **Post-conditions:**
   - The result should contain only words from the original sentence whose lengths are prime
   - The order should be preserved
   - Words should be separated by single spaces

5. **Loops:**
   - There's a loop in `is_prime()` that checks divisors up to sqrt(n)
   - There's a loop that iterates through words

For Dafny implementation, I need:
1. A helper method `is_prime(n: int) -> bool`
2. A method to split the string into words (Dafny doesn't have built-in split)
3. Logic to filter words based on prime length
4. A method to join words back with spaces

The main challenge is implementing string splitting and joining in Dafny, since these aren't built-in operations.
</thinking>

```dafny
method words_in_sentence(sentence: string) returns (result: string)
  requires |sentence| >= 1 && |sentence| <= 100
  ensures |result| <= |sentence|
{
  // Split sentence into words
  var words := split_by_space(sentence);
  
  // Filter words whose lengths are prime
  var prime_words: seq<string> := [];
  var i := 0;
  while i < |words|
    invariant 0 <= i <= |words|
    invariant |prime_words| <= i
    decreases |words| - i
  {
    var word_length := |words[i]|;
    var is_prime_length := is_prime(word_length);
    if is_prime_length {
      prime_words := prime_words + [words[i]];
    }
    i := i + 1;
  }
  
  // Join filtered words back with spaces
  result := join_with_space(prime_words);
}

method is_prime(n: int) returns (result: bool)
  requires n >= 0
{
  if n < 2 {
    result := false;
  } else if n == 2 {
    result := true;
  } else if n % 2 == 0 {
    result := false;
  } else {
    result := true;
    var i := 3;
    while i * i <= n
      invariant i >= 3
      invariant i % 2 == 1
      invariant result ==> forall k :: 3 <= k < i && k % 2 == 1 ==> n % k != 0
      decreases n - i * i + 1
    {
      if n % i == 0 {
        result := false;
        break;
      }
      i := i + 2;
    }
  }
}

method split_by_space(s: string) returns (words: seq<string>)
  ensures |words| >= 0
{
  words := [];
  if |s| == 0 {
    return;
  }
  
  var current_word := "";
  var i := 0;
  
  while i < |s|
    invariant 0 <= i <= |s|
    decreases |s| - i
  {
    if s[i] == ' ' {
      if |current_word| > 0 {
        words := words + [current_word];
        current_word := "";
      }
    } else {
      current_word := current_word + [s[i]];
    }
    i := i + 1;
  }
  
  // Add the last word if it's not empty
  if |current_word| > 0 {
    words := words + [current_word];
  }
}

method join_with_space(words: seq<string>) returns (result: string)
{
  result := "";
  var i := 0;
  while i < |words|
    invariant 0 <= i <= |words|
    decreases |words| - i
  {
    if i > 0 {
      result := result + " ";
    }
    result := result + words[i];
    i := i + 1;
  }
}
```

