=============== SYSTEM ===============
You are an expert in formal verification and Dafny specifications. Your task is to analyze whether Dafny method specifications properly describe the behavior of the corresponding Python function.

You will be given:
1. A Python function with its behavior
2. A Dafny method translation with specifications (requires, ensures clauses)

Your job is to determine if the Dafny specifications fully and accurately capture the Python function's behavior. If not, you should improve the specifications.

IMPORTANT: You must respond with EXACTLY one of these phrases:
- "THE SCRIPT HAS PROPER SPECS" - if the specifications correctly describe the function
- "THE SCRIPT HAD NOT A PROPER SPEC" - if the specifications need improvement

After this phrase, provide the complete Dafny code (either unchanged or with improved specifications).



=============== USER ===============
Please analyze whether the Dafny specifications properly describe the Python function behavior.

**Python Function:**
```python
def order_by_points(nums):
    """
    Write a function which sorts the given list of integers
    in ascending order according to the sum of their digits.
    Note: if there are several items with similar sum of their digits,
    order them based on their index in original list.

    For example:
    >>> order_by_points([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]
    >>> order_by_points([]) == []
    """
    def digit_sum(n):
        # Convert to string to handle digits
        s = str(abs(n))  # Use absolute value to get digits
        total = sum(int(digit) for digit in s)
        
        # For negative numbers, subtract the first digit once more
        # This accounts for the negative sign affecting the first digit
        if n < 0:
            total -= 2 * int(s[0])
        
        return total
    
    # Create list of (original_index, number, digit_sum) tuples
    indexed_nums = [(i, num, digit_sum(num)) for i, num in enumerate(nums)]
    
    # Sort by digit sum first, then by original index for stability
    indexed_nums.sort(key=lambda x: (x[2], x[0]))
    
    # Extract just the numbers from the sorted list
    return [num for _, num, _ in indexed_nums]
```

**Current Dafny Code:**
```dafny
datatype IndexedNum = IndexedNum(index: int, value: int, digitSum: int)

method order_by_points(nums: seq<int>) returns (result: seq<int>)
    ensures |result| == |nums|
    ensures multiset(result) == multiset(nums)
{
    if |nums| == 0 {
        return [];
    }
    
    // Create indexed numbers with digit sums
    var indexedNums := seq(|nums|, i requires 0 <= i < |nums| => 
        IndexedNum(i, nums[i], digit_sum(nums[i])));
    
    // Sort the indexed numbers
    var sortedIndexed := sort_indexed_nums(indexedNums);
    
    // Extract just the values
    result := seq(|sortedIndexed|, i requires 0 <= i < |sortedIndexed| => 
        sortedIndexed[i].value);
}

function digit_sum(n: int): int
{
    if n >= 0 then
        digit_sum_positive(n)
    else
        digit_sum_negative(n)
}

function digit_sum_positive(n: int): int
    requires n >= 0
    decreases n
{
    if n < 10 then n
    else (n % 10) + digit_sum_positive(n / 10)
}

function digit_sum_negative(n: int): int
    requires n < 0
{
    var abs_n := -n;
    var total := digit_sum_positive(abs_n);
    var first_digit := get_first_digit(abs_n);
    total - 2 * first_digit
}

function get_first_digit(n: int): int
    requires n > 0
    decreases n
{
    if n < 10 then n
    else get_first_digit(n / 10)
}

method sort_indexed_nums(nums: seq<IndexedNum>) returns (sorted: seq<IndexedNum>)
    ensures |sorted| == |nums|
    ensures multiset(sorted) == multiset(nums)
    ensures forall i, j :: 0 <= i < j < |sorted| ==> 
        (sorted[i].digitSum < sorted[j].digitSum || 
         (sorted[i].digitSum == sorted[j].digitSum && sorted[i].index < sorted[j].index))
{
    if |nums| <= 1 {
        return nums;
    }
    
    sorted := merge_sort_indexed(nums);
}

method merge_sort_indexed(nums: seq<IndexedNum>) returns (sorted: seq<IndexedNum>)
    ensures |sorted| == |nums|
    ensures multiset(sorted) == multiset(nums)
    ensures forall i, j :: 0 <= i < j < |sorted| ==> 
        (sorted[i].digitSum < sorted[j].digitSum || 
         (sorted[i].digitSum == sorted[j].digitSum && sorted[i].index < sorted[j].index))
    decreases nums
{
    if |nums| <= 1 {
        return nums;
    }
    
    var mid := |nums| / 2;
    var left := nums[..mid];
    var right := nums[mid..];
    
    var sorted_left := merge_sort_indexed(left);
    var sorted_right := merge_sort_indexed(right);
    
    sorted := merge_indexed(sorted_left, sorted_right);
}

method merge_indexed(left: seq<IndexedNum>, right: seq<IndexedNum>) returns (merged: seq<IndexedNum>)
    requires forall i, j :: 0 <= i < j < |left| ==> 
        (left[i].digitSum < left[j].digitSum || 
         (left[i].digitSum == left[j].digitSum && left[i].index < left[j].index))
    requires forall i, j :: 0 <= i < j < |right| ==> 
        (right[i].digitSum < right[j].digitSum || 
         (right[i].digitSum == right[j].digitSum && right[i].index < right[j].index))
    ensures |merged| == |left| + |right|
    ensures multiset(merged) == multiset(left) + multiset(right)
    ensures forall i, j :: 0 <= i < j < |merged| ==> 
        (merged[i].digitSum < merged[j].digitSum || 
         (merged[i].digitSum == merged[j].digitSum && merged[i].index < merged[j].index))
{
    merged := [];
    var i, j := 0, 0;
    
    while i < |left| || j < |right|
        invariant 0 <= i <= |left|
        invariant 0 <= j <= |right|
        invariant |merged| == i + j
        invariant multiset(merged) == multiset(left[..i]) + multiset(right[..j])
        invariant forall k, l :: 0 <= k < l < |merged| ==> 
            (merged[k].digitSum < merged[l].digitSum || 
             (merged[k].digitSum == merged[l].digitSum && merged[k].index < merged[l].index))
    {
        if i >= |left| {
            merged := merged + [right[j]];
            j := j + 1;
        } else if j >= |right| {
            merged := merged + [left[i]];
            i := i + 1;
        } else if should_come_first(left[i], right[j]) {
            merged := merged + [left[i]];
            i := i + 1;
        } else {
            merged := merged + [right[j]];
            j := j + 1;
        }
    }
}

predicate should_come_first(a: IndexedNum, b: IndexedNum)
{
    a.digitSum < b.digitSum || (a.digitSum == b.digitSum && a.index < b.index)
}
```

**Analysis Task:**
1. Compare the Python function's behavior with the Dafny specifications
2. Check if the `requires` clauses capture all preconditions
3. Check if the `ensures` clauses capture all postconditions and behavior
4. Verify that the specifications fully describe what the function does

**Response Format:**
Start with exactly one of these phrases:
- "THE SCRIPT HAS PROPER SPECS" (if specifications are adequate)
- "THE SCRIPT HAD NOT A PROPER SPEC" (if specifications need improvement)

Then provide the complete Dafny code. If improving specifications:
- Add missing `requires` clauses for preconditions
- Add missing `ensures` clauses for postconditions
- Ensure specifications capture the function's complete behavior
- Preserve the existing method implementation unchanged

 


=============== ASSISTANT ===============
--- THINKING ---
Let me analyze the Python function behavior and compare it with the Dafny specifications.

**Python Function Analysis:**
1. The function takes a list of integers and sorts them by the sum of their digits.
2. For negative numbers, the digit sum calculation is special: it uses `abs(n)` to get digits, sums them, but then for negative numbers subtracts `2 * int(s[0])` where `s[0]` is the first digit of the absolute value.
3. If multiple numbers have the same digit sum, they should be ordered by their original index in the list.
4. The function returns a new list with the same elements but in the sorted order.

**Dafny Code Analysis:**
Looking at the main method `order_by_points`:
- It ensures `|result| == |nums|` - correct, preserves length
- It ensures `multiset(result) == multiset(nums)` - correct, preserves elements

But I need to check if the main specification captures the sorting behavior. The current specification only says:
1. Same length
2. Same elements (as multiset)

But it doesn't specify the sorting behavior! The sorting behavior is only specified in the helper methods like `sort_indexed_nums` and `merge_sort_indexed`, but the main method doesn't ensure that the result is actually sorted according to digit sum and original index.

Let me look at what the main postcondition should be:
- The result should be sorted by digit sum (ascending)
- For elements with the same digit sum, they should be sorted by original index

The current specification is missing this crucial sorting property in the main method `order_by_points`. 

So the specification is incomplete. I need to add an ensures clause that captures the sorting behavior.

The proper specification should ensure that:
```dafny
ensures forall i, j :: 0 <= i < j < |result| ==>
    (digit_sum(result[i]) < digit_sum(result[j]) ||
     (digit_sum(result[i]) == digit_sum(result[j]) && 
      index_of(result[i], nums) < index_of(result[j], nums)))
```

I realize the complexity lies in tracking original indices. The sorting mechanism relies on creating a stable sort that preserves the initial order when digit sums are equal. This requires a careful approach to indexing and comparison.

The core challenge is designing a specification that accurately captures the nuanced sorting logic of the original Python implementation, ensuring both digit sum ordering and stable index-based secondary sorting.

I need to modify the Dafny method's contract to explicitly define these sorting requirements, focusing on adding a precise postcondition that guarantees the result meets the intended ordering constraints.

--- RESPONSE ---
THE SCRIPT HAD NOT A PROPER SPEC

```dafny
datatype IndexedNum = IndexedNum(index: int, value: int, digitSum: int)

method order_by_points(nums: seq<int>) returns (result: seq<int>)
    ensures |result| == |nums|
    ensures multiset(result) == multiset(nums)
    ensures forall i, j :: 0 <= i < j < |result| ==> 
        (digit_sum(result[i]) < digit_sum(result[j]) || 
         (digit_sum(result[i]) == digit_sum(result[j]) && 
          original_index_in_result(i, nums, result) < original_index_in_result(j, nums, result)))
{
    if |nums| == 0 {
        return [];
    }
    
    // Create indexed numbers with digit sums
    var indexedNums := seq(|nums|, i requires 0 <= i < |nums| => 
        IndexedNum(i, nums[i], digit_sum(nums[i])));
    
    // Sort the indexed numbers
    var sortedIndexed := sort_indexed_nums(indexedNums);
    
    // Extract just the values
    result := seq(|sortedIndexed|, i requires 0 <= i < |sortedIndexed| => 
        sortedIndexed[i].value);
}

function original_index_in_result(pos: int, original: seq<int>, result: seq<int>): int
    requires 0 <= pos < |result|
    requires |result| == |original|
    requires multiset(result) == multiset(original)
{
    find_original_index(result[pos], original, 0, count_occurrences_before(result[pos], result, pos))
}

function count_occurrences_before(val: int, s: seq<int>, pos: int): int
    requires 0 <= pos <= |s|
{
    if pos == 0 then 0
    else (if s[pos-1] == val then 1 else 0) + count_occurrences_before(val, s, pos-1)
}

function find_original_index(val: int, s: seq<int>, start: int, occurrence: int): int
    requires 0 <= start <= |s|
    requires occurrence >= 0
    decreases |s| - start
{
    if start >= |s| then -1
    else if s[start] == val then
        if occurrence == 0 then start
        else find_original_index(val, s, start + 1, occurrence - 1)
    else find_original_index(val, s, start + 1, occurrence)
}

function digit_sum(n: int): int
{
    if n >= 0 then
        digit_sum_positive(n)
    else
        digit_sum_negative(n)
}

function digit_sum_positive(n: int): int
    requires n >= 0
    decreases n
{
    if n < 10 then n
    else (n % 10) + digit_sum_positive(n / 10)
}

function digit_sum_negative(n: int): int
    requires n < 0
{
    var abs_n := -n;
    var total := digit_sum_positive(abs_n);
    var first_digit := get_first_digit(abs_n);
    total - 2 * first_digit
}

function get_first_digit(n: int): int
    requires n > 0
    decreases n
{
    if n < 10 then n
    else get_first_digit(n / 10)
}

method sort_indexed_nums(nums: seq<IndexedNum>) returns (sorted: seq<IndexedNum>)
    ensures |sorted| == |nums|
    ensures multiset(sorted) == multiset(nums)
    ensures forall i, j :: 0 <= i < j < |sorted| ==> 
        (sorted[i].digitSum < sorted[j].digitSum || 
         (sorted[i].digitSum == sorted[j].digitSum && sorted[i].index < sorted[j].index))
{
    if |nums| <= 1 {
        return nums;
    }
    
    sorted := merge_sort_indexed(nums);
}

method merge_sort_indexed(nums: seq<IndexedNum>) returns (sorted: seq<IndexedNum>)
    ensures |sorted| == |nums|
    ensures multiset(sorted) == multiset(nums)
    ensures forall i, j :: 0 <= i < j < |sorted| ==> 
        (sorted[i].digitSum < sorted[j].digitSum || 
         (sorted[i].digitSum == sorted[j].digitSum && sorted[i].index < sorted[j].index))
    decreases nums
{
    if |nums| <= 1 {
        return nums;
    }
    
    var mid := |nums| / 2;
    var left := nums[..mid];
    var right := nums[mid..];
    
    var sorted_left := merge_sort_indexed(left);
    var sorted_right := merge_sort_indexed(right);
    
    sorted := merge_indexed(sorted_left, sorted_right);
}

method merge_indexed(left: seq<IndexedNum>, right: seq<IndexedNum>) returns (merged: seq<IndexedNum>)
    requires forall i, j :: 0 <= i < j < |left| ==> 
        (left[i].digitSum < left[j].digitSum || 
         (left[i].digitSum == left[j].digitSum && left[i].index < left[j].index))
    requires forall i, j :: 0 <= i < j < |right| ==> 
        (right[i].digitSum < right[j].digitSum || 
         (right[i].digitSum == right[j].digitSum && right[i].index < right[j].index))
    ensures |merged| == |left| + |right|
    ensures multiset(merged) == multiset(left) + multiset(right)
    ensures forall i, j :: 0 <= i < j < |merged| ==> 
        (merged[i].digitSum < merged[j].digitSum || 
         (merged[i].digitSum == merged[j].digitSum && merged[i].index < merged[j].index))
{
    merged := [];
    var i, j := 0, 0;
    
    while i < |left| || j < |right|
        invariant 0 <= i <= |left|
        invariant 0 <= j <= |right|
        invariant |merged| == i + j
        invariant multiset(merged) == multiset(left[..i]) + multiset(right[..j])
        invariant forall k, l :: 0 <= k < l < |merged| ==> 
            (merged[k].digitSum < merged[l].digitSum || 
             (merged[k].digitSum == merged[l].digitSum && merged[k].index < merged[l].index))
    {
        if i >= |left| {
            merged := merged + [right[j]];
            j := j + 1;
        } else if j >= |right| {
            merged := merged + [left[i]];
            i := i + 1;
        } else if should_come_first(left[i], right[j]) {
            merged := merged + [left[i]];
            i := i + 1;
        } else {
            merged := merged + [right[j]];
            j := j + 1;
        }
    }
}

predicate should_come_first(a: IndexedNum, b: IndexedNum)
{
    a.digitSum < b.digitSum || (a.digitSum == b.digitSum && a.index < b.index)
}
```


=============== USER ===============
Please analyze whether the Dafny specifications properly describe the Python function behavior.

**Python Function:**
```python
def order_by_points(nums):
    """
    Write a function which sorts the given list of integers
    in ascending order according to the sum of their digits.
    Note: if there are several items with similar sum of their digits,
    order them based on their index in original list.

    For example:
    >>> order_by_points([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]
    >>> order_by_points([]) == []
    """
    def digit_sum(n):
        # Convert to string to handle digits
        s = str(abs(n))  # Use absolute value to get digits
        total = sum(int(digit) for digit in s)
        
        # For negative numbers, subtract the first digit once more
        # This accounts for the negative sign affecting the first digit
        if n < 0:
            total -= 2 * int(s[0])
        
        return total
    
    # Create list of (original_index, number, digit_sum) tuples
    indexed_nums = [(i, num, digit_sum(num)) for i, num in enumerate(nums)]
    
    # Sort by digit sum first, then by original index for stability
    indexed_nums.sort(key=lambda x: (x[2], x[0]))
    
    # Extract just the numbers from the sorted list
    return [num for _, num, _ in indexed_nums]
```

**Current Dafny Code:**
```dafny
datatype IndexedNum = IndexedNum(index: int, value: int, digitSum: int)

method order_by_points(nums: seq<int>) returns (result: seq<int>)
    ensures |result| == |nums|
    ensures multiset(result) == multiset(nums)
    ensures forall i, j :: 0 <= i < j < |result| ==> 
        (digit_sum(result[i]) < digit_sum(result[j]) || 
         (digit_sum(result[i]) == digit_sum(result[j]) && 
          original_index_in_result(i, nums, result) < original_index_in_result(j, nums, result)))
{
    if |nums| == 0 {
        return [];
    }
    
    // Create indexed numbers with digit sums
    var indexedNums := seq(|nums|, i requires 0 <= i < |nums| => 
        IndexedNum(i, nums[i], digit_sum(nums[i])));
    
    // Sort the indexed numbers
    var sortedIndexed := sort_indexed_nums(indexedNums);
    
    // Extract just the values
    result := seq(|sortedIndexed|, i requires 0 <= i < |sortedIndexed| => 
        sortedIndexed[i].value);
}

function original_index_in_result(pos: int, original: seq<int>, result: seq<int>): int
    requires 0 <= pos < |result|
    requires |result| == |original|
    requires multiset(result) == multiset(original)
{
    find_original_index(result[pos], original, 0, count_occurrences_before(result[pos], result, pos))
}

function count_occurrences_before(val: int, s: seq<int>, pos: int): int
    requires 0 <= pos <= |s|
{
    if pos == 0 then 0
    else (if s[pos-1] == val then 1 else 0) + count_occurrences_before(val, s, pos-1)
}

function find_original_index(val: int, s: seq<int>, start: int, occurrence: int): int
    requires 0 <= start <= |s|
    requires occurrence >= 0
    decreases |s| - start
{
    if start >= |s| then -1
    else if s[start] == val then
        if occurrence == 0 then start
        else find_original_index(val, s, start + 1, occurrence - 1)
    else find_original_index(val, s, start + 1, occurrence)
}

function digit_sum(n: int): int
{
    if n >= 0 then
        digit_sum_positive(n)
    else
        digit_sum_negative(n)
}

function digit_sum_positive(n: int): int
    requires n >= 0
    decreases n
{
    if n < 10 then n
    else (n % 10) + digit_sum_positive(n / 10)
}

function digit_sum_negative(n: int): int
    requires n < 0
{
    var abs_n := -n;
    var total := digit_sum_positive(abs_n);
    var first_digit := get_first_digit(abs_n);
    total - 2 * first_digit
}

function get_first_digit(n: int): int
    requires n > 0
    decreases n
{
    if n < 10 then n
    else get_first_digit(n / 10)
}

method sort_indexed_nums(nums: seq<IndexedNum>) returns (sorted: seq<IndexedNum>)
    ensures |sorted| == |nums|
    ensures multiset(sorted) == multiset(nums)
    ensures forall i, j :: 0 <= i < j < |sorted| ==> 
        (sorted[i].digitSum < sorted[j].digitSum || 
         (sorted[i].digitSum == sorted[j].digitSum && sorted[i].index < sorted[j].index))
{
    if |nums| <= 1 {
        return nums;
    }
    
    sorted := merge_sort_indexed(nums);
}

method merge_sort_indexed(nums: seq<IndexedNum>) returns (sorted: seq<IndexedNum>)
    ensures |sorted| == |nums|
    ensures multiset(sorted) == multiset(nums)
    ensures forall i, j :: 0 <= i < j < |sorted| ==> 
        (sorted[i].digitSum < sorted[j].digitSum || 
         (sorted[i].digitSum == sorted[j].digitSum && sorted[i].index < sorted[j].index))
    decreases nums
{
    if |nums| <= 1 {
        return nums;
    }
    
    var mid := |nums| / 2;
    var left := nums[..mid];
    var right := nums[mid..];
    
    var sorted_left := merge_sort_indexed(left);
    var sorted_right := merge_sort_indexed(right);
    
    sorted := merge_indexed(sorted_left, sorted_right);
}

method merge_indexed(left: seq<IndexedNum>, right: seq<IndexedNum>) returns (merged: seq<IndexedNum>)
    requires forall i, j :: 0 <= i < j < |left| ==> 
        (left[i].digitSum < left[j].digitSum || 
         (left[i].digitSum == left[j].digitSum && left[i].index < left[j].index))
    requires forall i, j :: 0 <= i < j < |right| ==> 
        (right[i].digitSum < right[j].digitSum || 
         (right[i].digitSum == right[j].digitSum && right[i].index < right[j].index))
    ensures |merged| == |left| + |right|
    ensures multiset(merged) == multiset(left) + multiset(right)
    ensures forall i, j :: 0 <= i < j < |merged| ==> 
        (merged[i].digitSum < merged[j].digitSum || 
         (merged[i].digitSum == merged[j].digitSum && merged[i].index < merged[j].index))
{
    merged := [];
    var i, j := 0, 0;
    
    while i < |left| || j < |right|
        invariant 0 <= i <= |left|
        invariant 0 <= j <= |right|
        invariant |merged| == i + j
        invariant multiset(merged) == multiset(left[..i]) + multiset(right[..j])
        invariant forall k, l :: 0 <= k < l < |merged| ==> 
            (merged[k].digitSum < merged[l].digitSum || 
             (merged[k].digitSum == merged[l].digitSum && merged[k].index < merged[l].index))
    {
        if i >= |left| {
            merged := merged + [right[j]];
            j := j + 1;
        } else if j >= |right| {
            merged := merged + [left[i]];
            i := i + 1;
        } else if should_come_first(left[i], right[j]) {
            merged := merged + [left[i]];
            i := i + 1;
        } else {
            merged := merged + [right[j]];
            j := j + 1;
        }
    }
}

predicate should_come_first(a: IndexedNum, b: IndexedNum)
{
    a.digitSum < b.digitSum || (a.digitSum == b.digitSum && a.index < b.index)
}
```

**Analysis Task:**
1. Compare the Python function's behavior with the Dafny specifications
2. Check if the `requires` clauses capture all preconditions
3. Check if the `ensures` clauses capture all postconditions and behavior
4. Verify that the specifications fully describe what the function does

**Response Format:**
Start with exactly one of these phrases:
- "THE SCRIPT HAS PROPER SPECS" (if specifications are adequate)
- "THE SCRIPT HAD NOT A PROPER SPEC" (if specifications need improvement)

Then provide the complete Dafny code. If improving specifications:
- Add missing `requires` clauses for preconditions
- Add missing `ensures` clauses for postconditions
- Ensure specifications capture the function's complete behavior
- Preserve the existing method implementation unchanged



This is attempt 2 to improve the specifications. Please analyze the current version and improve it further if needed. 


=============== ASSISTANT ===============
--- THINKING ---
Let me analyze the Python function and the Dafny specification:

1. Python function behavior:
   - Takes a list of integers
   - Sorts them by the sum of their digits (ascending order)
   - If digit sums are equal, sorts by original index (stable sort)
   - For negative numbers, the digit sum is calculated by taking the sum of digits of the absolute value, then subtracting 2 times the first digit

2. Current Dafny specification:
   - The main method `order_by_points` has:
     - `ensures |result| == |nums|` - correct, preserves length
     - `ensures multiset(result) == multiset(nums)` - correct, preserves elements
     - `ensures forall i, j :: 0 <= i < j < |result| ==> (digit_sum(result[i]) < digit_sum(result[j]) || (digit_sum(result[i]) == digit_sum(result[j]) && original_index_in_result(i, nums, result) < original_index_in_result(j, nums, result)))` - this captures the sorting behavior correctly

Let me check if the `digit_sum` function is correctly implemented:
- For positive numbers: `digit_sum_positive` sums all digits
- For negative numbers: `digit_sum_negative` takes the sum of digits of absolute value, then subtracts 2 times the first digit

This matches the Python implementation.

The `original_index_in_result` function tries to find the original index of an element in the result by looking at its position and counting occurrences before it. This seems correct for handling duplicates.

Looking at the helper functions and methods:
- `sort_indexed_nums` and `merge_sort_indexed` have proper specifications for sorting
- The sorting criteria is correctly captured in `should_come_first`

However, I need to check if there are any missing preconditions or postconditions:


The implementation handles various input scenarios without explicit constraints. Both Python and Dafny versions work seamlessly with different integer lists, including empty lists. The specifications comprehensively cover length preservation, element retention, and sorting logic based on digit sums and original indices. The approach ensures a stable sorting mechanism that accurately reflects the intended sorting behavior.

The method for tracking original indices appears robust, particularly in managing duplicate elements by carefully counting occurrences before a specific position in the result array.

--- RESPONSE ---
THE SCRIPT HAS PROPER SPECS

```dafny
datatype IndexedNum = IndexedNum(index: int, value: int, digitSum: int)

method order_by_points(nums: seq<int>) returns (result: seq<int>)
    ensures |result| == |nums|
    ensures multiset(result) == multiset(nums)
    ensures forall i, j :: 0 <= i < j < |result| ==> 
        (digit_sum(result[i]) < digit_sum(result[j]) || 
         (digit_sum(result[i]) == digit_sum(result[j]) && 
          original_index_in_result(i, nums, result) < original_index_in_result(j, nums, result)))
{
    if |nums| == 0 {
        return [];
    }
    
    // Create indexed numbers with digit sums
    var indexedNums := seq(|nums|, i requires 0 <= i < |nums| => 
        IndexedNum(i, nums[i], digit_sum(nums[i])));
    
    // Sort the indexed numbers
    var sortedIndexed := sort_indexed_nums(indexedNums);
    
    // Extract just the values
    result := seq(|sortedIndexed|, i requires 0 <= i < |sortedIndexed| => 
        sortedIndexed[i].value);
}

function original_index_in_result(pos: int, original: seq<int>, result: seq<int>): int
    requires 0 <= pos < |result|
    requires |result| == |original|
    requires multiset(result) == multiset(original)
{
    find_original_index(result[pos], original, 0, count_occurrences_before(result[pos], result, pos))
}

function count_occurrences_before(val: int, s: seq<int>, pos: int): int
    requires 0 <= pos <= |s|
{
    if pos == 0 then 0
    else (if s[pos-1] == val then 1 else 0) + count_occurrences_before(val, s, pos-1)
}

function find_original_index(val: int, s: seq<int>, start: int, occurrence: int): int
    requires 0 <= start <= |s|
    requires occurrence >= 0
    decreases |s| - start
{
    if start >= |s| then -1
    else if s[start] == val then
        if occurrence == 0 then start
        else find_original_index(val, s, start + 1, occurrence - 1)
    else find_original_index(val, s, start + 1, occurrence)
}

function digit_sum(n: int): int
{
    if n >= 0 then
        digit_sum_positive(n)
    else
        digit_sum_negative(n)
}

function digit_sum_positive(n: int): int
    requires n >= 0
    decreases n
{
    if n < 10 then n
    else (n % 10) + digit_sum_positive(n / 10)
}

function digit_sum_negative(n: int): int
    requires n < 0
{
    var abs_n := -n;
    var total := digit_sum_positive(abs_n);
    var first_digit := get_first_digit(abs_n);
    total - 2 * first_digit
}

function get_first_digit(n: int): int
    requires n > 0
    decreases n
{
    if n < 10 then n
    else get_first_digit(n / 10)
}

method sort_indexed_nums(nums: seq<IndexedNum>) returns (sorted: seq<IndexedNum>)
    ensures |sorted| == |nums|
    ensures multiset(sorted) == multiset(nums)
    ensures forall i, j :: 0 <= i < j < |sorted| ==> 
        (sorted[i].digitSum < sorted[j].digitSum || 
         (sorted[i].digitSum == sorted[j].digitSum && sorted[i].index < sorted[j].index))
{
    if |nums| <= 1 {
        return nums;
    }
    
    sorted := merge_sort_indexed(nums);
}

method merge_sort_indexed(nums: seq<IndexedNum>) returns (sorted: seq<IndexedNum>)
    ensures |sorted| == |nums|
    ensures multiset(sorted) == multiset(nums)
    ensures forall i, j :: 0 <= i < j < |sorted| ==> 
        (sorted[i].digitSum < sorted[j].digitSum || 
         (sorted[i].digitSum == sorted[j].digitSum && sorted[i].index < sorted[j].index))
    decreases nums
{
    if |nums| <= 1 {
        return nums;
    }
    
    var mid := |nums| / 2;
    var left := nums[..mid];
    var right := nums[mid..];
    
    var sorted_left := merge_sort_indexed(left);
    var sorted_right := merge_sort_indexed(right);
    
    sorted := merge_indexed(sorted_left, sorted_right);
}

method merge_indexed(left: seq<IndexedNum>, right: seq<IndexedNum>) returns (merged: seq<IndexedNum>)
    requires forall i, j :: 0 <= i < j < |left| ==> 
        (left[i].digitSum < left[j].digitSum || 
         (left[i].digitSum == left[j].digitSum && left[i].index < left[j].index))
    requires forall i, j :: 0 <= i < j < |right| ==> 
        (right[i].digitSum < right[j].digitSum || 
         (right[i].digitSum == right[j].digitSum && right[i].index < right[j].index))
    ensures |merged| == |left| + |right|
    ensures multiset(merged) == multiset(left) + multiset(right)
    ensures forall i, j :: 0 <= i < j < |merged| ==> 
        (merged[i].digitSum < merged[j].digitSum || 
         (merged[i].digitSum == merged[j].digitSum && merged[i].index < merged[j].index))
{
    merged := [];
    var i, j := 0, 0;
    
    while i < |left| || j < |right|
        invariant 0 <= i <= |left|
        invariant 0 <= j <= |right|
        invariant |merged| == i + j
        invariant multiset(merged) == multiset(left[..i]) + multiset(right[..j])
        invariant forall k, l :: 0 <= k < l < |merged| ==> 
            (merged[k].digitSum < merged[l].digitSum || 
             (merged[k].digitSum == merged[l].digitSum && merged[k].index < merged[l].index))
    {
        if i >= |left| {
            merged := merged + [right[j]];
            j := j + 1;
        } else if j >= |right| {
            merged := merged + [left[i]];
            i := i + 1;
        } else if should_come_first(left[i], right[j]) {
            merged := merged + [left[i]];
            i := i + 1;
        } else {
            merged := merged + [right[j]];
            j := j + 1;
        }
    }
}

predicate should_come_first(a: IndexedNum, b: IndexedNum)
{
    a.digitSum < b.digitSum || (a.digitSum == b.digitSum && a.index < b.index)
}
```

