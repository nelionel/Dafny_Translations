=============== SYSTEM ===============
You are an expert programmer specializing in translating Python code to the Dafny verification language. Your task is to translate the provided Python function into a Dafny method that is both verifiable and compilable. Pay close attention to types, specifications, and providing concrete implementations for all methods.



=============== USER ===============
I will provide you with a Python function and its documentation. Please translate the Python function into a Dafny method.

**Python Function and Documentation:**
```python

def order_by_points(nums):
    """
    Write a function which sorts the given list of integers
    in ascending order according to the sum of their digits.
    Note: if there are several items with similar sum of their digits,
    order them based on their index in original list.

    For example:
    >>> order_by_points([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]
    >>> order_by_points([]) == []
    """

def order_by_points(nums):
    """
    Write a function which sorts the given list of integers
    in ascending order according to the sum of their digits.
    Note: if there are several items with similar sum of their digits,
    order them based on their index in original list.

    For example:
    >>> order_by_points([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]
    >>> order_by_points([]) == []
    """
    def digit_sum(n):
        # Convert to string to handle digits
        s = str(abs(n))  # Use absolute value to get digits
        total = sum(int(digit) for digit in s)
        
        # For negative numbers, subtract the first digit once more
        # This accounts for the negative sign affecting the first digit
        if n < 0:
            total -= 2 * int(s[0])
        
        return total
    
    # Create list of (original_index, number, digit_sum) tuples
    indexed_nums = [(i, num, digit_sum(num)) for i, num in enumerate(nums)]
    
    # Sort by digit sum first, then by original index for stability
    indexed_nums.sort(key=lambda x: (x[2], x[0]))
    
    # Extract just the numbers from the sorted list
    return [num for _, num, _ in indexed_nums]
```

**Your Task:**
1.  **Reasoning (in a <thinking> block):**
    *   Analyze the Python code and its types. How will you map Python types (like lists of floats) to Dafny types (like `seq<real>`)?
    *   Analyze the function's logic. What are the pre-conditions (`requires`) and post-conditions (`ensures`)?
    *   Identify any loops and determine their invariants.
    *   Think about termination conditions for any recursive calls or loops.
2.  **Dafny Implementation (in a ```dafny ... ``` block):**
    *   Write the complete Dafny method, including its signature, `requires` clauses, `ensures` clauses, and the method body.
    *   **The return type of the main method must be a basic Dafny type.** Use `int`, `real`, `bool`, `string`, or a sequence of these types (e.g., `seq<int>`). Do not use custom `datatype`s in the return signature. If the Python code implies an optional return (e.g. returning `None`), you should return a sensible default for the basic type instead (e.g. `false`, `-1`, or an empty sequence `[]`).
    *   The Dafny method name must be exactly the same as the Python function name: `order_by_points`. Do not change the casing.
    *   **All methods must have a concrete implementation (a body).** The `{:axiom}` attribute is forbidden for defining standard functions. However, if the problem's solution relies on an unproven mathematical conjecture (e.g., the Goldbach Conjecture, P vs NP), you may state the conjecture as an `axiom`. If you do so, you **must** include a comment identifying the conjecture (e.g., `// Axiom for the Twin Prime Conjecture`). Do not use axioms to avoid implementing solvable algorithms.
    *   **Provide explicit termination proofs.** For any recursive function, you must include a `decreases` clause. Do **not** use `decreases *`. For functions that operate on a sequence, the termination metric is almost always the length of the sequence (e.g., `decreases my_sequence`). For functions on integers, it is the integer itself (e.g., `decreases n`).
    *   **Do not use Dafny reserved keywords as variable names.** Avoid names like: `abstract, allocated, as, assert, assume, bool, break, by, calc, case, char, class, codatatype, const, constructor, datatype, decreases, else, ensures, exists, export, extends, false, forall, fresh, function, ghost, if, imap, import, in, include, int, invariant, is, iset, iterator, label, lemma, map, match, method, modifies, modify, module, multiset, nameonly, nat, new, newtype, null, object, object?, old, opened, ORDINAL, predicate, print, provides,reads, real, refines, requires, return, returns, reveal, reveals, seq, set, static, string, then, this, trait, true, twostate, type, unchanged, var, while, witness, yield, yields`. For example, instead of `var array`, use `var arr`.



=============== ASSISTANT ===============
--- THINKING ---
Let me analyze this Python function step by step:

1. The function `order_by_points` takes a list of integers and sorts them by the sum of their digits.
2. For negative numbers, it uses a special calculation where the negative sign affects the first digit.
3. If two numbers have the same digit sum, they should be ordered by their original index (stable sort).

Let me break down the `digit_sum` function:
- It takes the absolute value of the number to get the digits
- It sums all the digits
- For negative numbers, it subtracts 2 * the first digit (this effectively makes the first digit negative)

For example:
- For -12: abs(-12) = 12, digits are [1, 2], sum = 1 + 2 = 3, but since it's negative, we subtract 2*1 = 2, so total = 3 - 2 = 1
- For -1: abs(-1) = 1, digits are [1], sum = 1, but since it's negative, we subtract 2*1 = 2, so total = 1 - 2 = -1

Now for the Dafny implementation:

1. I need to implement a helper function to calculate the digit sum
2. I need to sort the array based on digit sum, with original index as tie-breaker
3. The main challenge will be implementing the sorting algorithm

Let me think about the types:
- Input: `seq<int>` (sequence of integers)
- Output: `seq<int>` (sequence of integers)

For the digit sum calculation, I need to:
- Convert the number to its absolute value
- Extract digits (I can do this by repeatedly dividing by 10)
- Sum the digits
- Handle the negative case

For sorting, I can implement a simple sorting algorithm like insertion sort or merge sort. Since Dafny verification can be challenging with complex algorithms, I'll go with a simpler approach.


I'll need a sophisticated sorting strategy that captures both the digit sum and original index. The approach involves creating an internal representation that tracks each number's original position and calculated digit sum. This allows for a precise, stable sorting mechanism that meets the complex requirements of the problem. I'll design an internal data structure that can be used for sorting while maintaining the original sequence information, then extract just the sorted numbers as the final output.

The key challenge is managing the sorting criteria without using built-in tuple comparisons. I'll need to create a custom comparison method that first considers the digit sum, then falls back to the original index when sums are equal. This requires careful implementation of the sorting logic to ensure both the digit sum calculation and stable sorting are correctly handled.

--- RESPONSE ---
<thinking>
Let me analyze this Python function:

1. **Function Logic**: `order_by_points` sorts integers by the sum of their digits, with original index as tie-breaker
2. **Digit Sum Calculation**: For negative numbers, the first digit is treated as negative (subtract 2 * first digit from the total)
3. **Sorting**: Stable sort by digit sum, then by original index
4. **Types**: Input and output are lists of integers â†’ `seq<int>` in Dafny

Key challenges for Dafny:
- Need helper function to calculate digit sum
- Need to implement sorting with custom comparison
- Need to track original indices for tie-breaking
- Need to handle negative numbers correctly in digit sum calculation

For the implementation:
- I'll create a datatype internally to track (index, value, digit_sum)
- Use merge sort or similar for sorting
- Extract just the values for the final result
</thinking>

```dafny
datatype IndexedNum = IndexedNum(index: int, value: int, digitSum: int)

method order_by_points(nums: seq<int>) returns (result: seq<int>)
    ensures |result| == |nums|
    ensures multiset(result) == multiset(nums)
{
    if |nums| == 0 {
        return [];
    }
    
    // Create indexed numbers with digit sums
    var indexedNums := seq(|nums|, i requires 0 <= i < |nums| => 
        IndexedNum(i, nums[i], digit_sum(nums[i])));
    
    // Sort the indexed numbers
    var sortedIndexed := sort_indexed_nums(indexedNums);
    
    // Extract just the values
    result := seq(|sortedIndexed|, i requires 0 <= i < |sortedIndexed| => 
        sortedIndexed[i].value);
}

function digit_sum(n: int): int
{
    if n >= 0 then
        digit_sum_positive(n)
    else
        digit_sum_negative(n)
}

function digit_sum_positive(n: int): int
    requires n >= 0
    decreases n
{
    if n < 10 then n
    else (n % 10) + digit_sum_positive(n / 10)
}

function digit_sum_negative(n: int): int
    requires n < 0
{
    var abs_n := -n;
    var total := digit_sum_positive(abs_n);
    var first_digit := get_first_digit(abs_n);
    total - 2 * first_digit
}

function get_first_digit(n: int): int
    requires n > 0
    decreases n
{
    if n < 10 then n
    else get_first_digit(n / 10)
}

method sort_indexed_nums(nums: seq<IndexedNum>) returns (sorted: seq<IndexedNum>)
    ensures |sorted| == |nums|
    ensures multiset(sorted) == multiset(nums)
    ensures forall i, j :: 0 <= i < j < |sorted| ==> 
        (sorted[i].digitSum < sorted[j].digitSum || 
         (sorted[i].digitSum == sorted[j].digitSum && sorted[i].index < sorted[j].index))
{
    if |nums| <= 1 {
        return nums;
    }
    
    sorted := merge_sort_indexed(nums);
}

method merge_sort_indexed(nums: seq<IndexedNum>) returns (sorted: seq<IndexedNum>)
    ensures |sorted| == |nums|
    ensures multiset(sorted) == multiset(nums)
    ensures forall i, j :: 0 <= i < j < |sorted| ==> 
        (sorted[i].digitSum < sorted[j].digitSum || 
         (sorted[i].digitSum == sorted[j].digitSum && sorted[i].index < sorted[j].index))
    decreases nums
{
    if |nums| <= 1 {
        return nums;
    }
    
    var mid := |nums| / 2;
    var left := nums[..mid];
    var right := nums[mid..];
    
    var sorted_left := merge_sort_indexed(left);
    var sorted_right := merge_sort_indexed(right);
    
    sorted := merge_indexed(sorted_left, sorted_right);
}

method merge_indexed(left: seq<IndexedNum>, right: seq<IndexedNum>) returns (merged: seq<IndexedNum>)
    requires forall i, j :: 0 <= i < j < |left| ==> 
        (left[i].digitSum < left[j].digitSum || 
         (left[i].digitSum == left[j].digitSum && left[i].index < left[j].index))
    requires forall i, j :: 0 <= i < j < |right| ==> 
        (right[i].digitSum < right[j].digitSum || 
         (right[i].digitSum == right[j].digitSum && right[i].index < right[j].index))
    ensures |merged| == |left| + |right|
    ensures multiset(merged) == multiset(left) + multiset(right)
    ensures forall i, j :: 0 <= i < j < |merged| ==> 
        (merged[i].digitSum < merged[j].digitSum || 
         (merged[i].digitSum == merged[j].digitSum && merged[i].index < merged[j].index))
{
    merged := [];
    var i, j := 0, 0;
    
    while i < |left| || j < |right|
        invariant 0 <= i <= |left|
        invariant 0 <= j <= |right|
        invariant |merged| == i + j
        invariant multiset(merged) == multiset(left[..i]) + multiset(right[..j])
        invariant forall k, l :: 0 <= k < l < |merged| ==> 
            (merged[k].digitSum < merged[l].digitSum || 
             (merged[k].digitSum == merged[l].digitSum && merged[k].index < merged[l].index))
    {
        if i >= |left| {
            merged := merged + [right[j]];
            j := j + 1;
        } else if j >= |right| {
            merged := merged + [left[i]];
            i := i + 1;
        } else if should_come_first(left[i], right[j]) {
            merged := merged + [left[i]];
            i := i + 1;
        } else {
            merged := merged + [right[j]];
            j := j + 1;
        }
    }
}

predicate should_come_first(a: IndexedNum, b: IndexedNum)
{
    a.digitSum < b.digitSum || (a.digitSum == b.digitSum && a.index < b.index)
}
```

