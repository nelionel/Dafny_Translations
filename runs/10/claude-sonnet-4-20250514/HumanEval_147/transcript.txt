======SYSTEM PROMPT======
You are a Python coding assistant. Your task is to write a Python script with the full implementation of the function described in the user prompt. The implementation should be inside a markdown code block.

======USER PROMPT======

def get_max_triples(n):
    """
    You are given a positive integer n. You have to create an integer array a of length n.
        For each i (1 ≤ i ≤ n), the value of a[i] = i * i - i + 1.
        Return the number of triples (a[i], a[j], a[k]) of a where i < j < k, 
    and a[i] + a[j] + a[k] is a multiple of 3.

    Example :
        Input: n = 5
        Output: 1
        Explanation: 
        a = [1, 3, 7, 13, 21]
        The only valid triple is (1, 7, 13).
    """


======MODEL OUTPUT======
Looking at this problem, I need to:

1. Create an array where `a[i] = i * i - i + 1` for i from 1 to n
2. Find all triples (a[i], a[j], a[k]) where i < j < k
3. Count how many of these triples have a sum divisible by 3

Let me first analyze the pattern of the formula `i * i - i + 1`:
- For i = 1: 1 - 1 + 1 = 1
- For i = 2: 4 - 2 + 1 = 3  
- For i = 3: 9 - 3 + 1 = 7
- For i = 4: 16 - 4 + 1 = 13
- For i = 5: 25 - 5 + 1 = 21

I notice that `i * i - i + 1 = i(i-1) + 1`. Let me check the pattern modulo 3:
- i ≡ 0 (mod 3): i(i-1) ≡ 0, so a[i] ≡ 1 (mod 3)
- i ≡ 1 (mod 3): i(i-1) ≡ 0, so a[i] ≡ 1 (mod 3)  
- i ≡ 2 (mod 3): i(i-1) ≡ 2×1 ≡ 2, so a[i] ≡ 0 (mod 3)

So the pattern repeats every 3 elements: [1, 1, 0] mod 3.

For a sum of three numbers to be divisible by 3, their sum mod 3 must be 0. The valid combinations are:
- (0, 0, 0) - three numbers ≡ 0 (mod 3)
- (1, 1, 1) - three numbers ≡ 1 (mod 3)
- (0, 1, 2) - one each of 0, 1, 2 (mod 3)

Since we only have numbers that are 0 or 1 (mod 3), only the first two cases apply.

```python
def get_max_triples(n):
    """
    You are given a positive integer n. You have to create an integer array a of length n.
        For each i (1 ≤ i ≤ n), the value of a[i] = i * i - i + 1.
        Return the number of triples (a[i], a[j], a[k]) of a where i < j < k, 
    and a[i] + a[j] + a[k] is a multiple of 3.
    """
    # Create the array
    a = []
    for i in range(1, n + 1):
        a.append(i * i - i + 1)
    
    # Count elements by their remainder when divided by 3
    # Based on the pattern: i*i - i + 1 ≡ 1 (mod 3) when i ≡ 0,1 (mod 3)
    #                                  ≡ 0 (mod 3) when i ≡ 2 (mod 3)
    count_0 = 0  # count of elements ≡ 0 (mod 3)
    count_1 = 0  # count of elements ≡ 1 (mod 3)
    
    for i in range(1, n + 1):
        if i % 3 == 2:  # i ≡ 2 (mod 3) -> a[i] ≡ 0 (mod 3)
            count_0 += 1
        else:  # i ≡ 0,1 (mod 3) -> a[i] ≡ 1 (mod 3)
            count_1 += 1
    
    # Count valid triples
    # Case 1: Three elements ≡ 0 (mod 3) -> C(count_0, 3)
    # Case 2: Three elements ≡ 1 (mod 3) -> C(count_1, 3)
    
    def combination(n, k):
        if k > n or k < 0:
            return 0
        if k == 0 or k == n:
            return 1
        
        # Calculate C(n, k) = n! / (k! * (n-k)!)
        result = 1
        for i in range(min(k, n - k)):
            result = result * (n - i) // (i + 1)
        return result
    
    triples_0 = combination(count_0, 3)
    triples_1 = combination(count_1, 3)
    
    return triples_0 + triples_1
```