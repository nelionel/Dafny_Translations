=============== SYSTEM ===============
You are an expert programmer specializing in translating Python tests to the Dafny verification language. Your task is to translate Python `assert` statements into Dafny test methods and provide a minimal dummy implementation for compilation checking.



=============== USER ===============
I need you to translate Python test assertions into Dafny test methods.

**The Method to Test:**
The Dafny method you need to test is named `Strongest_Extension`.

**Python Test Code:**
```python
def check(candidate):

    # Check some simple cases
    assert candidate('Watashi', ['tEN', 'niNE', 'eIGHt8OKe']) == 'Watashi.eIGHt8OKe'
    assert candidate('Boku123', ['nani', 'NazeDa', 'YEs.WeCaNe', '32145tggg']) == 'Boku123.YEs.WeCaNe'
    assert candidate('__YESIMHERE', ['t', 'eMptY', 'nothing', 'zeR00', 'NuLl__', '123NoooneB321']) == '__YESIMHERE.NuLl__'
    assert candidate('K', ['Ta', 'TAR', 't234An', 'cosSo']) == 'K.TAR'
    assert candidate('__HAHA', ['Tab', '123', '781345', '-_-']) == '__HAHA.123'
    assert candidate('YameRore', ['HhAas', 'okIWILL123', 'WorkOut', 'Fails', '-_-']) == 'YameRore.okIWILL123'
    assert candidate('finNNalLLly', ['Die', 'NowW', 'Wow', 'WoW']) == 'finNNalLLly.WoW'

    # Check some edge cases that are easy to work out by hand.
    assert candidate('_', ['Bb', '91245']) == '_.Bb'
    assert candidate('Sp', ['671235', 'Bb']) == 'Sp.671235'
    

```

**Dafny Solution Code (that these tests should test):**
```dafny
method Strongest_Extension(class_name: string, extensions: seq<string>) returns (result: string)
  requires |extensions| > 0
  ensures |result| > 0
  ensures exists i :: 0 <= i < |extensions| && class_name + "." + extensions[i] == result
{
  var strongest_extension := extensions[0];
  var max_strength := CalculateStrength(extensions[0]);
  
  var i := 1;
  while i < |extensions|
    invariant 0 <= i <= |extensions|
    invariant exists j :: 0 <= j < i && strongest_extension == extensions[j]
    invariant max_strength == CalculateStrength(strongest_extension)
    invariant forall j :: 0 <= j < i ==> CalculateStrength(extensions[j]) <= max_strength
    decreases |extensions| - i
  {
    var current_strength := CalculateStrength(extensions[i]);
    if current_strength > max_strength {
      max_strength := current_strength;
      strongest_extension := extensions[i];
    }
    i := i + 1;
  }
  
  result := class_name + "." + strongest_extension;
}

function CalculateStrength(extension: string): int
{
  CountUppercase(extension) - CountLowercase(extension)
}

function CountUppercase(s: string): int
  decreases |s|
{
  if |s| == 0 then 0
  else (if 'A' <= s[0] <= 'Z' then 1 else 0) + CountUppercase(s[1..])
}

function CountLowercase(s: string): int
  decreases |s|
{
  if |s| == 0 then 0
  else (if 'a' <= s[0] <= 'z' then 1 else 0) + CountLowercase(s[1..])
}
```

**Your Task:**
1. **Analyze the tests and solution:**
   - Note the exact name (`Strongest_Extension`) and signature of the Dafny method from the provided solution code.

2. **Create a minimal dummy implementation** (in a `<dummy>` block):
   - Create a dummy version of the `Strongest_Extension` Dafny method.
   - The dummy should have the same signature as the method in the full Dafny solution and return appropriate default values (0 for int, false for bool, [] for sequences, etc.).
   - This dummy is ONLY for validating that the test code compiles correctly.

3. **Translate the tests** (in a ```dafny ... ``` block):
   - For each `assert` statement in the Python code, create a Dafny test method with `{:test}` attribute.
   - **All generated test methods must have a complete body and be runnable.**
   - Name them `test_0`, `test_1`, etc.
   - Convert scientific notation (e.g., 1e-6) to decimal form (e.g., 0.000001).
   - Each test method should:
     a. Call the `Strongest_Extension` Dafny method and assign the result to a variable.
     b. Use `expect` to check if the result matches the expected value.

**Example:** If Python has `assert add(2, 3) == 5`, the method to test is `add`, and the Dafny solution has `function add(a: int, b: int): int`, then:
<dummy>
function add(a: int, b: int): int
{
    0
}
</dummy>

```dafny
method {:test} test_0()
{
    var result := add(2, 3);
    expect result == 5;
}
```



=============== ASSISTANT ===============
--- THINKING ---
Looking at the Python tests and the Dafny solution, I need to:

1. Understand what `Strongest_Extension` does: it takes a class name and a sequence of extensions, finds the "strongest" extension (based on some calculation), and returns the class name + "." + strongest extension.

2. The signature from the Dafny solution is:
```dafny
method Strongest_Extension(class_name: string, extensions: seq<string>) returns (result: string)
```

3. I need to create a dummy implementation that compiles and then translate the test assertions.

Let me analyze the Python tests:
- `candidate('Watashi', ['tEN', 'niNE', 'eIGHt8OKe']) == 'Watashi.eIGHt8OKe'`
- `candidate('Boku123', ['nani', 'NazeDa', 'YEs.WeCaNe', '32145tggg']) == 'Boku123.YEs.WeCaNe'`
- etc.

Each test calls the method with a class name and a list of extensions, expecting a specific result.

For the dummy implementation, I just need to return an empty string or some default value that will compile.

For the tests, I need to convert each assert into a Dafny test method using the `{:test}` attribute and `expect` statements.

--- RESPONSE ---
<dummy>
method Strongest_Extension(class_name: string, extensions: seq<string>) returns (result: string)
  requires |extensions| > 0
  ensures |result| > 0
  ensures exists i :: 0 <= i < |extensions| && class_name + "." + extensions[i] == result
{
    result := class_name + "." + extensions[0];
}

function CalculateStrength(extension: string): int
{
    0
}

function CountUppercase(s: string): int
{
    0
}

function CountLowercase(s: string): int
{
    0
}
</dummy>

```dafny
method {:test} test_0()
{
    var result := Strongest_Extension("Watashi", ["tEN", "niNE", "eIGHt8OKe"]);
    expect result == "Watashi.eIGHt8OKe";
}

method {:test} test_1()
{
    var result := Strongest_Extension("Boku123", ["nani", "NazeDa", "YEs.WeCaNe", "32145tggg"]);
    expect result == "Boku123.YEs.WeCaNe";
}

method {:test} test_2()
{
    var result := Strongest_Extension("__YESIMHERE", ["t", "eMptY", "nothing", "zeR00", "NuLl__", "123NoooneB321"]);
    expect result == "__YESIMHERE.NuLl__";
}

method {:test} test_3()
{
    var result := Strongest_Extension("K", ["Ta", "TAR", "t234An", "cosSo"]);
    expect result == "K.TAR";
}

method {:test} test_4()
{
    var result := Strongest_Extension("__HAHA", ["Tab", "123", "781345", "-_-"]);
    expect result == "__HAHA.123";
}

method {:test} test_5()
{
    var result := Strongest_Extension("YameRore", ["HhAas", "okIWILL123", "WorkOut", "Fails", "-_-"]);
    expect result == "YameRore.okIWILL123";
}

method {:test} test_6()
{
    var result := Strongest_Extension("finNNalLLly", ["Die", "NowW", "Wow", "WoW"]);
    expect result == "finNNalLLly.WoW";
}

method {:test} test_7()
{
    var result := Strongest_Extension("_", ["Bb", "91245"]);
    expect result == "_.Bb";
}

method {:test} test_8()
{
    var result := Strongest_Extension("Sp", ["671235", "Bb"]);
    expect result == "Sp.671235";
}
```

