=============== SYSTEM ===============
You are an expert programmer specializing in translating Python code to the Dafny verification language. Your task is to translate the provided Python function into a Dafny method that is both verifiable and compilable. Pay close attention to types, specifications, and providing concrete implementations for all methods.



=============== USER ===============
I will provide you with a Python function and its documentation. Please translate the Python function into a Dafny method.

**Python Function and Documentation:**
```python

def int_to_mini_roman(number):
    """
    Given a positive integer, obtain its roman numeral equivalent as a string,
    and return it in lowercase.
    Restrictions: 1 <= num <= 1000

    Examples:
    >>> int_to_mini_roman(19) == 'xix'
    >>> int_to_mini_roman(152) == 'clii'
    >>> int_to_mini_roman(426) == 'cdxxvi'
    """

def int_to_mini_roman(number):
    """
    Given a positive integer, obtain its roman numeral equivalent as a string,
    and return it in lowercase.
    Restrictions: 1 <= num <= 1000

    Examples:
    >>> int_to_mini_roman(19) == 'xix'
    >>> int_to_mini_roman(152) == 'clii'
    >>> int_to_mini_roman(426) == 'cdxxvi'
    """
    # Define the Roman numeral values and their corresponding symbols
    # Listed in descending order to handle subtractive cases properly
    values = [
        1000, 900, 500, 400,
        100, 90, 50, 40,
        10, 9, 5, 4,
        1
    ]
    
    symbols = [
        'M', 'CM', 'D', 'CD',
        'C', 'XC', 'L', 'XL',
        'X', 'IX', 'V', 'IV',
        'I'
    ]
    
    result = ""
    
    # Process each value-symbol pair
    for i in range(len(values)):
        # Add the symbol as many times as the value fits into the number
        count = number // values[i]
        if count > 0:
            result += symbols[i] * count
            number -= values[i] * count
    
    return result.lower()
```

**Your Task:**
1.  **Reasoning (in a <thinking> block):**
    *   Analyze the Python code and its types. How will you map Python types (like lists of floats) to Dafny types (like `seq<real>`)?
    *   Analyze the function's logic. What are the pre-conditions (`requires`) and post-conditions (`ensures`)?
    *   Identify any loops and determine their invariants.
    *   Think about termination conditions for any recursive calls or loops.
2.  **Dafny Implementation (in a ```dafny ... ``` block):**
    *   Write the complete Dafny method, including its signature, `requires` clauses, `ensures` clauses, and the method body.
    *   **The return type of the main method must be a basic Dafny type.** Use `int`, `real`, `bool`, `string`, or a sequence of these types (e.g., `seq<int>`). Do not use custom `datatype`s in the return signature. If the Python code implies an optional return (e.g. returning `None`), you should return a sensible default for the basic type instead (e.g. `false`, `-1`, or an empty sequence `[]`).
    *   The Dafny method name must be exactly the same as the Python function name: `int_to_mini_roman`. Do not change the casing.
    *   **All methods must have a concrete implementation (a body).** The `{:axiom}` attribute is forbidden for defining standard functions. However, if the problem's solution relies on an unproven mathematical conjecture (e.g., the Goldbach Conjecture, P vs NP), you may state the conjecture as an `axiom`. If you do so, you **must** include a comment identifying the conjecture (e.g., `// Axiom for the Twin Prime Conjecture`). Do not use axioms to avoid implementing solvable algorithms.
    *   **Provide explicit termination proofs.** For any recursive function, you must include a `decreases` clause. Do **not** use `decreases *`. For functions that operate on a sequence, the termination metric is almost always the length of the sequence (e.g., `decreases my_sequence`). For functions on integers, it is the integer itself (e.g., `decreases n`).
    *   **Do not use Dafny reserved keywords as variable names.** Avoid names like: `abstract, allocated, as, assert, assume, bool, break, by, calc, case, char, class, codatatype, const, constructor, datatype, decreases, else, ensures, exists, export, extends, false, forall, fresh, function, ghost, if, imap, import, in, include, int, invariant, is, iset, iterator, label, lemma, map, match, method, modifies, modify, module, multiset, nameonly, nat, new, newtype, null, object, object?, old, opened, ORDINAL, predicate, print, provides,reads, real, refines, requires, return, returns, reveal, reveals, seq, set, static, string, then, this, trait, true, twostate, type, unchanged, var, while, witness, yield, yields`. For example, instead of `var array`, use `var arr`.



=============== ASSISTANT ===============
--- THINKING ---
Let me analyze the Python function:

1. The function takes a positive integer between 1 and 1000
2. It converts the integer to a Roman numeral string in lowercase
3. It uses a greedy approach with predefined values and symbols

Let me trace through how it works:
- It has arrays of values and symbols in descending order
- For each value-symbol pair, it finds how many times the value fits into the number
- It adds that many symbols to the result and subtracts the value times count from the number

For Dafny:
- Input: `number: int` with `requires 1 <= number <= 1000`
- Output: `string`
- The postcondition should ensure that the result is the correct lowercase Roman numeral

I need to:
1. Define the values and symbols as sequences
2. Implement the main loop
3. Add proper invariants for the loop
4. Ensure termination

The loop invariant should maintain:
- The result constructed so far plus the remaining number equals the original number (in Roman numeral terms)
- The index is valid
- The remaining number is non-negative

For termination, since we're processing a finite array and the number decreases in each iteration where we add symbols, the loop will terminate.

Let me implement this:

```dafny
method int_to_mini_roman(number: int) returns (result: string)
    requires 1 <= number <= 1000
    ensures |result| > 0
{
    var values := [1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1];
    var symbols := ["M", "CM", "D", "CD", "C", "XC", "L", "XL", "X", "IX", "V", "IV", "I"];
    
    result := "";
    var remaining := number;
    var i := 0;
    
    I'll process each symbol-value pair systematically:
    - Check if the current value can be subtracted from the remaining number
    - If possible, repeatedly add the corresponding symbol
    - Update the remaining number by subtracting the processed value
    - Move to the next symbol-value pair

    The approach ensures we build the Roman numeral representation greedily:
    - Start with the largest possible symbols
    - Progressively break down the number into smaller Roman numeral components
    - Guarantee a complete conversion by the end of the iteration
}
```

--- RESPONSE ---
<thinking>
Let me analyze the Python function:

1. **Types**: The function takes an `int` and returns a `string`. In Dafny, this maps to `int` and `string`.

2. **Logic**: The function converts an integer to Roman numerals using a greedy approach:
   - It has predefined values and symbols in descending order
   - For each value-symbol pair, it determines how many times the value fits into the remaining number
   - It adds that many symbols to the result and subtracts the corresponding value

3. **Preconditions**: The input must be between 1 and 1000 (inclusive)

4. **Postconditions**: The result should be a non-empty lowercase string representing the Roman numeral

5. **Loop invariants**: 
   - The index stays within bounds
   - The remaining number is non-negative
   - The arrays have consistent lengths

6. **Termination**: The loop terminates because we iterate through a finite array, and the number decreases monotonically.

I need to implement a helper method to convert uppercase Roman numerals to lowercase, and handle the main conversion logic.
</thinking>

```dafny
method int_to_mini_roman(number: int) returns (result: string)
    requires 1 <= number <= 1000
    ensures |result| > 0
{
    var values := [1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1];
    var symbols := ["M", "CM", "D", "CD", "C", "XC", "L", "XL", "X", "IX", "V", "IV", "I"];
    
    result := "";
    var remaining := number;
    var i := 0;
    
    while i < |values|
        invariant 0 <= i <= |values|
        invariant remaining >= 0
        invariant |values| == |symbols| == 13
        decreases |values| - i
    {
        var count := remaining / values[i];
        if count > 0 {
            var j := 0;
            while j < count
                invariant 0 <= j <= count
                decreases count - j
            {
                result := result + symbols[i];
                j := j + 1;
            }
            remaining := remaining - values[i] * count;
        }
        i := i + 1;
    }
    
    // Convert to lowercase
    result := to_lowercase(result);
}

method to_lowercase(s: string) returns (result: string)
    ensures |result| == |s|
{
    result := "";
    var i := 0;
    while i < |s|
        invariant 0 <= i <= |s|
        invariant |result| == i
        decreases |s| - i
    {
        var c := s[i];
        if 'A' <= c <= 'Z' {
            var lower_c := (c as int - 'A' as int + 'a' as int) as char;
            result := result + [lower_c];
        } else {
            result := result + [c];
        }
        i := i + 1;
    }
}
```

