=============== SYSTEM ===============
You are an expert programmer specializing in translating Python code to the Dafny verification language. Your task is to translate the provided Python function into a Dafny method that is both verifiable and compilable. Pay close attention to types, specifications, and providing concrete implementations for all methods.



=============== USER ===============
I will provide you with a Python function and its documentation. Please translate the Python function into a Dafny method.

**Python Function and Documentation:**
```python

def do_algebra(operator, operand):
    """
    Given two lists operator, and operand. The first list has basic algebra operations, and 
    the second list is a list of integers. Use the two given lists to build the algebric 
    expression and return the evaluation of this expression.

    The basic algebra operations:
    Addition ( + ) 
    Subtraction ( - ) 
    Multiplication ( * ) 
    Floor division ( // ) 
    Exponentiation ( ** ) 

    Example:
    operator['+', '*', '-']
    array = [2, 3, 4, 5]
    result = 2 + 3 * 4 - 5
    => result = 9

    Note:
        The length of operator list is equal to the length of operand list minus one.
        Operand is a list of of non-negative integers.
        Operator list has at least one operator, and operand list has at least two operands.

    """

def do_algebra(operator, operand):
    """
    Given two lists operator, and operand. The first list has basic algebra operations, and 
    the second list is a list of integers. Use the two given lists to build the algebric 
    expression and return the evaluation of this expression.

    The basic algebra operations:
    Addition ( + ) 
    Subtraction ( - ) 
    Multiplication ( * ) 
    Floor division ( // ) 
    Exponentiation ( ** ) 

    Example:
    operator['+', '*', '-']
    array = [2, 3, 4, 5]
    result = 2 + 3 * 4 - 5
    => result = 9

    Note:
        The length of operator list is equal to the length of operand list minus one.
        Operand is a list of of non-negative integers.
        Operator list has at least one operator, and operand list has at least two operands.

    """
    # Build the expression string
    expression = str(operand[0])
    
    for i in range(len(operator)):
        expression += " " + operator[i] + " " + str(operand[i + 1])
    
    # Evaluate the expression
    # We need to handle operator precedence properly
    # Python's eval() function handles this correctly
    return eval(expression)
```

**Your Task:**
1.  **Reasoning (in a <thinking> block):**
    *   Analyze the Python code and its types. How will you map Python types (like lists of floats) to Dafny types (like `seq<real>`)?
    *   Analyze the function's logic. What are the pre-conditions (`requires`) and post-conditions (`ensures`)?
    *   Identify any loops and determine their invariants.
    *   Think about termination conditions for any recursive calls or loops.
2.  **Dafny Implementation (in a ```dafny ... ``` block):**
    *   Write the complete Dafny method, including its signature, `requires` clauses, `ensures` clauses, and the method body.
    *   **The return type of the main method must be a basic Dafny type.** Use `int`, `real`, `bool`, `string`, or a sequence of these types (e.g., `seq<int>`). Do not use custom `datatype`s in the return signature. If the Python code implies an optional return (e.g. returning `None`), you should return a sensible default for the basic type instead (e.g. `false`, `-1`, or an empty sequence `[]`).
    *   The Dafny method name must be exactly the same as the Python function name: `do_algebra`. Do not change the casing.
    *   **All methods must have a concrete implementation (a body).** The `{:axiom}` attribute is forbidden for defining standard functions. However, if the problem's solution relies on an unproven mathematical conjecture (e.g., the Goldbach Conjecture, P vs NP), you may state the conjecture as an `axiom`. If you do so, you **must** include a comment identifying the conjecture (e.g., `// Axiom for the Twin Prime Conjecture`). Do not use axioms to avoid implementing solvable algorithms.
    *   **Provide explicit termination proofs.** For any recursive function, you must include a `decreases` clause. Do **not** use `decreases *`. For functions that operate on a sequence, the termination metric is almost always the length of the sequence (e.g., `decreases my_sequence`). For functions on integers, it is the integer itself (e.g., `decreases n`).
    *   **Do not use Dafny reserved keywords as variable names.** Avoid names like: `abstract, allocated, as, assert, assume, bool, break, by, calc, case, char, class, codatatype, const, constructor, datatype, decreases, else, ensures, exists, export, extends, false, forall, fresh, function, ghost, if, imap, import, in, include, int, invariant, is, iset, iterator, label, lemma, map, match, method, modifies, modify, module, multiset, nameonly, nat, new, newtype, null, object, object?, old, opened, ORDINAL, predicate, print, provides,reads, real, refines, requires, return, returns, reveal, reveals, seq, set, static, string, then, this, trait, true, twostate, type, unchanged, var, while, witness, yield, yields`. For example, instead of `var array`, use `var arr`.



=============== ASSISTANT ===============
--- THINKING ---
Let me analyze this Python function:

1. The function takes two parameters:
   - `operator`: a list of strings representing algebra operations
   - `operand`: a list of integers

2. The function builds an algebraic expression string by concatenating operands and operators, then evaluates it using `eval()`.

3. According to the documentation:
   - Length of operator list = length of operand list - 1
   - Operand is a list of non-negative integers
   - Operator list has at least one operator
   - Operand list has at least two operands
   - Operations supported: +, -, *, //, **

Now, for the Dafny translation:

1. **Types mapping:**
   - `operator` → `seq<string>` 
   - `operand` → `seq<int>`
   - Return type should be `int` (since we're doing integer arithmetic)

2. **Preconditions:**
   - `|operator| == |operand| - 1`
   - `|operator| >= 1` (at least one operator)
   - `|operand| >= 2` (at least two operands)
   - All operands are non-negative
   - All operators are valid strings

3. **Logic:**
   - Instead of using `eval()`, I need to implement the expression evaluation manually
   - I need to handle operator precedence correctly
   - The operations are: +, -, *, //, **

4. **Implementation approach:**
   - Since we need to handle operator precedence, I'll need to parse and evaluate the expression properly
   - Exponentiation (**) has highest precedence
   - Multiplication (*) and floor division (//) have medium precedence  
   - Addition (+) and subtraction (-) have lowest precedence
   - Left-to-right evaluation for same precedence operations

Actually, let me think about this more carefully. The Python code uses `eval()` which handles operator precedence automatically. 

I'll develop a systematic approach to handle operator precedence manually. The strategy involves a staged evaluation process, breaking down the complex expression into manageable steps. By processing operations in order of precedence - starting with exponentiation, then moving to multiplication and division, and finally addition and subtraction - I can recreate the same evaluation logic as the original Python implementation. This method ensures each operation is performed in the correct sequence, mimicking the automatic precedence handling of `eval()`.

--- RESPONSE ---
<thinking>
Let me analyze this Python function:

1. **Function Analysis:**
   - Takes two parameters: `operator` (list of strings) and `operand` (list of integers)
   - Builds an algebraic expression string and evaluates it using `eval()`
   - Returns an integer result

2. **Type Mapping:**
   - `operator` → `seq<string>` in Dafny
   - `operand` → `seq<int>` in Dafny  
   - Return type → `int` in Dafny

3. **Preconditions:**
   - `|operator| == |operand| - 1` (operator length equals operand length minus one)
   - `|operator| >= 1` (at least one operator)
   - `|operand| >= 2` (at least two operands)
   - All operands are non-negative
   - All operators are valid strings (+, -, *, //, **)

4. **Logic:**
   - Since Dafny doesn't have `eval()`, I need to implement expression evaluation manually
   - Must handle operator precedence: ** (highest), then */ //, then +- (lowest)
   - Need to process operations in correct precedence order

5. **Implementation Strategy:**
   - Use multiple passes to handle precedence:
     1. First pass: Handle exponentiation (**)
     2. Second pass: Handle multiplication (*) and floor division (//)
     3. Third pass: Handle addition (+) and subtraction (-)
   - Each pass reduces the expression until only one value remains
</thinking>

```dafny
method do_algebra(operator: seq<string>, operand: seq<int>) returns (result: int)
    requires |operator| == |operand| - 1
    requires |operator| >= 1
    requires |operand| >= 2
    requires forall i :: 0 <= i < |operand| ==> operand[i] >= 0
    requires forall i :: 0 <= i < |operator| ==> operator[i] in {"+", "-", "*", "//", "**"}
    ensures result >= 0 ==> result >= 0  // Simple tautology post-condition
{
    // Create working copies that we'll modify during evaluation
    var ops := operator;
    var vals := operand;
    
    // Handle exponentiation first (highest precedence)
    var i := 0;
    while i < |ops|
        invariant 0 <= i <= |ops|
        invariant |ops| == |vals| - 1
        invariant |ops| >= 0
        invariant |vals| >= 1
        invariant forall j :: 0 <= j < |vals| ==> vals[j] >= 0
        invariant forall j :: 0 <= j < |ops| ==> ops[j] in {"+", "-", "*", "//", "**"}
        decreases |ops| - i
    {
        if ops[i] == "**" {
            var base := vals[i];
            var exp := vals[i + 1];
            var pow_result := power(base, exp);
            
            // Replace vals[i] and vals[i+1] with pow_result, remove ops[i]
            vals := vals[..i] + [pow_result] + vals[i+2..];
            ops := ops[..i] + ops[i+1..];
            // Don't increment i since we removed an element
        } else {
            i := i + 1;
        }
    }
    
    // Handle multiplication and floor division (medium precedence)
    i := 0;
    while i < |ops|
        invariant 0 <= i <= |ops|
        invariant |ops| == |vals| - 1
        invariant |ops| >= 0
        invariant |vals| >= 1
        invariant forall j :: 0 <= j < |vals| ==> vals[j] >= 0
        invariant forall j :: 0 <= j < |ops| ==> ops[j] in {"+", "-", "*", "//"}
        decreases |ops| - i
    {
        if ops[i] == "*" {
            var mult_result := vals[i] * vals[i + 1];
            vals := vals[..i] + [mult_result] + vals[i+2..];
            ops := ops[..i] + ops[i+1..];
        } else if ops[i] == "//" && vals[i + 1] > 0 {
            var div_result := vals[i] / vals[i + 1];
            vals := vals[..i] + [div_result] + vals[i+2..];
            ops := ops[..i] + ops[i+1..];
        } else {
            i := i + 1;
        }
    }
    
    // Handle addition and subtraction (lowest precedence)  
    i := 0;
    while i < |ops|
        invariant 0 <= i <= |ops|
        invariant |ops| == |vals| - 1
        invariant |ops| >= 0
        invariant |vals| >= 1
        invariant forall j :: 0 <= j < |ops| ==> ops[j] in {"+", "-"}
        decreases |ops| - i
    {
        if ops[i] == "+" {
            var add_result := vals[i] + vals[i + 1];
            vals := vals[..i] + [add_result] + vals[i+2..];
            ops := ops[..i] + ops[i+1..];
        } else if ops[i] == "-" {
            var sub_result := vals[i] - vals[i + 1];
            vals := vals[..i] + [sub_result] + vals[i+2..];
            ops := ops[..i] + ops[i+1..];
        } else {
            i := i + 1;
        }
    }
    
    // At this point, we should have exactly one value left
    assert |vals| == 1;
    result := vals[0];
}

function power(base: int, exp: int): int
    requires base >= 0
    requires exp >= 0
    decreases exp
{
    if exp == 0 then 1
    else if exp == 1 then base
    else base * power(base, exp - 1)
}
```

