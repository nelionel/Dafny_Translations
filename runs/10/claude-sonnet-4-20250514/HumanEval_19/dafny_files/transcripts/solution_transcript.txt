=============== SYSTEM ===============
You are an expert programmer specializing in translating Python code to the Dafny verification language. Your task is to translate the provided Python function into a Dafny method that is both verifiable and compilable. Pay close attention to types, specifications, and providing concrete implementations for all methods.



=============== USER ===============
I will provide you with a Python function and its documentation. Please translate the Python function into a Dafny method.

**Python Function and Documentation:**
```python
from typing import List


def sort_numbers(numbers: str) -> str:
    """ Input is a space-delimited string of numberals from 'zero' to 'nine'.
    Valid choices are 'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight' and 'nine'.
    Return the string with numbers sorted from smallest to largest
    >>> sort_numbers('three one five')
    'one three five'
    """

from typing import List


def sort_numbers(numbers: str) -> str:
    """ Input is a space-delimited string of numberals from 'zero' to 'nine'.
    Valid choices are 'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight' and 'nine'.
    Return the string with numbers sorted from smallest to largest
    >>> sort_numbers('three one five')
    'one three five'
    """
    # Handle empty string
    if not numbers.strip():
        return ""
    
    # Mapping of number words to their numeric values
    word_to_num = {
        'zero': 0, 'one': 1, 'two': 2, 'three': 3, 'four': 4,
        'five': 5, 'six': 6, 'seven': 7, 'eight': 8, 'nine': 9
    }
    
    # Split the input string into individual number words
    number_words = numbers.split()
    
    # Sort the words based on their numeric values
    sorted_words = sorted(number_words, key=lambda word: word_to_num[word])
    
    # Join the sorted words back into a space-delimited string
    return ' '.join(sorted_words)
```

**Your Task:**
1.  **Reasoning (in a <thinking> block):**
    *   Analyze the Python code and its types. How will you map Python types (like lists of floats) to Dafny types (like `seq<real>`)?
    *   Analyze the function's logic. What are the pre-conditions (`requires`) and post-conditions (`ensures`)?
    *   Identify any loops and determine their invariants.
    *   Think about termination conditions for any recursive calls or loops.
2.  **Dafny Implementation (in a ```dafny ... ``` block):**
    *   Write the complete Dafny method, including its signature, `requires` clauses, `ensures` clauses, and the method body.
    *   **The return type of the main method must be a basic Dafny type.** Use `int`, `real`, `bool`, `string`, or a sequence of these types (e.g., `seq<int>`). Do not use custom `datatype`s in the return signature. If the Python code implies an optional return (e.g. returning `None`), you should return a sensible default for the basic type instead (e.g. `false`, `-1`, or an empty sequence `[]`).
    *   The Dafny method name must be exactly the same as the Python function name: `sort_numbers`. Do not change the casing.
    *   **All methods must have a concrete implementation (a body).** The `{:axiom}` attribute is forbidden for defining standard functions. However, if the problem's solution relies on an unproven mathematical conjecture (e.g., the Goldbach Conjecture, P vs NP), you may state the conjecture as an `axiom`. If you do so, you **must** include a comment identifying the conjecture (e.g., `// Axiom for the Twin Prime Conjecture`). Do not use axioms to avoid implementing solvable algorithms.
    *   **Provide explicit termination proofs.** For any recursive function, you must include a `decreases` clause. Do **not** use `decreases *`. For functions that operate on a sequence, the termination metric is almost always the length of the sequence (e.g., `decreases my_sequence`). For functions on integers, it is the integer itself (e.g., `decreases n`).
    *   **Do not use Dafny reserved keywords as variable names.** Avoid names like: `abstract, allocated, as, assert, assume, bool, break, by, calc, case, char, class, codatatype, const, constructor, datatype, decreases, else, ensures, exists, export, extends, false, forall, fresh, function, ghost, if, imap, import, in, include, int, invariant, is, iset, iterator, label, lemma, map, match, method, modifies, modify, module, multiset, nameonly, nat, new, newtype, null, object, object?, old, opened, ORDINAL, predicate, print, provides,reads, real, refines, requires, return, returns, reveal, reveals, seq, set, static, string, then, this, trait, true, twostate, type, unchanged, var, while, witness, yield, yields`. For example, instead of `var array`, use `var arr`.



=============== ASSISTANT ===============
--- THINKING ---
Let me analyze the Python function first:

1. The function takes a string as input representing space-delimited number words
2. It returns a string with the number words sorted from smallest to largest
3. The valid number words are 'zero' through 'nine'
4. If the input is empty/whitespace, it returns an empty string

The logic:
1. Check if the input string is empty (after stripping whitespace)
2. Create a mapping from word to numeric value
3. Split the string into words
4. Sort words based on their numeric values
5. Join back into a space-delimited string

For Dafny translation:
- Input: `string` 
- Output: `string`
- Need to handle string splitting and joining
- Need to implement sorting based on numeric values of words
- Need helper functions for word-to-number mapping

Pre-conditions:
- The input should only contain valid number words separated by spaces
- But the Python code doesn't validate this, so I should handle it gracefully

Post-conditions:
- The output should contain the same words as input but sorted by numeric value
- If input is empty/whitespace, output should be empty

I'll need helper functions:
1. A function to map word to number
2. A function to split string by spaces
3. A function to join strings with spaces
4. A sorting function

Let me think about the implementation:

```dafny
method sort_numbers(numbers: string) returns (result: string)
{
    // Handle empty string
    if |numbers| == 0 {
        return "";
    }
    
    // Split into words
    var words := split_by_space(numbers);
    
    // Sort words by their numeric values
    var sorted_words := sort_words_by_value(words);
    
    // Join back
    result := join_with_space(sorted_words);
}
```

I need to implement all these helper functions. 

I'll break down the helper functions systematically. Each requires careful implementation in Dafny:

1. `split_by_space` needs to handle string parsing
2. `word_to_number` requires a precise mapping of words to integers
3. `sort_words_by_value` demands a custom comparison method
4. `join_with_space` will reconstruct the sorted string

The implementation will involve creating precise methods for each step, ensuring type safety and correct logic in Dafny's verification-friendly environment.

--- RESPONSE ---
<thinking>
Let me analyze the Python function:

1. **Input/Output**: Takes a string of space-delimited number words, returns a string with those words sorted by numeric value
2. **Logic**: 
   - Handle empty input
   - Map number words to numeric values
   - Split input by spaces
   - Sort words based on numeric values
   - Join back with spaces

For Dafny translation:
- Input: `string`
- Output: `string` 
- Need helper functions for: word-to-number mapping, string splitting, sorting, string joining
- Pre-condition: Input should contain valid number words (though Python doesn't validate this)
- Post-condition: Output contains same words sorted by numeric value

The main challenge is implementing string manipulation and sorting in Dafny. I'll need several helper functions and will need to be careful about termination proofs for any loops.
</thinking>

```dafny
method sort_numbers(numbers: string) returns (result: string)
    ensures |numbers| == 0 ==> result == ""
{
    if |numbers| == 0 {
        return "";
    }
    
    // Split the string into words
    var words := split_string(numbers, ' ');
    
    // Remove empty strings from split result
    var filtered_words := filter_empty_strings(words);
    
    if |filtered_words| == 0 {
        return "";
    }
    
    // Sort the words by their numeric values
    var sorted_words := sort_word_sequence(filtered_words);
    
    // Join the sorted words back with spaces
    result := join_strings(sorted_words, " ");
}

function word_to_number(word: string): int
{
    if word == "zero" then 0
    else if word == "one" then 1
    else if word == "two" then 2
    else if word == "three" then 3
    else if word == "four" then 4
    else if word == "five" then 5
    else if word == "six" then 6
    else if word == "seven" then 7
    else if word == "eight" then 8
    else if word == "nine" then 9
    else -1  // Invalid word, assign lowest priority
}

method split_string(s: string, delimiter: char) returns (parts: seq<string>)
    ensures forall i :: 0 <= i < |parts| ==> delimiter !in parts[i]
    decreases |s|
{
    if |s| == 0 {
        return [];
    }
    
    var result: seq<string> := [];
    var current := "";
    var i := 0;
    
    while i < |s|
        invariant 0 <= i <= |s|
        invariant delimiter !in current
        invariant forall j :: 0 <= j < |result| ==> delimiter !in result[j]
        decreases |s| - i
    {
        if s[i] == delimiter {
            result := result + [current];
            current := "";
        } else {
            current := current + [s[i]];
        }
        i := i + 1;
    }
    
    result := result + [current];
    return result;
}

method filter_empty_strings(strings: seq<string>) returns (filtered: seq<string>)
    ensures forall i :: 0 <= i < |filtered| ==> |filtered[i]| > 0
    decreases |strings|
{
    if |strings| == 0 {
        return [];
    }
    
    var result: seq<string> := [];
    var i := 0;
    
    while i < |strings|
        invariant 0 <= i <= |strings|
        invariant forall j :: 0 <= j < |result| ==> |result[j]| > 0
        decreases |strings| - i
    {
        if |strings[i]| > 0 {
            result := result + [strings[i]];
        }
        i := i + 1;
    }
    
    return result;
}

method sort_word_sequence(words: seq<string>) returns (sorted_words: seq<string>)
    ensures |sorted_words| == |words|
    ensures multiset(sorted_words) == multiset(words)
    ensures forall i, j :: 0 <= i < j < |sorted_words| ==> 
        word_to_number(sorted_words[i]) <= word_to_number(sorted_words[j])
    decreases |words|
{
    if |words| <= 1 {
        return words;
    }
    
    // Simple insertion sort
    var result := [words[0]];
    var i := 1;
    
    while i < |words|
        invariant 1 <= i <= |words|
        invariant |result| == i
        invariant multiset(result) == multiset(words[0..i])
        invariant forall x, y :: 0 <= x < y < |result| ==> 
            word_to_number(result[x]) <= word_to_number(result[y])
        decreases |words| - i
    {
        var current_word := words[i];
        var current_value := word_to_number(current_word);
        
        // Find insertion position
        var pos := 0;
        while pos < |result| && word_to_number(result[pos]) <= current_value
            invariant 0 <= pos <= |result|
            decreases |result| - pos
        {
            pos := pos + 1;
        }
        
        // Insert at position pos
        result := result[0..pos] + [current_word] + result[pos..];
        i := i + 1;
    }
    
    return result;
}

method join_strings(strings: seq<string>, separator: string) returns (joined: string)
    decreases |strings|
{
    if |strings| == 0 {
        return "";
    }
    
    if |strings| == 1 {
        return strings[0];
    }
    
    var result := strings[0];
    var i := 1;
    
    while i < |strings|
        invariant 1 <= i <= |strings|
        decreases |strings| - i
    {
        result := result + separator + strings[i];
        i := i + 1;
    }
    
    return result;
}
```

