=============== SYSTEM ===============
You are an expert programmer specializing in translating Python tests to the Dafny verification language. Your task is to translate Python `assert` statements into Dafny test methods and provide a minimal dummy implementation for compilation checking.



=============== USER ===============
I need you to translate Python test assertions into Dafny test methods.

**The Method to Test:**
The Dafny method you need to test is named `sort_numbers`.

**Python Test Code:**
```python


METADATA = {
    'author': 'jt',
    'dataset': 'test'
}


def check(candidate):
    assert candidate('') == ''
    assert candidate('three') == 'three'
    assert candidate('three five nine') == 'three five nine'
    assert candidate('five zero four seven nine eight') == 'zero four five seven eight nine'
    assert candidate('six five four three two one zero') == 'zero one two three four five six'

```

**Dafny Solution Code (that these tests should test):**
```dafny
method sort_numbers(numbers: string) returns (result: string)
    ensures |numbers| == 0 ==> result == ""
{
    if |numbers| == 0 {
        return "";
    }
    
    // Split the string into words
    var words := split_string(numbers, ' ');
    
    // Remove empty strings from split result
    var filtered_words := filter_empty_strings(words);
    
    if |filtered_words| == 0 {
        return "";
    }
    
    // Sort the words by their numeric values
    var sorted_words := sort_word_sequence(filtered_words);
    
    // Join the sorted words back with spaces
    result := join_strings(sorted_words, " ");
}

function word_to_number(word: string): int
{
    if word == "zero" then 0
    else if word == "one" then 1
    else if word == "two" then 2
    else if word == "three" then 3
    else if word == "four" then 4
    else if word == "five" then 5
    else if word == "six" then 6
    else if word == "seven" then 7
    else if word == "eight" then 8
    else if word == "nine" then 9
    else -1  // Invalid word, assign lowest priority
}

method split_string(s: string, delimiter: char) returns (parts: seq<string>)
    ensures forall i :: 0 <= i < |parts| ==> delimiter !in parts[i]
    decreases |s|
{
    if |s| == 0 {
        return [];
    }
    
    var result: seq<string> := [];
    var current := "";
    var i := 0;
    
    while i < |s|
        invariant 0 <= i <= |s|
        invariant delimiter !in current
        invariant forall j :: 0 <= j < |result| ==> delimiter !in result[j]
        decreases |s| - i
    {
        if s[i] == delimiter {
            result := result + [current];
            current := "";
        } else {
            current := current + [s[i]];
        }
        i := i + 1;
    }
    
    result := result + [current];
    return result;
}

method filter_empty_strings(strings: seq<string>) returns (filtered: seq<string>)
    ensures forall i :: 0 <= i < |filtered| ==> |filtered[i]| > 0
    decreases |strings|
{
    if |strings| == 0 {
        return [];
    }
    
    var result: seq<string> := [];
    var i := 0;
    
    while i < |strings|
        invariant 0 <= i <= |strings|
        invariant forall j :: 0 <= j < |result| ==> |result[j]| > 0
        decreases |strings| - i
    {
        if |strings[i]| > 0 {
            result := result + [strings[i]];
        }
        i := i + 1;
    }
    
    return result;
}

method sort_word_sequence(words: seq<string>) returns (sorted_words: seq<string>)
    ensures |sorted_words| == |words|
    ensures multiset(sorted_words) == multiset(words)
    ensures forall i, j :: 0 <= i < j < |sorted_words| ==> 
        word_to_number(sorted_words[i]) <= word_to_number(sorted_words[j])
    decreases |words|
{
    if |words| <= 1 {
        return words;
    }
    
    // Simple insertion sort
    var result := [words[0]];
    var i := 1;
    
    while i < |words|
        invariant 1 <= i <= |words|
        invariant |result| == i
        invariant multiset(result) == multiset(words[0..i])
        invariant forall x, y :: 0 <= x < y < |result| ==> 
            word_to_number(result[x]) <= word_to_number(result[y])
        decreases |words| - i
    {
        var current_word := words[i];
        var current_value := word_to_number(current_word);
        
        // Find insertion position
        var pos := 0;
        while pos < |result| && word_to_number(result[pos]) <= current_value
            invariant 0 <= pos <= |result|
            decreases |result| - pos
        {
            pos := pos + 1;
        }
        
        // Insert at position pos
        result := result[0..pos] + [current_word] + result[pos..];
        i := i + 1;
    }
    
    return result;
}

method join_strings(strings: seq<string>, separator: string) returns (joined: string)
    decreases |strings|
{
    if |strings| == 0 {
        return "";
    }
    
    if |strings| == 1 {
        return strings[0];
    }
    
    var result := strings[0];
    var i := 1;
    
    while i < |strings|
        invariant 1 <= i <= |strings|
        decreases |strings| - i
    {
        result := result + separator + strings[i];
        i := i + 1;
    }
    
    return result;
}
```

**Your Task:**
1. **Analyze the tests and solution:**
   - Note the exact name (`sort_numbers`) and signature of the Dafny method from the provided solution code.

2. **Create a minimal dummy implementation** (in a `<dummy>` block):
   - Create a dummy version of the `sort_numbers` Dafny method.
   - The dummy should have the same signature as the method in the full Dafny solution and return appropriate default values (0 for int, false for bool, [] for sequences, etc.).
   - This dummy is ONLY for validating that the test code compiles correctly.

3. **Translate the tests** (in a ```dafny ... ``` block):
   - For each `assert` statement in the Python code, create a Dafny test method with `{:test}` attribute.
   - **All generated test methods must have a complete body and be runnable.**
   - Name them `test_0`, `test_1`, etc.
   - Convert scientific notation (e.g., 1e-6) to decimal form (e.g., 0.000001).
   - Each test method should:
     a. Call the `sort_numbers` Dafny method and assign the result to a variable.
     b. Use `expect` to check if the result matches the expected value.

**Example:** If Python has `assert add(2, 3) == 5`, the method to test is `add`, and the Dafny solution has `function add(a: int, b: int): int`, then:
<dummy>
function add(a: int, b: int): int
{
    0
}
</dummy>

```dafny
method {:test} test_0()
{
    var result := add(2, 3);
    expect result == 5;
}
```



=============== ASSISTANT ===============
--- THINKING ---
Let me analyze the Python test code and the Dafny solution.

The Python test code has the following assertions:
1. `assert candidate('') == ''` - empty string should return empty string
2. `assert candidate('three') == 'three'` - single word should return the same word
3. `assert candidate('three five nine') == 'three five nine'` - already sorted, should remain the same
4. `assert candidate('five zero four seven nine eight') == 'zero four five seven eight nine'` - unsorted sequence should be sorted by numeric value
5. `assert candidate('six five four three two one zero') == 'zero one two three four five six'` - reverse order should be sorted correctly

The Dafny method to test is `sort_numbers` which takes a `string` parameter and returns a `string`.

From the solution code, I can see the signature:
```dafny
method sort_numbers(numbers: string) returns (result: string)
```

So I need to create a dummy implementation with the same signature that returns a default string value, and then create test methods that call this method and use `expect` to verify the results.

Let me create the dummy implementation first:

```dafny
method sort_numbers(numbers: string) returns (result: string)
{
    result := "";
}
```

Now for the tests:

1. `test_0`: `sort_numbers('')` should return `''`
2. `test_1`: `sort_numbers('three')` should return `'three'`
3. `test_2`: `sort_numbers('three five nine')` should return `'three five nine'`
4. `test_3`: `sort_numbers('five zero four seven nine eight')` should return `'zero four five seven eight nine'`
5. `test_4`: `sort_numbers('six five four three two one zero')` should return `'zero one two three four five six'`

--- RESPONSE ---
Looking at the Python test code and the Dafny solution, I can see that the method to test is `sort_numbers` which takes a string parameter and returns a string result.

<dummy>
method sort_numbers(numbers: string) returns (result: string)
{
    result := "";
}
</dummy>

```dafny
method {:test} test_0()
{
    var result := sort_numbers("");
    expect result == "";
}

method {:test} test_1()
{
    var result := sort_numbers("three");
    expect result == "three";
}

method {:test} test_2()
{
    var result := sort_numbers("three five nine");
    expect result == "three five nine";
}

method {:test} test_3()
{
    var result := sort_numbers("five zero four seven nine eight");
    expect result == "zero four five seven eight nine";
}

method {:test} test_4()
{
    var result := sort_numbers("six five four three two one zero");
    expect result == "zero one two three four five six";
}
```

