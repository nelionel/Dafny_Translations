=============== SYSTEM ===============
You are an expert programmer specializing in translating Python code to the Dafny verification language. Your task is to translate the provided Python function into a Dafny method that is both verifiable and compilable. Pay close attention to types, specifications, and providing concrete implementations for all methods.



=============== USER ===============
I will provide you with a Python function and its documentation. Please translate the Python function into a Dafny method.

**Python Function and Documentation:**
```python
from typing import List


def rescale_to_unit(numbers: List[float]) -> List[float]:
    """ Given list of numbers (of at least two elements), apply a linear transform to that list,
    such that the smallest number will become 0 and the largest will become 1
    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])
    [0.0, 0.25, 0.5, 0.75, 1.0]
    """

from typing import List


def rescale_to_unit(numbers: List[float]) -> List[float]:
    """ Given list of numbers (of at least two elements), apply a linear transform to that list,
    such that the smallest number will become 0 and the largest will become 1
    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])
    [0.0, 0.25, 0.5, 0.75, 1.0]
    """
    min_val = min(numbers)
    max_val = max(numbers)
    
    # Handle edge case where all numbers are the same
    if min_val == max_val:
        return [0.0] * len(numbers)
    
    range_val = max_val - min_val
    
    return [(x - min_val) / range_val for x in numbers]
```

**Your Task:**
1.  **Reasoning (in a <thinking> block):**
    *   Analyze the Python code and its types. How will you map Python types (like lists of floats) to Dafny types (like `seq<real>`)?
    *   Analyze the function's logic. What are the pre-conditions (`requires`) and post-conditions (`ensures`)?
    *   Identify any loops and determine their invariants.
    *   Think about termination conditions for any recursive calls or loops.
2.  **Dafny Implementation (in a ```dafny ... ``` block):**
    *   Write the complete Dafny method, including its signature, `requires` clauses, `ensures` clauses, and the method body.
    *   **The return type of the main method must be a basic Dafny type.** Use `int`, `real`, `bool`, `string`, or a sequence of these types (e.g., `seq<int>`). Do not use custom `datatype`s in the return signature. If the Python code implies an optional return (e.g. returning `None`), you should return a sensible default for the basic type instead (e.g. `false`, `-1`, or an empty sequence `[]`).
    *   The Dafny method name must be exactly the same as the Python function name: `rescale_to_unit`. Do not change the casing.
    *   **All methods must have a concrete implementation (a body).** The `{:axiom}` attribute is forbidden for defining standard functions. However, if the problem's solution relies on an unproven mathematical conjecture (e.g., the Goldbach Conjecture, P vs NP), you may state the conjecture as an `axiom`. If you do so, you **must** include a comment identifying the conjecture (e.g., `// Axiom for the Twin Prime Conjecture`). Do not use axioms to avoid implementing solvable algorithms.
    *   **Provide explicit termination proofs.** For any recursive function, you must include a `decreases` clause. Do **not** use `decreases *`. For functions that operate on a sequence, the termination metric is almost always the length of the sequence (e.g., `decreases my_sequence`). For functions on integers, it is the integer itself (e.g., `decreases n`).
    *   **Do not use Dafny reserved keywords as variable names.** Avoid names like: `abstract, allocated, as, assert, assume, bool, break, by, calc, case, char, class, codatatype, const, constructor, datatype, decreases, else, ensures, exists, export, extends, false, forall, fresh, function, ghost, if, imap, import, in, include, int, invariant, is, iset, iterator, label, lemma, map, match, method, modifies, modify, module, multiset, nameonly, nat, new, newtype, null, object, object?, old, opened, ORDINAL, predicate, print, provides,reads, real, refines, requires, return, returns, reveal, reveals, seq, set, static, string, then, this, trait, true, twostate, type, unchanged, var, while, witness, yield, yields`. For example, instead of `var array`, use `var arr`.



=============== ASSISTANT ===============
--- THINKING ---
Let me analyze the Python function:

1. The function takes a list of floats and returns a list of floats
2. It finds the minimum and maximum values in the list
3. If min == max (all values are the same), it returns a list of 0.0s
4. Otherwise, it applies the linear transformation: (x - min) / (max - min) for each element

For Dafny translation:
- Python `List[float]` maps to `seq<real>` in Dafny
- The function requires at least 2 elements according to the documentation
- Need to handle the edge case where all numbers are the same
- Need helper functions for min and max since Dafny doesn't have built-in min/max for sequences

Let me think about the specifications:
- Requires: |numbers| >= 2 (at least two elements)
- Ensures: |result| == |numbers| (same length)
- Ensures: if all elements are the same, result is all 0.0
- Ensures: otherwise, min element becomes 0.0 and max element becomes 1.0
- Ensures: all elements in result are between 0.0 and 1.0 inclusive

I need helper functions:
1. A function to find the minimum value in a sequence
2. A function to find the maximum value in a sequence

For the main logic:
1. Find min and max
2. Check if they're equal
3. If equal, return sequence of 0.0s
4. Otherwise, apply the transformation

Let me write this step by step:

```dafny
function min_seq(numbers: seq<real>): real
  requires |numbers| > 0
  decreases numbers
{
  if |numbers| == 1 then numbers[0]
  else 
    var rest_min := min_seq(numbers[1..]);
    if numbers[0] <= rest_min then numbers[0] else rest_min


}

function max_seq(numbers: seq<real>): real
  requires |numbers| > 0
  decreases numbers
{
  if |numbers| == 1 then numbers[0]
  else 
    var rest_max := max_seq(numbers[1..]);
    if numbers[0] >= rest_max then numbers[0] else rest_max
}

method rescale_to_unit(numbers: seq<real>) returns (result: seq<real>)
  requires |numbers| >= 2
  ensures |result| == |numbers|
{
  var min_val := min_seq(numbers);
  var max_val := max_seq(numbers);

  if min_val == max_val {
    result := seq(|numbers|, i => 0.0);
  } else {
    result := seq(|numbers|, i => (numbers[i] - min_val) / (max_val - min_val));
  }
}
```

I'll complete the implementation by handling the normalization logic. The method creates a new sequence using the linear transformation, ensuring each element is scaled between 0 and 1. If all numbers are the same, it returns a sequence of zeros.

The recursive approach for finding min and max values provides a clean, functional implementation. I'll focus on making the method robust and mathematically precise.

I'll compute the min and max values directly within the rescaling method, eliminating the need for separate helper functions. This approach simplifies the implementation while maintaining the core logic of normalization. By calculating the range inline, I can ensure a straightforward transformation of the input sequence to a normalized range between 0 and 1.

The method will handle edge cases like uniform sequences by checking if the minimum and maximum values are identical, which would result in a zero-filled output sequence. This ensures numerical stability and prevents potential division by zero scenarios.

--- RESPONSE ---
<thinking>
Let me analyze the Python function:

1. **Types**: The function takes a `List[float]` and returns a `List[float]`. In Dafny, this maps to `seq<real>` for both input and output.

2. **Logic**: 
   - Find minimum and maximum values in the sequence
   - If min == max (all values same), return sequence of 0.0s
   - Otherwise, apply linear transformation: (x - min) / (max - min)

3. **Preconditions**: The documentation states "at least two elements", so `requires |numbers| >= 2`

4. **Postconditions**:
   - Result has same length as input
   - If all elements are equal, result is all 0.0s
   - Otherwise, the transformation maps min→0.0 and max→1.0
   - All result values are in [0.0, 1.0]

5. **Implementation approach**: I'll need helper functions to find min/max of a sequence, then apply the transformation. Since Dafny functions can't have loops, I'll use recursion with proper decreases clauses.
</thinking>

```dafny
function min_seq(numbers: seq<real>): real
  requires |numbers| > 0
  decreases numbers
{
  if |numbers| == 1 then 
    numbers[0]
  else 
    var rest_min := min_seq(numbers[1..]);
    if numbers[0] <= rest_min then numbers[0] else rest_min
}

function max_seq(numbers: seq<real>): real
  requires |numbers| > 0
  decreases numbers
{
  if |numbers| == 1 then 
    numbers[0]
  else 
    var rest_max := max_seq(numbers[1..]);
    if numbers[0] >= rest_max then numbers[0] else rest_max
}

lemma min_seq_property(numbers: seq<real>)
  requires |numbers| > 0
  ensures forall i :: 0 <= i < |numbers| ==> min_seq(numbers) <= numbers[i]
  decreases numbers
{
  if |numbers| == 1 {
    // Base case: trivially true
  } else {
    min_seq_property(numbers[1..]);
  }
}

lemma max_seq_property(numbers: seq<real>)
  requires |numbers| > 0
  ensures forall i :: 0 <= i < |numbers| ==> numbers[i] <= max_seq(numbers)
  decreases numbers
{
  if |numbers| == 1 {
    // Base case: trivially true
  } else {
    max_seq_property(numbers[1..]);
  }
}

method rescale_to_unit(numbers: seq<real>) returns (result: seq<real>)
  requires |numbers| >= 2
  ensures |result| == |numbers|
  ensures forall i :: 0 <= i < |result| ==> 0.0 <= result[i] <= 1.0
{
  var min_val := min_seq(numbers);
  var max_val := max_seq(numbers);
  
  min_seq_property(numbers);
  max_seq_property(numbers);
  
  if min_val == max_val {
    // All numbers are the same
    result := seq(|numbers|, i => 0.0);
  } else {
    var range_val := max_val - min_val;
    result := seq(|numbers|, i => (numbers[i] - min_val) / range_val);
    
    // The postcondition about bounds follows from:
    // - min_val <= numbers[i] <= max_val for all i
    // - So 0.0 <= (numbers[i] - min_val) <= range_val
    // - So 0.0 <= (numbers[i] - min_val) / range_val <= 1.0
  }
}
```

