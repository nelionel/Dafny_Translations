=============== SYSTEM ===============
You are an expert in formal verification and Dafny specifications. Your task is to analyze whether Dafny method specifications properly describe the behavior of the corresponding Python function.

You will be given:
1. A Python function with its behavior
2. A Dafny method translation with specifications (requires, ensures clauses)

Your job is to determine if the Dafny specifications fully and accurately capture the Python function's behavior. If not, you should improve the specifications.

IMPORTANT: You must respond with EXACTLY one of these phrases:
- "THE SCRIPT HAS PROPER SPECS" - if the specifications correctly describe the function
- "THE SCRIPT HAD NOT A PROPER SPEC" - if the specifications need improvement

After this phrase, provide the complete Dafny code (either unchanged or with improved specifications).



=============== USER ===============
Please analyze whether the Dafny specifications properly describe the Python function behavior.

**Python Function:**
```python
from typing import List


def rescale_to_unit(numbers: List[float]) -> List[float]:
    """ Given list of numbers (of at least two elements), apply a linear transform to that list,
    such that the smallest number will become 0 and the largest will become 1
    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])
    [0.0, 0.25, 0.5, 0.75, 1.0]
    """
    min_val = min(numbers)
    max_val = max(numbers)
    
    # Handle edge case where all numbers are the same
    if min_val == max_val:
        return [0.0] * len(numbers)
    
    range_val = max_val - min_val
    
    return [(x - min_val) / range_val for x in numbers]
```

**Current Dafny Code:**
```dafny
function min_seq(numbers: seq<real>): real
  requires |numbers| > 0
  decreases numbers
{
  if |numbers| == 1 then 
    numbers[0]
  else 
    var rest_min := min_seq(numbers[1..]);
    if numbers[0] <= rest_min then numbers[0] else rest_min
}

function max_seq(numbers: seq<real>): real
  requires |numbers| > 0
  decreases numbers
{
  if |numbers| == 1 then 
    numbers[0]
  else 
    var rest_max := max_seq(numbers[1..]);
    if numbers[0] >= rest_max then numbers[0] else rest_max
}

lemma min_seq_property(numbers: seq<real>)
  requires |numbers| > 0
  ensures forall i :: 0 <= i < |numbers| ==> min_seq(numbers) <= numbers[i]
  decreases numbers
{
  if |numbers| == 1 {
    // Base case: trivially true
  } else {
    min_seq_property(numbers[1..]);
  }
}

lemma max_seq_property(numbers: seq<real>)
  requires |numbers| > 0
  ensures forall i :: 0 <= i < |numbers| ==> numbers[i] <= max_seq(numbers)
  decreases numbers
{
  if |numbers| == 1 {
    // Base case: trivially true
  } else {
    max_seq_property(numbers[1..]);
  }
}

method rescale_to_unit(numbers: seq<real>) returns (result: seq<real>)
  requires |numbers| >= 2
  ensures |result| == |numbers|
  ensures forall i :: 0 <= i < |result| ==> 0.0 <= result[i] <= 1.0
{
  var min_val := min_seq(numbers);
  var max_val := max_seq(numbers);
  
  min_seq_property(numbers);
  max_seq_property(numbers);
  
  if min_val == max_val {
    // All numbers are the same
    result := seq(|numbers|, i => 0.0);
  } else {
    var range_val := max_val - min_val;
    result := seq(|numbers|, i => (numbers[i] - min_val) / range_val);
    
    // The postcondition about bounds follows from:
    // - min_val <= numbers[i] <= max_val for all i
    // - So 0.0 <= (numbers[i] - min_val) <= range_val
    // - So 0.0 <= (numbers[i] - min_val) / range_val <= 1.0
  }
}
```

**Analysis Task:**
1. Compare the Python function's behavior with the Dafny specifications
2. Check if the `requires` clauses capture all preconditions
3. Check if the `ensures` clauses capture all postconditions and behavior
4. Verify that the specifications fully describe what the function does

**Response Format:**
Start with exactly one of these phrases:
- "THE SCRIPT HAS PROPER SPECS" (if specifications are adequate)
- "THE SCRIPT HAD NOT A PROPER SPEC" (if specifications need improvement)

Then provide the complete Dafny code. If improving specifications:
- Add missing `requires` clauses for preconditions
- Add missing `ensures` clauses for postconditions
- Ensure specifications capture the function's complete behavior
- Preserve the existing method implementation unchanged

 


=============== ASSISTANT ===============
--- THINKING ---
Let me analyze the Python function's behavior and compare it with the Dafny specifications.

**Python Function Behavior:**
1. Takes a list of numbers (at least two elements)
2. Finds the minimum and maximum values
3. If min == max (all numbers are the same), returns a list of all 0.0s
4. Otherwise, applies linear transformation: (x - min) / (max - min)
5. The result has the smallest number become 0 and the largest become 1

**Current Dafny Specifications:**
- `requires |numbers| >= 2` - matches Python's requirement of at least two elements
- `ensures |result| == |numbers|` - correct, output has same length as input
- `ensures forall i :: 0 <= i < |result| ==> 0.0 <= result[i] <= 1.0` - correct, all values are between 0 and 1

**What's missing from the specifications:**
1. The key property that the minimum value becomes 0 and maximum becomes 1 (when they're different)
2. The property that when all values are the same, all results are 0
3. The monotonicity property - if numbers[i] <= numbers[j], then result[i] <= result[j]

Let me check what the key postconditions should be:

1. When min_val != max_val:
   - The minimum value in the input should map to 0 in the output
   - The maximum value in the input should map to 1 in the output
   - The transformation is linear

2. When min_val == max_val (all numbers are the same):
   - All output values should be 0

The current specifications are missing these crucial behavioral properties. The current ensures clauses only guarantee that the output values are in [0,1] range and the length is preserved, but they don't capture the actual transformation behavior.

So the specifications need improvement.

--- RESPONSE ---
THE SCRIPT HAD NOT A PROPER SPEC

```dafny
function min_seq(numbers: seq<real>): real
  requires |numbers| > 0
  decreases numbers
{
  if |numbers| == 1 then 
    numbers[0]
  else 
    var rest_min := min_seq(numbers[1..]);
    if numbers[0] <= rest_min then numbers[0] else rest_min
}

function max_seq(numbers: seq<real>): real
  requires |numbers| > 0
  decreases numbers
{
  if |numbers| == 1 then 
    numbers[0]
  else 
    var rest_max := max_seq(numbers[1..]);
    if numbers[0] >= rest_max then numbers[0] else rest_max
}

lemma min_seq_property(numbers: seq<real>)
  requires |numbers| > 0
  ensures forall i :: 0 <= i < |numbers| ==> min_seq(numbers) <= numbers[i]
  decreases numbers
{
  if |numbers| == 1 {
    // Base case: trivially true
  } else {
    min_seq_property(numbers[1..]);
  }
}

lemma max_seq_property(numbers: seq<real>)
  requires |numbers| > 0
  ensures forall i :: 0 <= i < |numbers| ==> numbers[i] <= max_seq(numbers)
  decreases numbers
{
  if |numbers| == 1 {
    // Base case: trivially true
  } else {
    max_seq_property(numbers[1..]);
  }
}

method rescale_to_unit(numbers: seq<real>) returns (result: seq<real>)
  requires |numbers| >= 2
  ensures |result| == |numbers|
  ensures forall i :: 0 <= i < |result| ==> 0.0 <= result[i] <= 1.0
  ensures var min_val := min_seq(numbers);
          var max_val := max_seq(numbers);
          if min_val == max_val then
            forall i :: 0 <= i < |result| ==> result[i] == 0.0
          else
            (exists i :: 0 <= i < |numbers| && numbers[i] == min_val ==> result[i] == 0.0) &&
            (exists j :: 0 <= j < |numbers| && numbers[j] == max_val ==> result[j] == 1.0) &&
            (forall k :: 0 <= k < |numbers| ==> result[k] == (numbers[k] - min_val) / (max_val - min_val))
{
  var min_val := min_seq(numbers);
  var max_val := max_seq(numbers);
  
  min_seq_property(numbers);
  max_seq_property(numbers);
  
  if min_val == max_val {
    // All numbers are the same
    result := seq(|numbers|, i => 0.0);
  } else {
    var range_val := max_val - min_val;
    result := seq(|numbers|, i => (numbers[i] - min_val) / range_val);
    
    // The postcondition about bounds follows from:
    // - min_val <= numbers[i] <= max_val for all i
    // - So 0.0 <= (numbers[i] - min_val) <= range_val
    // - So 0.0 <= (numbers[i] - min_val) / range_val <= 1.0
  }
}
```


=============== USER ===============
Please analyze whether the Dafny specifications properly describe the Python function behavior.

**Python Function:**
```python
from typing import List


def rescale_to_unit(numbers: List[float]) -> List[float]:
    """ Given list of numbers (of at least two elements), apply a linear transform to that list,
    such that the smallest number will become 0 and the largest will become 1
    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])
    [0.0, 0.25, 0.5, 0.75, 1.0]
    """
    min_val = min(numbers)
    max_val = max(numbers)
    
    # Handle edge case where all numbers are the same
    if min_val == max_val:
        return [0.0] * len(numbers)
    
    range_val = max_val - min_val
    
    return [(x - min_val) / range_val for x in numbers]
```

**Current Dafny Code:**
```dafny
function min_seq(numbers: seq<real>): real
  requires |numbers| > 0
  decreases numbers
{
  if |numbers| == 1 then 
    numbers[0]
  else 
    var rest_min := min_seq(numbers[1..]);
    if numbers[0] <= rest_min then numbers[0] else rest_min
}

function max_seq(numbers: seq<real>): real
  requires |numbers| > 0
  decreases numbers
{
  if |numbers| == 1 then 
    numbers[0]
  else 
    var rest_max := max_seq(numbers[1..]);
    if numbers[0] >= rest_max then numbers[0] else rest_max
}

lemma min_seq_property(numbers: seq<real>)
  requires |numbers| > 0
  ensures forall i :: 0 <= i < |numbers| ==> min_seq(numbers) <= numbers[i]
  decreases numbers
{
  if |numbers| == 1 {
    // Base case: trivially true
  } else {
    min_seq_property(numbers[1..]);
  }
}

lemma max_seq_property(numbers: seq<real>)
  requires |numbers| > 0
  ensures forall i :: 0 <= i < |numbers| ==> numbers[i] <= max_seq(numbers)
  decreases numbers
{
  if |numbers| == 1 {
    // Base case: trivially true
  } else {
    max_seq_property(numbers[1..]);
  }
}

method rescale_to_unit(numbers: seq<real>) returns (result: seq<real>)
  requires |numbers| >= 2
  ensures |result| == |numbers|
  ensures forall i :: 0 <= i < |result| ==> 0.0 <= result[i] <= 1.0
  ensures var min_val := min_seq(numbers);
          var max_val := max_seq(numbers);
          if min_val == max_val then
            forall i :: 0 <= i < |result| ==> result[i] == 0.0
          else
            (exists i :: 0 <= i < |numbers| && numbers[i] == min_val ==> result[i] == 0.0) &&
            (exists j :: 0 <= j < |numbers| && numbers[j] == max_val ==> result[j] == 1.0) &&
            (forall k :: 0 <= k < |numbers| ==> result[k] == (numbers[k] - min_val) / (max_val - min_val))
{
  var min_val := min_seq(numbers);
  var max_val := max_seq(numbers);
  
  min_seq_property(numbers);
  max_seq_property(numbers);
  
  if min_val == max_val {
    // All numbers are the same
    result := seq(|numbers|, i => 0.0);
  } else {
    var range_val := max_val - min_val;
    result := seq(|numbers|, i => (numbers[i] - min_val) / range_val);
    
    // The postcondition about bounds follows from:
    // - min_val <= numbers[i] <= max_val for all i
    // - So 0.0 <= (numbers[i] - min_val) <= range_val
    // - So 0.0 <= (numbers[i] - min_val) / range_val <= 1.0
  }
}
```

**Analysis Task:**
1. Compare the Python function's behavior with the Dafny specifications
2. Check if the `requires` clauses capture all preconditions
3. Check if the `ensures` clauses capture all postconditions and behavior
4. Verify that the specifications fully describe what the function does

**Response Format:**
Start with exactly one of these phrases:
- "THE SCRIPT HAS PROPER SPECS" (if specifications are adequate)
- "THE SCRIPT HAD NOT A PROPER SPEC" (if specifications need improvement)

Then provide the complete Dafny code. If improving specifications:
- Add missing `requires` clauses for preconditions
- Add missing `ensures` clauses for postconditions
- Ensure specifications capture the function's complete behavior
- Preserve the existing method implementation unchanged



This is attempt 2 to improve the specifications. Please analyze the current version and improve it further if needed. 


=============== ASSISTANT ===============
--- THINKING ---
Let me analyze the Python function behavior and the Dafny specifications:

**Python Function Behavior:**
1. Takes a list of numbers (at least two elements)
2. Finds min and max values
3. If min equals max (all numbers are the same), returns list of all 0.0s
4. Otherwise, applies linear transformation: (x - min) / (max - min)
5. Result: smallest becomes 0, largest becomes 1, others proportionally scaled

**Current Dafny Specifications Analysis:**

**Precondition:**
- `requires |numbers| >= 2` - matches Python requirement

**Postconditions:**
- `ensures |result| == |numbers|` - correct, output same length
- `ensures forall i :: 0 <= i < |result| ==> 0.0 <= result[i] <= 1.0` - correct bounds
- Complex ensures clause for behavior:
  - Handles min_val == max_val case correctly (all zeros)
  - For normal case: has existence claims and formula

Let me check the complex ensures clause more carefully:

```dafny
ensures var min_val := min_seq(numbers);
        var max_val := max_seq(numbers);
        if min_val == max_val then
          forall i :: 0 <= i < |result| ==> result[i] == 0.0
        else
          (exists i :: 0 <= i < |numbers| && numbers[i] == min_val ==> result[i] == 0.0) &&
          (exists j :: 0 <= j < |numbers| && numbers[j] == max_val ==> result[j] == 1.0) &&
          (forall k :: 0 <= k < |numbers| ==> result[k] == (numbers[k] - min_val) / (max_val - min_val))


```

The specification contains two critical logical flaws. The existence claims are incorrectly structured, creating potential verification challenges. The first issue involves the implication direction, which needs to be reversed to correctly capture the intended transformation. Additionally, the current formulation allows for vacuous truth in the existence claims, which could mask potential verification problems.

The core problem lies in how the specification attempts to assert the transformation's properties. The quantifiers and implications need careful restructuring to precisely capture the normalization algorithm's behavior across all input scenarios.

The proposed solution involves using universal quantifiers with precise conditions, ensuring that minimum and maximum value elements are correctly mapped while maintaining a consistent transformation for all other elements. This approach provides a more rigorous and comprehensive specification of the normalization process.

The key insight is to replace the existential quantifier with a universal quantifier, which guarantees that all minimum value elements are mapped to 0.0 and all maximum value elements are mapped to 1.0. The third condition then ensures a consistent linear scaling for all intermediate values.

By explicitly stating these three conditions, the specification becomes clearer and more precise about the expected transformation of the input array.

--- RESPONSE ---
THE SCRIPT HAD NOT A PROPER SPEC

```dafny
function min_seq(numbers: seq<real>): real
  requires |numbers| > 0
  decreases numbers
{
  if |numbers| == 1 then 
    numbers[0]
  else 
    var rest_min := min_seq(numbers[1..]);
    if numbers[0] <= rest_min then numbers[0] else rest_min
}

function max_seq(numbers: seq<real>): real
  requires |numbers| > 0
  decreases numbers
{
  if |numbers| == 1 then 
    numbers[0]
  else 
    var rest_max := max_seq(numbers[1..]);
    if numbers[0] >= rest_max then numbers[0] else rest_max
}

lemma min_seq_property(numbers: seq<real>)
  requires |numbers| > 0
  ensures forall i :: 0 <= i < |numbers| ==> min_seq(numbers) <= numbers[i]
  decreases numbers
{
  if |numbers| == 1 {
    // Base case: trivially true
  } else {
    min_seq_property(numbers[1..]);
  }
}

lemma max_seq_property(numbers: seq<real>)
  requires |numbers| > 0
  ensures forall i :: 0 <= i < |numbers| ==> numbers[i] <= max_seq(numbers)
  decreases numbers
{
  if |numbers| == 1 {
    // Base case: trivially true
  } else {
    max_seq_property(numbers[1..]);
  }
}

method rescale_to_unit(numbers: seq<real>) returns (result: seq<real>)
  requires |numbers| >= 2
  ensures |result| == |numbers|
  ensures forall i :: 0 <= i < |result| ==> 0.0 <= result[i] <= 1.0
  ensures var min_val := min_seq(numbers);
          var max_val := max_seq(numbers);
          if min_val == max_val then
            forall i :: 0 <= i < |result| ==> result[i] == 0.0
          else
            (forall i :: 0 <= i < |numbers| && numbers[i] == min_val ==> result[i] == 0.0) &&
            (forall j :: 0 <= j < |numbers| && numbers[j] == max_val ==> result[j] == 1.0) &&
            (forall k :: 0 <= k < |numbers| ==> result[k] == (numbers[k] - min_val) / (max_val - min_val))
{
  var min_val := min_seq(numbers);
  var max_val := max_seq(numbers);
  
  min_seq_property(numbers);
  max_seq_property(numbers);
  
  if min_val == max_val {
    // All numbers are the same
    result := seq(|numbers|, i => 0.0);
  } else {
    var range_val := max_val - min_val;
    result := seq(|numbers|, i => (numbers[i] - min_val) / range_val);
    
    // The postcondition about bounds follows from:
    // - min_val <= numbers[i] <= max_val for all i
    // - So 0.0 <= (numbers[i] - min_val) <= range_val
    // - So 0.0 <= (numbers[i] - min_val) / range_val <= 1.0
  }
}
```


=============== USER ===============
Please analyze whether the Dafny specifications properly describe the Python function behavior.

**Python Function:**
```python
from typing import List


def rescale_to_unit(numbers: List[float]) -> List[float]:
    """ Given list of numbers (of at least two elements), apply a linear transform to that list,
    such that the smallest number will become 0 and the largest will become 1
    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])
    [0.0, 0.25, 0.5, 0.75, 1.0]
    """
    min_val = min(numbers)
    max_val = max(numbers)
    
    # Handle edge case where all numbers are the same
    if min_val == max_val:
        return [0.0] * len(numbers)
    
    range_val = max_val - min_val
    
    return [(x - min_val) / range_val for x in numbers]
```

**Current Dafny Code:**
```dafny
function min_seq(numbers: seq<real>): real
  requires |numbers| > 0
  decreases numbers
{
  if |numbers| == 1 then 
    numbers[0]
  else 
    var rest_min := min_seq(numbers[1..]);
    if numbers[0] <= rest_min then numbers[0] else rest_min
}

function max_seq(numbers: seq<real>): real
  requires |numbers| > 0
  decreases numbers
{
  if |numbers| == 1 then 
    numbers[0]
  else 
    var rest_max := max_seq(numbers[1..]);
    if numbers[0] >= rest_max then numbers[0] else rest_max
}

lemma min_seq_property(numbers: seq<real>)
  requires |numbers| > 0
  ensures forall i :: 0 <= i < |numbers| ==> min_seq(numbers) <= numbers[i]
  decreases numbers
{
  if |numbers| == 1 {
    // Base case: trivially true
  } else {
    min_seq_property(numbers[1..]);
  }
}

lemma max_seq_property(numbers: seq<real>)
  requires |numbers| > 0
  ensures forall i :: 0 <= i < |numbers| ==> numbers[i] <= max_seq(numbers)
  decreases numbers
{
  if |numbers| == 1 {
    // Base case: trivially true
  } else {
    max_seq_property(numbers[1..]);
  }
}

method rescale_to_unit(numbers: seq<real>) returns (result: seq<real>)
  requires |numbers| >= 2
  ensures |result| == |numbers|
  ensures forall i :: 0 <= i < |result| ==> 0.0 <= result[i] <= 1.0
  ensures var min_val := min_seq(numbers);
          var max_val := max_seq(numbers);
          if min_val == max_val then
            forall i :: 0 <= i < |result| ==> result[i] == 0.0
          else
            (forall i :: 0 <= i < |numbers| && numbers[i] == min_val ==> result[i] == 0.0) &&
            (forall j :: 0 <= j < |numbers| && numbers[j] == max_val ==> result[j] == 1.0) &&
            (forall k :: 0 <= k < |numbers| ==> result[k] == (numbers[k] - min_val) / (max_val - min_val))
{
  var min_val := min_seq(numbers);
  var max_val := max_seq(numbers);
  
  min_seq_property(numbers);
  max_seq_property(numbers);
  
  if min_val == max_val {
    // All numbers are the same
    result := seq(|numbers|, i => 0.0);
  } else {
    var range_val := max_val - min_val;
    result := seq(|numbers|, i => (numbers[i] - min_val) / range_val);
    
    // The postcondition about bounds follows from:
    // - min_val <= numbers[i] <= max_val for all i
    // - So 0.0 <= (numbers[i] - min_val) <= range_val
    // - So 0.0 <= (numbers[i] - min_val) / range_val <= 1.0
  }
}
```

**Analysis Task:**
1. Compare the Python function's behavior with the Dafny specifications
2. Check if the `requires` clauses capture all preconditions
3. Check if the `ensures` clauses capture all postconditions and behavior
4. Verify that the specifications fully describe what the function does

**Response Format:**
Start with exactly one of these phrases:
- "THE SCRIPT HAS PROPER SPECS" (if specifications are adequate)
- "THE SCRIPT HAD NOT A PROPER SPEC" (if specifications need improvement)

Then provide the complete Dafny code. If improving specifications:
- Add missing `requires` clauses for preconditions
- Add missing `ensures` clauses for postconditions
- Ensure specifications capture the function's complete behavior
- Preserve the existing method implementation unchanged



This is attempt 3 to improve the specifications. Please analyze the current version and improve it further if needed. 


=============== ASSISTANT ===============
--- THINKING ---
Let me analyze the Python function and the Dafny specifications carefully.

**Python function behavior:**
1. Takes a list of floats with at least 2 elements
2. Finds min and max values
3. If min == max (all elements the same), returns a list of zeros with same length
4. Otherwise, applies linear transformation: (x - min_val) / (max_val - min_val)
5. This ensures the smallest becomes 0 and largest becomes 1

**Current Dafny specifications:**
1. `requires |numbers| >= 2` - matches Python requirement
2. `ensures |result| == |numbers|` - correct, preserves length
3. `ensures forall i :: 0 <= i < |result| ==> 0.0 <= result[i] <= 1.0` - correct bounds
4. Complex ensures clause that covers both cases (min==max and min!=max)

Let me check if the specifications are complete:

The ensures clause says:
- If min_val == max_val, then all result[i] == 0.0 ✓
- If min_val != max_val, then:
  - Elements that were min become 0.0 ✓
  - Elements that were max become 1.0 ✓
  - All elements follow the formula (numbers[k] - min_val) / (max_val - min_val) ✓

This looks comprehensive. The specification captures:
1. The precondition (at least 2 elements)
2. The length preservation
3. The bounds (0.0 to 1.0)
4. The exact transformation behavior for both cases

However, let me think if there's anything missing:
- The Python function doesn't have any additional constraints on the input
- The transformation is exactly what's specified
- The edge case handling is covered

Actually, I think the specifications are quite thorough. They capture all the key behaviors:


I'll verify the key specification requirements systematically. The Dafny specification meticulously addresses critical aspects of the normalization function. It ensures robust input validation by mandating at least two elements, guarantees output length matches input, constrains values between 0 and 1, and handles both uniform and varied input scenarios precisely. The conditional logic elegantly manages edge cases, transforming uniform inputs to zero vectors while scaling diverse inputs proportionally.

--- RESPONSE ---
THE SCRIPT HAS PROPER SPECS

```dafny
function min_seq(numbers: seq<real>): real
  requires |numbers| > 0
  decreases numbers
{
  if |numbers| == 1 then 
    numbers[0]
  else 
    var rest_min := min_seq(numbers[1..]);
    if numbers[0] <= rest_min then numbers[0] else rest_min
}

function max_seq(numbers: seq<real>): real
  requires |numbers| > 0
  decreases numbers
{
  if |numbers| == 1 then 
    numbers[0]
  else 
    var rest_max := max_seq(numbers[1..]);
    if numbers[0] >= rest_max then numbers[0] else rest_max
}

lemma min_seq_property(numbers: seq<real>)
  requires |numbers| > 0
  ensures forall i :: 0 <= i < |numbers| ==> min_seq(numbers) <= numbers[i]
  decreases numbers
{
  if |numbers| == 1 {
    // Base case: trivially true
  } else {
    min_seq_property(numbers[1..]);
  }
}

lemma max_seq_property(numbers: seq<real>)
  requires |numbers| > 0
  ensures forall i :: 0 <= i < |numbers| ==> numbers[i] <= max_seq(numbers)
  decreases numbers
{
  if |numbers| == 1 {
    // Base case: trivially true
  } else {
    max_seq_property(numbers[1..]);
  }
}

method rescale_to_unit(numbers: seq<real>) returns (result: seq<real>)
  requires |numbers| >= 2
  ensures |result| == |numbers|
  ensures forall i :: 0 <= i < |result| ==> 0.0 <= result[i] <= 1.0
  ensures var min_val := min_seq(numbers);
          var max_val := max_seq(numbers);
          if min_val == max_val then
            forall i :: 0 <= i < |result| ==> result[i] == 0.0
          else
            (forall i :: 0 <= i < |numbers| && numbers[i] == min_val ==> result[i] == 0.0) &&
            (forall j :: 0 <= j < |numbers| && numbers[j] == max_val ==> result[j] == 1.0) &&
            (forall k :: 0 <= k < |numbers| ==> result[k] == (numbers[k] - min_val) / (max_val - min_val))
{
  var min_val := min_seq(numbers);
  var max_val := max_seq(numbers);
  
  min_seq_property(numbers);
  max_seq_property(numbers);
  
  if min_val == max_val {
    // All numbers are the same
    result := seq(|numbers|, i => 0.0);
  } else {
    var range_val := max_val - min_val;
    result := seq(|numbers|, i => (numbers[i] - min_val) / range_val);
    
    // The postcondition about bounds follows from:
    // - min_val <= numbers[i] <= max_val for all i
    // - So 0.0 <= (numbers[i] - min_val) <= range_val
    // - So 0.0 <= (numbers[i] - min_val) / range_val <= 1.0
  }
}
```

