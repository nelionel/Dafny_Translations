=============== SYSTEM ===============
You are an expert programmer specializing in translating Python code to the Dafny verification language. Your task is to translate the provided Python function into a Dafny method that is both verifiable and compilable. Pay close attention to types, specifications, and providing concrete implementations for all methods.



=============== USER ===============
I will provide you with a Python function and its documentation. Please translate the Python function into a Dafny method.

**Python Function and Documentation:**
```python


def largest_divisor(n: int) -> int:
    """ For a given number n, find the largest number that divides n evenly, smaller than n
    >>> largest_divisor(15)
    5
    """

def largest_divisor(n: int) -> int:
    """ For a given number n, find the largest number that divides n evenly, smaller than n
    >>> largest_divisor(15)
    5
    """
    # Check divisors from n//2 down to 1
    for i in range(n // 2, 0, -1):
        if n % i == 0:
            return i
    
    # This should never be reached for positive integers > 1
    return 1
```

**Your Task:**
1.  **Reasoning (in a <thinking> block):**
    *   Analyze the Python code and its types. How will you map Python types (like lists of floats) to Dafny types (like `seq<real>`)?
    *   Analyze the function's logic. What are the pre-conditions (`requires`) and post-conditions (`ensures`)?
    *   Identify any loops and determine their invariants.
    *   Think about termination conditions for any recursive calls or loops.
2.  **Dafny Implementation (in a ```dafny ... ``` block):**
    *   Write the complete Dafny method, including its signature, `requires` clauses, `ensures` clauses, and the method body.
    *   **The return type of the main method must be a basic Dafny type.** Use `int`, `real`, `bool`, `string`, or a sequence of these types (e.g., `seq<int>`). Do not use custom `datatype`s in the return signature. If the Python code implies an optional return (e.g. returning `None`), you should return a sensible default for the basic type instead (e.g. `false`, `-1`, or an empty sequence `[]`).
    *   The Dafny method name must be exactly the same as the Python function name: `largest_divisor`. Do not change the casing.
    *   **All methods must have a concrete implementation (a body).** The `{:axiom}` attribute is forbidden for defining standard functions. However, if the problem's solution relies on an unproven mathematical conjecture (e.g., the Goldbach Conjecture, P vs NP), you may state the conjecture as an `axiom`. If you do so, you **must** include a comment identifying the conjecture (e.g., `// Axiom for the Twin Prime Conjecture`). Do not use axioms to avoid implementing solvable algorithms.
    *   **Provide explicit termination proofs.** For any recursive function, you must include a `decreases` clause. Do **not** use `decreases *`. For functions that operate on a sequence, the termination metric is almost always the length of the sequence (e.g., `decreases my_sequence`). For functions on integers, it is the integer itself (e.g., `decreases n`).
    *   **Do not use Dafny reserved keywords as variable names.** Avoid names like: `abstract, allocated, as, assert, assume, bool, break, by, calc, case, char, class, codatatype, const, constructor, datatype, decreases, else, ensures, exists, export, extends, false, forall, fresh, function, ghost, if, imap, import, in, include, int, invariant, is, iset, iterator, label, lemma, map, match, method, modifies, modify, module, multiset, nameonly, nat, new, newtype, null, object, object?, old, opened, ORDINAL, predicate, print, provides,reads, real, refines, requires, return, returns, reveal, reveals, seq, set, static, string, then, this, trait, true, twostate, type, unchanged, var, while, witness, yield, yields`. For example, instead of `var array`, use `var arr`.



=============== ASSISTANT ===============
--- THINKING ---
Let me analyze the Python function:

1. The function takes an integer `n` and returns the largest divisor of `n` that is smaller than `n`.
2. It iterates from `n // 2` down to 1, checking if each number divides `n` evenly.
3. When it finds a divisor, it returns that divisor.
4. If no divisor is found (which should never happen for positive integers > 1), it returns 1.

For the Dafny translation:

**Types:**
- Input: `n: int`
- Output: `int`

**Preconditions:**
- `n > 1` (since we're looking for the largest divisor smaller than n, and for n=1, there's no such divisor)

**Postconditions:**
- The returned value should divide `n` evenly
- The returned value should be less than `n`
- The returned value should be the largest such divisor

**Loop analysis:**
- The loop goes from `n // 2` down to 1
- Loop invariant: all numbers from `i+1` to `n//2` do not divide `n`
- Termination: the loop variable `i` decreases each iteration and has a lower bound of 1

Let me write the Dafny code:

```dafny
method largest_divisor(n: int) returns (result: int)
    requires n > 1
    ensures result < n
    ensures n % result == 0
    ensures forall k :: result < k < n ==> n % k != 0
{
    var i := n / 2;
    while i > 0
        invariant 0 <= i <= n / 2
        invariant forall k :: i < k <= n / 2 ==> n % k != 0
        decreases i
    {
        if n % i == 0 {
            return i;
        }
        i := i - 1;
    }
    
    return 1;
}
```

I recognize the complexity of finding the largest divisor involves carefully searching through potential divisors. The method systematically checks divisors from the largest possible (n/2) down to 1, ensuring we capture the largest divisor efficiently. The implementation guarantees we'll always find a divisor for numbers greater than 1, with 1 being the default fallback.

The key insight is the methodical descent through potential divisors, leveraging integer division and modulo operations to identify the first (and thus largest) divisor encountered.

--- RESPONSE ---
<thinking>
Let me analyze the Python function:

1. **Function Logic**: The function finds the largest divisor of `n` that is smaller than `n` itself. It searches from `n//2` down to 1, returning the first divisor it finds (which will be the largest).

2. **Type Mapping**: 
   - Input: `n: int` → `n: int` in Dafny
   - Output: `int` → `int` in Dafny

3. **Preconditions**: 
   - `n > 1` is needed because for n=1, there's no divisor smaller than n, and for n≤0, the concept doesn't make sense.

4. **Postconditions**:
   - The result should divide `n` evenly: `n % result == 0`
   - The result should be less than `n`: `result < n`
   - The result should be the largest such divisor: `forall k :: result < k < n ==> n % k != 0`

5. **Loop Analysis**:
   - Loop variable `i` goes from `n/2` down to 1
   - Loop invariant: all numbers from `i+1` to `n/2` do not divide `n`
   - Termination: `i` decreases each iteration with lower bound 0

6. **Edge Case**: The function returns 1 at the end, which is correct since 1 always divides any positive integer.
</thinking>

```dafny
method largest_divisor(n: int) returns (result: int)
    requires n > 1
    ensures result < n
    ensures n % result == 0
    ensures forall k :: result < k < n ==> n % k != 0
{
    var i := n / 2;
    while i > 0
        invariant 0 <= i <= n / 2
        invariant forall k :: i < k <= n / 2 ==> n % k != 0
        decreases i
    {
        if n % i == 0 {
            return i;
        }
        i := i - 1;
    }
    
    return 1;
}
```

