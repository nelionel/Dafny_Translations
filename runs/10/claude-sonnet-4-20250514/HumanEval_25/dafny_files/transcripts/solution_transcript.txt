=============== SYSTEM ===============
You are an expert programmer specializing in translating Python code to the Dafny verification language. Your task is to translate the provided Python function into a Dafny method that is both verifiable and compilable. Pay close attention to types, specifications, and providing concrete implementations for all methods.



=============== USER ===============
I will provide you with a Python function and its documentation. Please translate the Python function into a Dafny method.

**Python Function and Documentation:**
```python
from typing import List


def factorize(n: int) -> List[int]:
    """ Return list of prime factors of given integer in the order from smallest to largest.
    Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.
    Input number should be equal to the product of all factors
    >>> factorize(8)
    [2, 2, 2]
    >>> factorize(25)
    [5, 5]
    >>> factorize(70)
    [2, 5, 7]
    """

from typing import List


def factorize(n: int) -> List[int]:
    """ Return list of prime factors of given integer in the order from smallest to largest.
    Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.
    Input number should be equal to the product of all factors
    >>> factorize(8)
    [2, 2, 2]
    >>> factorize(25)
    [5, 5]
    >>> factorize(70)
    [2, 5, 7]
    """
    factors = []
    
    # Handle the case where n is 1 or less
    if n <= 1:
        return factors
    
    # Check for factor 2
    while n % 2 == 0:
        factors.append(2)
        n //= 2
    
    # Check for odd factors starting from 3
    factor = 3
    while factor * factor <= n:
        while n % factor == 0:
            factors.append(factor)
            n //= factor
        factor += 2
    
    # If n is still greater than 1, then it's a prime factor
    if n > 1:
        factors.append(n)
    
    return factors
```

**Your Task:**
1.  **Reasoning (in a <thinking> block):**
    *   Analyze the Python code and its types. How will you map Python types (like lists of floats) to Dafny types (like `seq<real>`)?
    *   Analyze the function's logic. What are the pre-conditions (`requires`) and post-conditions (`ensures`)?
    *   Identify any loops and determine their invariants.
    *   Think about termination conditions for any recursive calls or loops.
2.  **Dafny Implementation (in a ```dafny ... ``` block):**
    *   Write the complete Dafny method, including its signature, `requires` clauses, `ensures` clauses, and the method body.
    *   **The return type of the main method must be a basic Dafny type.** Use `int`, `real`, `bool`, `string`, or a sequence of these types (e.g., `seq<int>`). Do not use custom `datatype`s in the return signature. If the Python code implies an optional return (e.g. returning `None`), you should return a sensible default for the basic type instead (e.g. `false`, `-1`, or an empty sequence `[]`).
    *   The Dafny method name must be exactly the same as the Python function name: `factorize`. Do not change the casing.
    *   **All methods must have a concrete implementation (a body).** The `{:axiom}` attribute is forbidden for defining standard functions. However, if the problem's solution relies on an unproven mathematical conjecture (e.g., the Goldbach Conjecture, P vs NP), you may state the conjecture as an `axiom`. If you do so, you **must** include a comment identifying the conjecture (e.g., `// Axiom for the Twin Prime Conjecture`). Do not use axioms to avoid implementing solvable algorithms.
    *   **Provide explicit termination proofs.** For any recursive function, you must include a `decreases` clause. Do **not** use `decreases *`. For functions that operate on a sequence, the termination metric is almost always the length of the sequence (e.g., `decreases my_sequence`). For functions on integers, it is the integer itself (e.g., `decreases n`).
    *   **Do not use Dafny reserved keywords as variable names.** Avoid names like: `abstract, allocated, as, assert, assume, bool, break, by, calc, case, char, class, codatatype, const, constructor, datatype, decreases, else, ensures, exists, export, extends, false, forall, fresh, function, ghost, if, imap, import, in, include, int, invariant, is, iset, iterator, label, lemma, map, match, method, modifies, modify, module, multiset, nameonly, nat, new, newtype, null, object, object?, old, opened, ORDINAL, predicate, print, provides,reads, real, refines, requires, return, returns, reveal, reveals, seq, set, static, string, then, this, trait, true, twostate, type, unchanged, var, while, witness, yield, yields`. For example, instead of `var array`, use `var arr`.



=============== ASSISTANT ===============
--- THINKING ---
Let me analyze the Python function first:

1. The function takes an integer `n` and returns a list of its prime factors in ascending order.
2. It handles special cases where n <= 1 by returning an empty list.
3. It first extracts all factors of 2.
4. Then it checks odd factors starting from 3, incrementing by 2 each time.
5. It continues until factor * factor > n.
6. If n is still > 1 after this process, n itself is a prime factor.

For the Dafny translation:

**Types:**
- `int` in Python maps to `int` in Dafny
- `List[int]` maps to `seq<int>` in Dafny

**Preconditions:**
- The function should work for any integer, but based on the logic, we might want to require n >= 0 or handle negative numbers appropriately.

**Postconditions:**
- The result should be a sequence of prime factors
- The product of all factors should equal the original n (if n > 1)
- The factors should be in non-decreasing order
- Each factor should be prime

**Loop invariants:**
- For the while loop that extracts factors of 2: the current n multiplied by the product of factors found so far equals the original n
- For the main factorization loop: similar invariant

**Termination:**
- The loops terminate because we're dividing n by factors, making it smaller
- The outer loop terminates because factor increases and we stop when factor * factor > n

Let me implement this:

```dafny
method factorize(n: int) returns (factors: seq<int>)
    requires n >= 0
    ensures |factors| >= 0
    ensures n <= 1 ==> |factors| == 0
    ensures n > 1 ==> |factors| > 0
    // Additional postconditions about primality and product would be complex to specify


```

I'll start by initializing an empty sequence and handling the base case. The method first checks if the input is less than or equal to 1, immediately returning an empty sequence if true. Then it begins extracting factors systematically, starting with factors of 2. The process involves repeatedly dividing by 2 and adding 2 to the factors list until the number is no longer divisible by 2.

Next, I'll iterate through odd factors starting from 3, carefully checking divisibility. When a factor is found, I'll divide the current number by that factor and add it to the factors list. I'll increment the potential factor by 2 to continue checking odd numbers.

If the remaining number is greater than 1 after this process, it means the number itself is a prime factor, so I'll add it to the final list of factors.

The key challenge is ensuring the loop terminates correctly, which requires a careful approach to the decreasing metric and divisibility checks.

```

--- RESPONSE ---
<thinking>
Let me analyze the Python function:

1. **Types**: `int` maps to `int` in Dafny, and `List[int]` maps to `seq<int>`
2. **Logic**: The function finds prime factors by trial division - first extracting all factors of 2, then checking odd numbers starting from 3
3. **Preconditions**: The function should handle any integer, but negative numbers don't make sense for factorization, so I'll require `n >= 0`
4. **Postconditions**: 
   - Empty sequence for n <= 1
   - Non-empty sequence for n > 1
   - Factors should be in non-decreasing order
   - Product of factors should equal original n (complex to specify formally)
5. **Loop invariants**: Need to track that the current number times the product of found factors equals the original n
6. **Termination**: 
   - Inner loops terminate because we divide the current number by factors
   - Outer loop terminates because factor increases and we stop when factorÂ² > current

The trickiest part is the termination proof for the outer loop, since the decreases metric isn't straightforward - sometimes current decreases, sometimes factor increases.
</thinking>

```dafny
method factorize(n: int) returns (factors: seq<int>)
    requires n >= 0
    ensures n <= 1 ==> |factors| == 0
    ensures n > 1 ==> |factors| > 0
    ensures forall i :: 0 <= i < |factors| - 1 ==> factors[i] <= factors[i + 1]
{
    factors := [];
    
    if n <= 1 {
        return;
    }
    
    var current := n;
    
    // Extract all factors of 2
    while current % 2 == 0
        invariant current > 0
        decreases current
    {
        factors := factors + [2];
        current := current / 2;
    }
    
    // Check odd factors starting from 3
    var factor := 3;
    while factor * factor <= current
        invariant factor >= 3
        invariant factor % 2 == 1
        invariant current > 0
        decreases current - factor + 1000000  // Ensures termination as either current decreases or factor increases
    {
        if current % factor == 0 {
            while current % factor == 0
                invariant current > 0
                decreases current
            {
                factors := factors + [factor];
                current := current / factor;
            }
        }
        factor := factor + 2;
    }
    
    // If current is still greater than 1, then it's a prime factor
    if current > 1 {
        factors := factors + [current];
    }
}
```

