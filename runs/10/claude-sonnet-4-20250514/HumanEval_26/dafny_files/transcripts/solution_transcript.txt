=============== SYSTEM ===============
You are an expert programmer specializing in translating Python code to the Dafny verification language. Your task is to translate the provided Python function into a Dafny method that is both verifiable and compilable. Pay close attention to types, specifications, and providing concrete implementations for all methods.



=============== USER ===============
I will provide you with a Python function and its documentation. Please translate the Python function into a Dafny method.

**Python Function and Documentation:**
```python
from typing import List


def remove_duplicates(numbers: List[int]) -> List[int]:
    """ From a list of integers, remove all elements that occur more than once.
    Keep order of elements left the same as in the input.
    >>> remove_duplicates([1, 2, 3, 2, 4])
    [1, 3, 4]
    """

from typing import List


def remove_duplicates(numbers: List[int]) -> List[int]:
    """ From a list of integers, remove all elements that occur more than once.
    Keep order of elements left the same as in the input.
    >>> remove_duplicates([1, 2, 3, 2, 4])
    [1, 3, 4]
    """
    # Count occurrences of each number
    count = {}
    for num in numbers:
        count[num] = count.get(num, 0) + 1
    
    # Keep only numbers that appear exactly once, maintaining order
    result = []
    for num in numbers:
        if count[num] == 1:
            result.append(num)
    
    return result
```

**Your Task:**
1.  **Reasoning (in a <thinking> block):**
    *   Analyze the Python code and its types. How will you map Python types (like lists of floats) to Dafny types (like `seq<real>`)?
    *   Analyze the function's logic. What are the pre-conditions (`requires`) and post-conditions (`ensures`)?
    *   Identify any loops and determine their invariants.
    *   Think about termination conditions for any recursive calls or loops.
2.  **Dafny Implementation (in a ```dafny ... ``` block):**
    *   Write the complete Dafny method, including its signature, `requires` clauses, `ensures` clauses, and the method body.
    *   **The return type of the main method must be a basic Dafny type.** Use `int`, `real`, `bool`, `string`, or a sequence of these types (e.g., `seq<int>`). Do not use custom `datatype`s in the return signature. If the Python code implies an optional return (e.g. returning `None`), you should return a sensible default for the basic type instead (e.g. `false`, `-1`, or an empty sequence `[]`).
    *   The Dafny method name must be exactly the same as the Python function name: `remove_duplicates`. Do not change the casing.
    *   **All methods must have a concrete implementation (a body).** The `{:axiom}` attribute is forbidden for defining standard functions. However, if the problem's solution relies on an unproven mathematical conjecture (e.g., the Goldbach Conjecture, P vs NP), you may state the conjecture as an `axiom`. If you do so, you **must** include a comment identifying the conjecture (e.g., `// Axiom for the Twin Prime Conjecture`). Do not use axioms to avoid implementing solvable algorithms.
    *   **Provide explicit termination proofs.** For any recursive function, you must include a `decreases` clause. Do **not** use `decreases *`. For functions that operate on a sequence, the termination metric is almost always the length of the sequence (e.g., `decreases my_sequence`). For functions on integers, it is the integer itself (e.g., `decreases n`).
    *   **Do not use Dafny reserved keywords as variable names.** Avoid names like: `abstract, allocated, as, assert, assume, bool, break, by, calc, case, char, class, codatatype, const, constructor, datatype, decreases, else, ensures, exists, export, extends, false, forall, fresh, function, ghost, if, imap, import, in, include, int, invariant, is, iset, iterator, label, lemma, map, match, method, modifies, modify, module, multiset, nameonly, nat, new, newtype, null, object, object?, old, opened, ORDINAL, predicate, print, provides,reads, real, refines, requires, return, returns, reveal, reveals, seq, set, static, string, then, this, trait, true, twostate, type, unchanged, var, while, witness, yield, yields`. For example, instead of `var array`, use `var arr`.



=============== ASSISTANT ===============
--- THINKING ---
Let me analyze the Python function:

1. The function takes a list of integers and returns a list of integers
2. It removes all elements that occur more than once, keeping the order of remaining elements
3. The algorithm:
   - First pass: count occurrences of each number
   - Second pass: keep only numbers that appear exactly once, maintaining order

For Dafny:
- Input type: `seq<int>` (sequence of integers)
- Output type: `seq<int>`
- The function needs to:
  1. Count occurrences of each element
  2. Filter elements that appear exactly once while maintaining order

Let me think about specifications:
- Preconditions: None really needed, any sequence of integers is valid input
- Postconditions: 
  - The result should contain only elements that appear exactly once in the input
  - The order should be preserved
  - No element in the result should appear more than once

For the implementation:
1. I'll need a helper function to count occurrences of an element in a sequence
2. Then filter the sequence based on the count

Let me think about loop invariants for counting and filtering:
- For counting: the count function should be straightforward
- For filtering: need to maintain that we're building the result correctly

Let me write this step by step:

```dafny
method remove_duplicates(numbers: seq<int>) returns (result: seq<int>)
{
    result := [];
    var i := 0;
    while i < |numbers|
        invariant 0 <= i <= |numbers|
        invariant |result| <= i
        // result contains elements from numbers[0..i) that appear exactly once in numbers
        invariant forall j :: 0 <= j < |result| ==> count_occurrences(numbers, result[j]) == 1
        invariant forall j :: 0 <= j < |result| ==> result[j] in numbers[0..i]
    {
        if count_occurrences(numbers, numbers[i]) == 1 {
            result := result + [numbers[i]];
        }
        i := i + 1;
    }
}

function count_occurrences(seq: seq<int>, target: int): int
{
    if |seq| == 0 then 0
    else if seq[0] == target then 1 + count_occurrences(seq[1..], target)
    else count_occurrences(seq[1..], target)
}
```

I realize I need to refine the specifications more carefully. The current approach requires additional verification to ensure complete correctness. The implementation looks promising, but might need more rigorous proof of its correctness.

The key constraints demand a solution that:
- Captures unique elements precisely
- Maintains the original sequence's order
- Guarantees no duplicates in the result

These specifications will guide a more robust implementation strategy.

--- RESPONSE ---
<thinking>
Let me analyze the Python function:

1. **Types**: The function takes a `List[int]` and returns a `List[int]`. In Dafny, this maps to `seq<int>` for both input and output.

2. **Logic**: The function removes all elements that occur more than once, keeping the order of remaining elements. It does this in two passes:
   - First pass: count occurrences of each number
   - Second pass: keep only numbers that appear exactly once, maintaining order

3. **Specifications**:
   - Preconditions: None needed - any sequence of integers is valid
   - Postconditions: 
     - Result contains only elements that appear exactly once in input
     - Order is preserved
     - Every element that appears exactly once in input is in the result

4. **Implementation approach**: I'll need a helper function to count occurrences, then iterate through the input sequence and include elements that have count == 1.

5. **Loop invariants**: For the main filtering loop, I need to maintain that the result so far contains the correct elements from the processed portion of the input.
</thinking>

```dafny
method remove_duplicates(numbers: seq<int>) returns (result: seq<int>)
    ensures forall x :: x in result ==> count_occurrences(numbers, x) == 1
    ensures forall x :: x in numbers && count_occurrences(numbers, x) == 1 ==> x in result
    ensures |result| <= |numbers|
{
    result := [];
    var i := 0;
    
    while i < |numbers|
        invariant 0 <= i <= |numbers|
        invariant forall x :: x in result ==> count_occurrences(numbers, x) == 1
        invariant forall j :: 0 <= j < i && count_occurrences(numbers, numbers[j]) == 1 ==> numbers[j] in result
        invariant forall x :: x in result ==> x in numbers[0..i]
    {
        if count_occurrences(numbers, numbers[i]) == 1 {
            result := result + [numbers[i]];
        }
        i := i + 1;
    }
}

function count_occurrences(s: seq<int>, target: int): int
    decreases s
{
    if |s| == 0 then 0
    else if s[0] == target then 1 + count_occurrences(s[1..], target)
    else count_occurrences(s[1..], target)
}
```

