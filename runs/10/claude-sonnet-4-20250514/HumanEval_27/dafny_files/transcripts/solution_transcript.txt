=============== SYSTEM ===============
You are an expert programmer specializing in translating Python code to the Dafny verification language. Your task is to translate the provided Python function into a Dafny method that is both verifiable and compilable. Pay close attention to types, specifications, and providing concrete implementations for all methods.



=============== USER ===============
I will provide you with a Python function and its documentation. Please translate the Python function into a Dafny method.

**Python Function and Documentation:**
```python


def flip_case(string: str) -> str:
    """ For a given string, flip lowercase characters to uppercase and uppercase to lowercase.
    >>> flip_case('Hello')
    'hELLO'
    """

def flip_case(string: str) -> str:
    """ For a given string, flip lowercase characters to uppercase and uppercase to lowercase.
    >>> flip_case('Hello')
    'hELLO'
    """
    result = ""
    for char in string:
        if char.islower():
            result += char.upper()
        elif char.isupper():
            result += char.lower()
        else:
            result += char
    return result
```

**Your Task:**
1.  **Reasoning (in a <thinking> block):**
    *   Analyze the Python code and its types. How will you map Python types (like lists of floats) to Dafny types (like `seq<real>`)?
    *   Analyze the function's logic. What are the pre-conditions (`requires`) and post-conditions (`ensures`)?
    *   Identify any loops and determine their invariants.
    *   Think about termination conditions for any recursive calls or loops.
2.  **Dafny Implementation (in a ```dafny ... ``` block):**
    *   Write the complete Dafny method, including its signature, `requires` clauses, `ensures` clauses, and the method body.
    *   **The return type of the main method must be a basic Dafny type.** Use `int`, `real`, `bool`, `string`, or a sequence of these types (e.g., `seq<int>`). Do not use custom `datatype`s in the return signature. If the Python code implies an optional return (e.g. returning `None`), you should return a sensible default for the basic type instead (e.g. `false`, `-1`, or an empty sequence `[]`).
    *   The Dafny method name must be exactly the same as the Python function name: `flip_case`. Do not change the casing.
    *   **All methods must have a concrete implementation (a body).** The `{:axiom}` attribute is forbidden for defining standard functions. However, if the problem's solution relies on an unproven mathematical conjecture (e.g., the Goldbach Conjecture, P vs NP), you may state the conjecture as an `axiom`. If you do so, you **must** include a comment identifying the conjecture (e.g., `// Axiom for the Twin Prime Conjecture`). Do not use axioms to avoid implementing solvable algorithms.
    *   **Provide explicit termination proofs.** For any recursive function, you must include a `decreases` clause. Do **not** use `decreases *`. For functions that operate on a sequence, the termination metric is almost always the length of the sequence (e.g., `decreases my_sequence`). For functions on integers, it is the integer itself (e.g., `decreases n`).
    *   **Do not use Dafny reserved keywords as variable names.** Avoid names like: `abstract, allocated, as, assert, assume, bool, break, by, calc, case, char, class, codatatype, const, constructor, datatype, decreases, else, ensures, exists, export, extends, false, forall, fresh, function, ghost, if, imap, import, in, include, int, invariant, is, iset, iterator, label, lemma, map, match, method, modifies, modify, module, multiset, nameonly, nat, new, newtype, null, object, object?, old, opened, ORDINAL, predicate, print, provides,reads, real, refines, requires, return, returns, reveal, reveals, seq, set, static, string, then, this, trait, true, twostate, type, unchanged, var, while, witness, yield, yields`. For example, instead of `var array`, use `var arr`.



=============== ASSISTANT ===============
--- THINKING ---
Let me analyze the Python function:

1. The function takes a string as input and returns a string.
2. It iterates through each character in the string.
3. For each character:
   - If it's lowercase, convert to uppercase and add to result
   - If it's uppercase, convert to lowercase and add to result
   - Otherwise (not a letter), keep the character as is and add to result
4. Return the result string.

In Dafny:
- The input type will be `string`
- The return type will be `string`
- I need to handle string operations, including checking if a character is upper/lowercase and converting case

For the logic:
- Pre-conditions: None really needed, any string is valid input
- Post-conditions: The result string should have the same length as the input string, and each character should be the case-flipped version of the corresponding input character.

For the loop:
- I'll iterate through the string by index
- Loop invariant: The result string built so far has the correct case-flipped characters for the processed portion
- Termination: The loop index increases and is bounded by the string length

Let me think about Dafny string operations:
- Strings are sequences of characters in Dafny
- I can access characters by index: `string[i]`
- I can get string length: `|string|`
- I need functions to check if a character is upper/lowercase and to convert case
- I can build strings using concatenation or sequence operations

Actually, let me check what string operations are available in Dafny. In Dafny, strings are sequences of characters. I can:
- Access individual characters: `s[i]`
- Get length: `|s|`
- Concatenate: `s1 + s2`
- Create from sequence of chars: probably need to build a sequence and convert

For character operations, I need to check if characters are uppercase/lowercase and convert them. 

I see Dafny provides built-in methods for character type operations. The `char` type has specific predicates and conversion methods to handle case transformations. This means I can directly use methods like `IsLower()`, `IsUpper()`, and corresponding case conversion functions to implement the case-flipping logic efficiently.

The implementation will involve iterating through the string, checking each character's case, and applying the appropriate conversion while building the result string. I'll need to carefully manage the string construction process to ensure each character is correctly transformed. I'll carefully check the syntax and add precise specifications for the method. The character case conversion requires specific Dafny sequence operations. I'll focus on the method's contract and implementation details:

```dafny
method flip_case(s: string) returns (result: string)
    ensures |result| == |s|
    ensures forall i :: 0 <= i < |s| =
```

I notice the thinking is cut off mid-sentence, so I'll complete the thought by copying the next part of the thinking:

```dafny
method flip_case(s: string) returns (result: string)
    ensures |result| == |s|
    ensures forall i :: 0 <= i < |s| =
        (s[i].IsLower() ==> result[i] == s[i].ToUpper()) &&
        (s[i].IsUpper() ==> result[i] == s[i].ToLower()) &&
        (!s[i].IsLower() && !s[i].IsUpper() ==> result[i] == s[i])
{
    result := "";
    var i := 0;
    while i < |s|
        invariant 0 <= i <= |s|
        invariant |result| == i
        invariant forall j :: 0 <= j < i ==>
            (s[j].IsLower() ==> result[j] == s[j].ToUpper()) &&
            (s[j].IsUpper() ==> result[j] == s[j].ToLower()) &&
            (!s[j].IsLower() && !s[j].IsUpper() ==> result[j] == s[j])
    {
        var c := s[i];
        if c.IsLower() {
            result := result + [c.ToUpper()];
        } else if c.IsUpper() {
            result := result + [c.ToLower()];
        } else {
            result := result + [c];
        }
        i := i + 1;
    }
}
```

The method systematically transforms each character's case while preserving non-alphabetic characters, with rigorous Dafny specifications ensuring correctness.

--- RESPONSE ---
<thinking>
Let me analyze the Python function:

1. **Types**: The function takes a `str` and returns a `str`, which in Dafny maps to `string` â†’ `string`.

2. **Logic**: The function iterates through each character in the input string:
   - If the character is lowercase, convert to uppercase
   - If the character is uppercase, convert to lowercase  
   - Otherwise, keep the character unchanged
   - Build and return the result string

3. **Pre-conditions**: None needed - any string is valid input.

4. **Post-conditions**: 
   - Result string has same length as input
   - Each character in result is the case-flipped version of corresponding input character

5. **Loop analysis**: 
   - Iterate by index through the string
   - Invariant: The result built so far correctly case-flips the processed characters
   - Termination: Index increases and is bounded by string length

6. **Dafny considerations**:
   - Use `char.IsLower()`, `char.IsUpper()`, `char.ToUpper()`, `char.ToLower()`
   - Build result string using sequence concatenation
   - Need proper loop invariants and decreases clause
</thinking>

```dafny
method flip_case(s: string) returns (result: string)
    ensures |result| == |s|
    ensures forall i :: 0 <= i < |s| ==> 
        (s[i].IsLower() ==> result[i] == s[i].ToUpper()) &&
        (s[i].IsUpper() ==> result[i] == s[i].ToLower()) &&
        (!s[i].IsLower() && !s[i].IsUpper() ==> result[i] == s[i])
{
    result := "";
    var i := 0;
    while i < |s|
        invariant 0 <= i <= |s|
        invariant |result| == i
        invariant forall j :: 0 <= j < i ==> 
            (s[j].IsLower() ==> result[j] == s[j].ToUpper()) &&
            (s[j].IsUpper() ==> result[j] == s[j].ToLower()) &&
            (!s[j].IsLower() && !s[j].IsUpper() ==> result[j] == s[j])
        decreases |s| - i
    {
        var c := s[i];
        if c.IsLower() {
            result := result + [c.ToUpper()];
        } else if c.IsUpper() {
            result := result + [c.ToLower()];
        } else {
            result := result + [c];
        }
        i := i + 1;
    }
}
```


=============== USER ===============
Your previous attempt failed to compile. Here is the error message:
<compilation_error>
temp_compile.dfy(4,14): Error: type char does not have a member IsLower
  |
4 |         (s[i].IsLower() ==> result[i] == s[i].ToUpper()) &&
  |          ^^^^^^^^^^^^

temp_compile.dfy(4,46): Error: type char does not have a member ToUpper
  |
4 |         (s[i].IsLower() ==> result[i] == s[i].ToUpper()) &&
  |                                          ^^^^^^^^^^^^

temp_compile.dfy(5,14): Error: type char does not have a member IsUpper
  |
5 |         (s[i].IsUpper() ==> result[i] == s[i].ToLower()) &&
  |          ^^^^^^^^^^^^

temp_compile.dfy(5,46): Error: type char does not have a member ToLower
  |
5 |         (s[i].IsUpper() ==> result[i] == s[i].ToLower()) &&
  |                                          ^^^^^^^^^^^^

temp_compile.dfy(6,15): Error: type char does not have a member IsLower
  |
6 |         (!s[i].IsLower() && !s[i].IsUpper() ==> result[i] == s[i])
  |           ^^^^^^^^^^^^

temp_compile.dfy(6,34): Error: type char does not have a member IsUpper
  |
6 |         (!s[i].IsLower() && !s[i].IsUpper() ==> result[i] == s[i])
  |                              ^^^^^^^^^^^^

temp_compile.dfy(14,18): Error: type char does not have a member IsLower
   |
14 |             (s[j].IsLower() ==> result[j] == s[j].ToUpper()) &&
   |              ^^^^^^^^^^^^

temp_compile.dfy(14,50): Error: type char does not have a member ToUpper
   |
14 |             (s[j].IsLower() ==> result[j] == s[j].ToUpper()) &&
   |                                              ^^^^^^^^^^^^

temp_compile.dfy(15,18): Error: type char does not have a member IsUpper
   |
15 |             (s[j].IsUpper() ==> result[j] == s[j].ToLower()) &&
   |              ^^^^^^^^^^^^

temp_compile.dfy(15,50): Error: type char does not have a member ToLower
   |
15 |             (s[j].IsUpper() ==> result[j] == s[j].ToLower()) &&
   |                                              ^^^^^^^^^^^^

temp_compile.dfy(16,19): Error: type char does not have a member IsLower
   |
16 |             (!s[j].IsLower() && !s[j].IsUpper() ==> result[j] == s[j])
   |               ^^^^^^^^^^^^

temp_compile.dfy(16,38): Error: type char does not have a member IsUpper
   |
16 |             (!s[j].IsLower() && !s[j].IsUpper() ==> result[j] == s[j])
   |                                  ^^^^^^^^^^^^

temp_compile.dfy(20,13): Error: type char does not have a member IsLower
   |
20 |         if c.IsLower() {
   |            ^^^^^^^^^

temp_compile.dfy(21,34): Error: type char does not have a member ToUpper
   |
21 |             result := result + [c.ToUpper()];
   |                                 ^^^^^^^^^

temp_compile.dfy(22,20): Error: type char does not have a member IsUpper
   |
22 |         } else if c.IsUpper() {
   |                   ^^^^^^^^^

temp_compile.dfy(23,34): Error: type char does not have a member ToLower
   |
23 |             result := result + [c.ToLower()];
   |                                 ^^^^^^^^^

16 resolution/type errors detected in temp_compile.dfy

</compilation_error>

Please analyze the error and provide the COMPLETE Dafny code again with the fix applied. 
Do not provide just the missing pieces - provide the entire solution including any helper functions, the main method, and all specifications. 


=============== ASSISTANT ===============
--- THINKING ---
The error shows that Dafny's `char` type doesn't have `IsLower()`, `IsUpper()`, `ToUpper()`, and `ToLower()` methods. I need to implement these functions myself by checking the ASCII values of characters.

In ASCII:
- Lowercase letters 'a' to 'z' are in range 97-122
- Uppercase letters 'A' to 'Z' are in range 65-90
- To convert lowercase to uppercase: subtract 32
- To convert uppercase to lowercase: add 32

I need to create helper functions for these operations and use them in the main method.

--- RESPONSE ---
```dafny
function IsLowerCase(c: char): bool
{
    'a' <= c <= 'z'
}

function IsUpperCase(c: char): bool
{
    'A' <= c <= 'Z'
}

function ToUpperCase(c: char): char
    requires IsLowerCase(c)
{
    (c as int - 'a' as int + 'A' as int) as char
}

function ToLowerCase(c: char): char
    requires IsUpperCase(c)
{
    (c as int - 'A' as int + 'a' as int) as char
}

method flip_case(s: string) returns (result: string)
    ensures |result| == |s|
    ensures forall i :: 0 <= i < |s| ==> 
        (IsLowerCase(s[i]) ==> result[i] == ToUpperCase(s[i])) &&
        (IsUpperCase(s[i]) ==> result[i] == ToLowerCase(s[i])) &&
        (!IsLowerCase(s[i]) && !IsUpperCase(s[i]) ==> result[i] == s[i])
{
    result := "";
    var i := 0;
    while i < |s|
        invariant 0 <= i <= |s|
        invariant |result| == i
        invariant forall j :: 0 <= j < i ==> 
            (IsLowerCase(s[j]) ==> result[j] == ToUpperCase(s[j])) &&
            (IsUpperCase(s[j]) ==> result[j] == ToLowerCase(s[j])) &&
            (!IsLowerCase(s[j]) && !IsUpperCase(s[j]) ==> result[j] == s[j])
        decreases |s| - i
    {
        var c := s[i];
        if IsLowerCase(c) {
            result := result + [ToUpperCase(c)];
        } else if IsUpperCase(c) {
            result := result + [ToLowerCase(c)];
        } else {
            result := result + [c];
        }
        i := i + 1;
    }
}
```

