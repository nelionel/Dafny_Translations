=============== SYSTEM ===============
You are an expert programmer specializing in translating Python code to the Dafny verification language. Your task is to translate the provided Python function into a Dafny method that is both verifiable and compilable. Pay close attention to types, specifications, and providing concrete implementations for all methods.



=============== USER ===============
I will provide you with a Python function and its documentation. Please translate the Python function into a Dafny method.

**Python Function and Documentation:**
```python


def car_race_collision(n: int):
    """
    Imagine a road that's a perfectly straight infinitely long line.
    n cars are driving left to right;  simultaneously, a different set of n cars
    are driving right to left.   The two sets of cars start out being very far from
    each other.  All cars move in the same speed.  Two cars are said to collide
    when a car that's moving left to right hits a car that's moving right to left.
    However, the cars are infinitely sturdy and strong; as a result, they continue moving
    in their trajectory as if they did not collide.

    This function outputs the number of such collisions.
    """

def car_race_collision(n: int):
    """
    Imagine a road that's a perfectly straight infinitely long line.
    n cars are driving left to right;  simultaneously, a different set of n cars
    are driving right to left.   The two sets of cars start out being very far from
    each other.  All cars move in the same speed.  Two cars are said to collide
    when a car that's moving left to right hits a car that's moving right to left.
    However, the cars are infinitely sturdy and strong; as a result, they continue moving
    in their trajectory as if they did not collide.

    This function outputs the number of such collisions.
    """
    return n * n
```

**Your Task:**
1.  **Reasoning (in a <thinking> block):**
    *   Analyze the Python code and its types. How will you map Python types (like lists of floats) to Dafny types (like `seq<real>`)?
    *   Analyze the function's logic. What are the pre-conditions (`requires`) and post-conditions (`ensures`)?
    *   Identify any loops and determine their invariants.
    *   Think about termination conditions for any recursive calls or loops.
2.  **Dafny Implementation (in a ```dafny ... ``` block):**
    *   Write the complete Dafny method, including its signature, `requires` clauses, `ensures` clauses, and the method body.
    *   **The return type of the main method must be a basic Dafny type.** Use `int`, `real`, `bool`, `string`, or a sequence of these types (e.g., `seq<int>`). Do not use custom `datatype`s in the return signature. If the Python code implies an optional return (e.g. returning `None`), you should return a sensible default for the basic type instead (e.g. `false`, `-1`, or an empty sequence `[]`).
    *   The Dafny method name must be exactly the same as the Python function name: `car_race_collision`. Do not change the casing.
    *   **All methods must have a concrete implementation (a body).** The `{:axiom}` attribute is forbidden for defining standard functions. However, if the problem's solution relies on an unproven mathematical conjecture (e.g., the Goldbach Conjecture, P vs NP), you may state the conjecture as an `axiom`. If you do so, you **must** include a comment identifying the conjecture (e.g., `// Axiom for the Twin Prime Conjecture`). Do not use axioms to avoid implementing solvable algorithms.
    *   **Provide explicit termination proofs.** For any recursive function, you must include a `decreases` clause. Do **not** use `decreases *`. For functions that operate on a sequence, the termination metric is almost always the length of the sequence (e.g., `decreases my_sequence`). For functions on integers, it is the integer itself (e.g., `decreases n`).
    *   **Do not use Dafny reserved keywords as variable names.** Avoid names like: `abstract, allocated, as, assert, assume, bool, break, by, calc, case, char, class, codatatype, const, constructor, datatype, decreases, else, ensures, exists, export, extends, false, forall, fresh, function, ghost, if, imap, import, in, include, int, invariant, is, iset, iterator, label, lemma, map, match, method, modifies, modify, module, multiset, nameonly, nat, new, newtype, null, object, object?, old, opened, ORDINAL, predicate, print, provides,reads, real, refines, requires, return, returns, reveal, reveals, seq, set, static, string, then, this, trait, true, twostate, type, unchanged, var, while, witness, yield, yields`. For example, instead of `var array`, use `var arr`.



=============== ASSISTANT ===============
--- THINKING ---
Let me analyze this Python function:

1. The function `car_race_collision(n: int)` takes an integer `n` and returns `n * n`.

2. The problem description is about n cars driving left to right and n cars driving right to left. Each car from one set will collide with each car from the other set, so there will be n * n collisions total.

3. This is a very simple function - it just returns n squared.

For the Dafny translation:
- Input: `n: int`
- Output: `int` (n * n)
- Pre-conditions: We should probably require `n >= 0` since having negative cars doesn't make sense
- Post-conditions: The result should be `n * n`
- No loops or recursion, so no invariants or decreases clauses needed

The logic is straightforward - just multiply n by itself.

--- RESPONSE ---

--- THINKING ---
Looking at this Python function:

```python
def car_race_collision(n: int):
    return n * n
```

The function is very simple - it takes an integer `n` representing the number of cars in each direction, and returns `n * n` which is the total number of collisions.

The reasoning is: if there are `n` cars going left-to-right and `n` cars going right-to-left, then each car from the first set will collide with each car from the second set, giving us `n * n` total collisions.

For the Dafny translation:
1. **Types**: `int` in Python maps directly to `int` in Dafny
2. **Pre-conditions**: We should require `n >= 0` since negative number of cars doesn't make sense
3. **Post-conditions**: The result should equal `n * n`
4. **No loops or recursion**: This is a simple arithmetic operation, so no invariants or decreases clauses needed

The implementation is straightforward - just return `n * n`.

--- RESPONSE ---
<thinking>
Let me analyze this Python function:

1. **Function Analysis**: The function `car_race_collision(n: int)` takes an integer `n` and returns `n * n`. The logic is that if there are `n` cars moving left-to-right and `n` cars moving right-to-left, each car from one set will collide with each car from the other set, resulting in `n * n` total collisions.

2. **Type Mapping**: The Python `int` type maps directly to Dafny's `int` type.

3. **Pre-conditions**: Since we're talking about a number of cars, `n` should be non-negative (`n >= 0`).

4. **Post-conditions**: The result should be exactly `n * n`.

5. **Logic**: This is a simple arithmetic operation with no loops or recursion, so no invariants or termination proofs are needed.

6. **Implementation**: Just return `n * n`.
</thinking>

```dafny
method car_race_collision(n: int) returns (result: int)
    requires n >= 0
    ensures result == n * n
{
    result := n * n;
}
```

