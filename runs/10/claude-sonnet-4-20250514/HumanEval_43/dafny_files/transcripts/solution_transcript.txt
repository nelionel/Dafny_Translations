=============== SYSTEM ===============
You are an expert programmer specializing in translating Python code to the Dafny verification language. Your task is to translate the provided Python function into a Dafny method that is both verifiable and compilable. Pay close attention to types, specifications, and providing concrete implementations for all methods.



=============== USER ===============
I will provide you with a Python function and its documentation. Please translate the Python function into a Dafny method.

**Python Function and Documentation:**
```python


def pairs_sum_to_zero(l):
    """
    pairs_sum_to_zero takes a list of integers as an input.
    it returns True if there are two distinct elements in the list that
    sum to zero, and False otherwise.
    >>> pairs_sum_to_zero([1, 3, 5, 0])
    False
    >>> pairs_sum_to_zero([1, 3, -2, 1])
    False
    >>> pairs_sum_to_zero([1, 2, 3, 7])
    False
    >>> pairs_sum_to_zero([2, 4, -5, 3, 5, 7])
    True
    >>> pairs_sum_to_zero([1])
    False
    """

def pairs_sum_to_zero(l):
    """
    pairs_sum_to_zero takes a list of integers as an input.
    it returns True if there are two distinct elements in the list that
    sum to zero, and False otherwise.
    >>> pairs_sum_to_zero([1, 3, 5, 0])
    False
    >>> pairs_sum_to_zero([1, 3, -2, 1])
    False
    >>> pairs_sum_to_zero([1, 2, 3, 7])
    False
    >>> pairs_sum_to_zero([2, 4, -5, 3, 5, 7])
    True
    >>> pairs_sum_to_zero([1])
    False
    """
    seen = set()
    
    for num in l:
        # Check if the negative of current number exists in seen set
        if -num in seen:
            return True
        # Add current number to seen set
        seen.add(num)
    
    return False
```

**Your Task:**
1.  **Reasoning (in a <thinking> block):**
    *   Analyze the Python code and its types. How will you map Python types (like lists of floats) to Dafny types (like `seq<real>`)?
    *   Analyze the function's logic. What are the pre-conditions (`requires`) and post-conditions (`ensures`)?
    *   Identify any loops and determine their invariants.
    *   Think about termination conditions for any recursive calls or loops.
2.  **Dafny Implementation (in a ```dafny ... ``` block):**
    *   Write the complete Dafny method, including its signature, `requires` clauses, `ensures` clauses, and the method body.
    *   **The return type of the main method must be a basic Dafny type.** Use `int`, `real`, `bool`, `string`, or a sequence of these types (e.g., `seq<int>`). Do not use custom `datatype`s in the return signature. If the Python code implies an optional return (e.g. returning `None`), you should return a sensible default for the basic type instead (e.g. `false`, `-1`, or an empty sequence `[]`).
    *   The Dafny method name must be exactly the same as the Python function name: `pairs_sum_to_zero`. Do not change the casing.
    *   **All methods must have a concrete implementation (a body).** The `{:axiom}` attribute is forbidden for defining standard functions. However, if the problem's solution relies on an unproven mathematical conjecture (e.g., the Goldbach Conjecture, P vs NP), you may state the conjecture as an `axiom`. If you do so, you **must** include a comment identifying the conjecture (e.g., `// Axiom for the Twin Prime Conjecture`). Do not use axioms to avoid implementing solvable algorithms.
    *   **Provide explicit termination proofs.** For any recursive function, you must include a `decreases` clause. Do **not** use `decreases *`. For functions that operate on a sequence, the termination metric is almost always the length of the sequence (e.g., `decreases my_sequence`). For functions on integers, it is the integer itself (e.g., `decreases n`).
    *   **Do not use Dafny reserved keywords as variable names.** Avoid names like: `abstract, allocated, as, assert, assume, bool, break, by, calc, case, char, class, codatatype, const, constructor, datatype, decreases, else, ensures, exists, export, extends, false, forall, fresh, function, ghost, if, imap, import, in, include, int, invariant, is, iset, iterator, label, lemma, map, match, method, modifies, modify, module, multiset, nameonly, nat, new, newtype, null, object, object?, old, opened, ORDINAL, predicate, print, provides,reads, real, refines, requires, return, returns, reveal, reveals, seq, set, static, string, then, this, trait, true, twostate, type, unchanged, var, while, witness, yield, yields`. For example, instead of `var array`, use `var arr`.



=============== ASSISTANT ===============
--- THINKING ---
Let me analyze the Python function:
1. It takes a list of integers as input
2. It checks if there are two distinct elements that sum to zero
3. It uses a set to track seen numbers
4. For each number, it checks if its negative is already in the seen set
5. If yes, returns True; otherwise, adds the current number to the set
6. If loop completes without finding a pair, returns False

For Dafny:
- Input type: `seq<int>` (sequence of integers)
- Return type: `bool`
- The algorithm is iterative, so I'll need a loop with invariants

Pre-conditions:
- No specific requirements on the input sequence

Post-conditions:
- Returns true if and only if there exist two distinct indices i, j such that l[i] + l[j] == 0 and i != j

Loop invariants:
- The seen set contains all elements processed so far
- If we haven't returned True yet, then no pair summing to zero has been found among processed elements

I need to simulate the set behavior in Dafny. I can use a sequence to track seen elements, but checking membership will require a helper function or predicate.

Let me think about the implementation:
1. I'll use a sequence to simulate the set
2. I'll need a helper function to check if an element is in the sequence
3. The main loop will iterate through the input sequence
4. For each element, check if its negative is in the seen sequence
5. If found, return true; otherwise, add to seen sequence

Actually, let me be more careful about the loop invariants and the specification.

--- RESPONSE ---
<thinking>
Looking at the Python code:
1. It takes a list of integers and returns a boolean
2. It uses a set to track seen numbers and checks if the negative of the current number exists
3. Returns True if two distinct elements sum to zero, False otherwise

For Dafny translation:
- Input: `seq<int>` (sequence of integers)  
- Return: `bool`
- Need to simulate the set behavior using a sequence and membership checking
- The algorithm is iterative, so I need loop invariants

The post-condition should specify that the method returns true if and only if there exist two distinct indices i, j such that the elements at those positions sum to zero.

For the loop:
- Invariant: the seen sequence contains all processed elements so far
- Invariant: if no pair has been found yet, then no two elements from the processed portion sum to zero
- Termination: the loop processes one element per iteration, so it decreases the remaining elements
</thinking>

```dafny
predicate Contains(s: seq<int>, x: int)
{
    exists i :: 0 <= i < |s| && s[i] == x
}

method pairs_sum_to_zero(l: seq<int>) returns (result: bool)
    ensures result <==> (exists i, j :: 0 <= i < |l| && 0 <= j < |l| && i != j && l[i] + l[j] == 0)
{
    var seen: seq<int> := [];
    var index := 0;
    
    while index < |l|
        invariant 0 <= index <= |l|
        invariant |seen| == index
        invariant forall k :: 0 <= k < index ==> seen[k] == l[k]
        invariant forall i, j :: 0 <= i < index && 0 <= j < index && i != j ==> l[i] + l[j] != 0
        decreases |l| - index
    {
        var num := l[index];
        
        if Contains(seen, -num) {
            return true;
        }
        
        seen := seen + [num];
        index := index + 1;
    }
    
    return false;
}
```

