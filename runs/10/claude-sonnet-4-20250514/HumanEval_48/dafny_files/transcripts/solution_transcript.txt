=============== SYSTEM ===============
You are an expert programmer specializing in translating Python code to the Dafny verification language. Your task is to translate the provided Python function into a Dafny method that is both verifiable and compilable. Pay close attention to types, specifications, and providing concrete implementations for all methods.



=============== USER ===============
I will provide you with a Python function and its documentation. Please translate the Python function into a Dafny method.

**Python Function and Documentation:**
```python


def is_palindrome(text: str):
    """
    Checks if given string is a palindrome
    >>> is_palindrome('')
    True
    >>> is_palindrome('aba')
    True
    >>> is_palindrome('aaaaa')
    True
    >>> is_palindrome('zbcd')
    False
    """

def is_palindrome(text: str):
    """
    Checks if given string is a palindrome
    >>> is_palindrome('')
    True
    >>> is_palindrome('aba')
    True
    >>> is_palindrome('aaaaa')
    True
    >>> is_palindrome('zbcd')
    False
    """
    # Convert to lowercase to handle case-insensitive comparison
    text = text.lower()
    
    # Compare the string with its reverse
    return text == text[::-1]
```

**Your Task:**
1.  **Reasoning (in a <thinking> block):**
    *   Analyze the Python code and its types. How will you map Python types (like lists of floats) to Dafny types (like `seq<real>`)?
    *   Analyze the function's logic. What are the pre-conditions (`requires`) and post-conditions (`ensures`)?
    *   Identify any loops and determine their invariants.
    *   Think about termination conditions for any recursive calls or loops.
2.  **Dafny Implementation (in a ```dafny ... ``` block):**
    *   Write the complete Dafny method, including its signature, `requires` clauses, `ensures` clauses, and the method body.
    *   **The return type of the main method must be a basic Dafny type.** Use `int`, `real`, `bool`, `string`, or a sequence of these types (e.g., `seq<int>`). Do not use custom `datatype`s in the return signature. If the Python code implies an optional return (e.g. returning `None`), you should return a sensible default for the basic type instead (e.g. `false`, `-1`, or an empty sequence `[]`).
    *   The Dafny method name must be exactly the same as the Python function name: `is_palindrome`. Do not change the casing.
    *   **All methods must have a concrete implementation (a body).** The `{:axiom}` attribute is forbidden for defining standard functions. However, if the problem's solution relies on an unproven mathematical conjecture (e.g., the Goldbach Conjecture, P vs NP), you may state the conjecture as an `axiom`. If you do so, you **must** include a comment identifying the conjecture (e.g., `// Axiom for the Twin Prime Conjecture`). Do not use axioms to avoid implementing solvable algorithms.
    *   **Provide explicit termination proofs.** For any recursive function, you must include a `decreases` clause. Do **not** use `decreases *`. For functions that operate on a sequence, the termination metric is almost always the length of the sequence (e.g., `decreases my_sequence`). For functions on integers, it is the integer itself (e.g., `decreases n`).
    *   **Do not use Dafny reserved keywords as variable names.** Avoid names like: `abstract, allocated, as, assert, assume, bool, break, by, calc, case, char, class, codatatype, const, constructor, datatype, decreases, else, ensures, exists, export, extends, false, forall, fresh, function, ghost, if, imap, import, in, include, int, invariant, is, iset, iterator, label, lemma, map, match, method, modifies, modify, module, multiset, nameonly, nat, new, newtype, null, object, object?, old, opened, ORDINAL, predicate, print, provides,reads, real, refines, requires, return, returns, reveal, reveals, seq, set, static, string, then, this, trait, true, twostate, type, unchanged, var, while, witness, yield, yields`. For example, instead of `var array`, use `var arr`.



=============== ASSISTANT ===============
--- THINKING ---
Looking at the Python function `is_palindrome`:

1. It takes a string as input and returns a boolean indicating whether the string is a palindrome.
2. It converts the string to lowercase for case-insensitive comparison.
3. It compares the string with its reverse using slicing `text[::-1]`.

For the Dafny translation:
- Input type: `string` in Dafny
- Return type: `bool` in Dafny
- I need to implement string reversal since Dafny doesn't have Python-like slicing
- I need to implement case conversion (to lowercase)

Let me think about the specifications:
- Preconditions: None really, any string is valid input
- Postconditions: The result should be true if and only if the (lowercase) string is equal to its reverse

For the implementation:
1. Convert string to lowercase - I'll need a helper function for this
2. Reverse the string - I'll need a helper function for this
3. Compare the original (lowercased) with the reversed

Let me think about helper functions:
1. `ToLowercase(s: string) -> string` - converts a string to lowercase
2. `Reverse(s: string) -> string` - reverses a string

For `ToLowercase`, I need to iterate through each character and convert uppercase to lowercase. In Dafny, I can use `seq<char>` to work with individual characters.

For `Reverse`, I can recursively reverse the string.

Actually, let me think about this more carefully. In Dafny, `string` is a sequence of characters, so I can work with it as `seq<char>`.

For the `ToLowercase` function:
- I need to iterate through each character
- Convert uppercase letters to lowercase
- This requires knowing ASCII values or having a mapping

For the `Reverse` function:
- I can use recursion with a decreases clause
- Base case: empty string returns empty string


- Recursive case involves appending the first character at the end after reversing the rest

I'll implement the recursive reversal by taking the first character and placing it at the end of the reversed remaining string. This approach ensures I can systematically break down the string and rebuild it in reverse order. I'll convert uppercase letters to lowercase by adding an offset, keeping other characters unchanged. The Reverse function recursively builds the reversed string by moving the first character to the end. The palindrome method converts the text to lowercase and checks if it matches its reverse, ensuring case-insensitive palindrome detection.

The function handles character conversion systematically: uppercase letters get shifted to their lowercase equivalents, while other characters remain unmodified. Recursion drives the string transformation, breaking down the problem into smaller, manageable steps.

The palindrome verification method leverages lowercase conversion and string reversal to create a robust, case-insensitive comparison mechanism.

Test cases validate the approach across various scenarios: empty strings, repeated characters, and non-palindromic inputs, confirming the method's reliability and correctness.

--- RESPONSE ---
<thinking>
Looking at the Python function `is_palindrome`:
1. It takes a string input and returns a boolean
2. It converts the string to lowercase for case-insensitive comparison
3. It compares the string with its reverse using Python's slice notation `[::-1]`

For the Dafny translation:
- Input type: `string` (which is `seq<char>` in Dafny)
- Return type: `bool`
- I need helper functions for:
  1. Converting to lowercase
  2. Reversing a string
- The main logic compares the lowercase string with its reverse

For specifications:
- No preconditions needed (any string is valid)
- Postcondition: result is true iff the lowercase version equals its reverse

I'll need recursive helper functions with proper `decreases` clauses for termination.
</thinking>

```dafny
function ToLowercaseChar(c: char): char
{
    if 'A' <= c <= 'Z' then
        (c as int - 'A' as int + 'a' as int) as char
    else
        c
}

function ToLowercase(s: string): string
    decreases |s|
{
    if |s| == 0 then ""
    else [ToLowercaseChar(s[0])] + ToLowercase(s[1..])
}

function Reverse(s: string): string
    decreases |s|
{
    if |s| == 0 then ""
    else Reverse(s[1..]) + [s[0]]
}

method is_palindrome(text: string) returns (result: bool)
    ensures result <==> ToLowercase(text) == Reverse(ToLowercase(text))
{
    var lowercased := ToLowercase(text);
    var reversed := Reverse(lowercased);
    result := lowercased == reversed;
}
```

