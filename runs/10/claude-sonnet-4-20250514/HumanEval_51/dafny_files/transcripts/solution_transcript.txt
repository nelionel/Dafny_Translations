=============== SYSTEM ===============
You are an expert programmer specializing in translating Python code to the Dafny verification language. Your task is to translate the provided Python function into a Dafny method that is both verifiable and compilable. Pay close attention to types, specifications, and providing concrete implementations for all methods.



=============== USER ===============
I will provide you with a Python function and its documentation. Please translate the Python function into a Dafny method.

**Python Function and Documentation:**
```python


def remove_vowels(text):
    """
    remove_vowels is a function that takes string and returns string without vowels.
    >>> remove_vowels('')
    ''
    >>> remove_vowels("abcdef\nghijklm")
    'bcdf\nghjklm'
    >>> remove_vowels('abcdef')
    'bcdf'
    >>> remove_vowels('aaaaa')
    ''
    >>> remove_vowels('aaBAA')
    'B'
    >>> remove_vowels('zbcd')
    'zbcd'
    """

def remove_vowels(text):
    """
    remove_vowels is a function that takes string and returns string without vowels.
    >>> remove_vowels('')
    ''
    >>> remove_vowels("abcdef\nghijklm")
    'bcdf\nghjklm'
    >>> remove_vowels('abcdef')
    'bcdf'
    >>> remove_vowels('aaaaa')
    ''
    >>> remove_vowels('aaBAA')
    'B'
    >>> remove_vowels('zbcd')
    'zbcd'
    """
    vowels = "aeiouAEIOU"
    result = ""
    
    for char in text:
        if char not in vowels:
            result += char
    
    return result
```

**Your Task:**
1.  **Reasoning (in a <thinking> block):**
    *   Analyze the Python code and its types. How will you map Python types (like lists of floats) to Dafny types (like `seq<real>`)?
    *   Analyze the function's logic. What are the pre-conditions (`requires`) and post-conditions (`ensures`)?
    *   Identify any loops and determine their invariants.
    *   Think about termination conditions for any recursive calls or loops.
2.  **Dafny Implementation (in a ```dafny ... ``` block):**
    *   Write the complete Dafny method, including its signature, `requires` clauses, `ensures` clauses, and the method body.
    *   **The return type of the main method must be a basic Dafny type.** Use `int`, `real`, `bool`, `string`, or a sequence of these types (e.g., `seq<int>`). Do not use custom `datatype`s in the return signature. If the Python code implies an optional return (e.g. returning `None`), you should return a sensible default for the basic type instead (e.g. `false`, `-1`, or an empty sequence `[]`).
    *   The Dafny method name must be exactly the same as the Python function name: `remove_vowels`. Do not change the casing.
    *   **All methods must have a concrete implementation (a body).** The `{:axiom}` attribute is forbidden for defining standard functions. However, if the problem's solution relies on an unproven mathematical conjecture (e.g., the Goldbach Conjecture, P vs NP), you may state the conjecture as an `axiom`. If you do so, you **must** include a comment identifying the conjecture (e.g., `// Axiom for the Twin Prime Conjecture`). Do not use axioms to avoid implementing solvable algorithms.
    *   **Provide explicit termination proofs.** For any recursive function, you must include a `decreases` clause. Do **not** use `decreases *`. For functions that operate on a sequence, the termination metric is almost always the length of the sequence (e.g., `decreases my_sequence`). For functions on integers, it is the integer itself (e.g., `decreases n`).
    *   **Do not use Dafny reserved keywords as variable names.** Avoid names like: `abstract, allocated, as, assert, assume, bool, break, by, calc, case, char, class, codatatype, const, constructor, datatype, decreases, else, ensures, exists, export, extends, false, forall, fresh, function, ghost, if, imap, import, in, include, int, invariant, is, iset, iterator, label, lemma, map, match, method, modifies, modify, module, multiset, nameonly, nat, new, newtype, null, object, object?, old, opened, ORDINAL, predicate, print, provides,reads, real, refines, requires, return, returns, reveal, reveals, seq, set, static, string, then, this, trait, true, twostate, type, unchanged, var, while, witness, yield, yields`. For example, instead of `var array`, use `var arr`.



=============== ASSISTANT ===============
--- THINKING ---
Let me analyze the Python function:

1. **Function signature and types:**
   - Input: `text` (string)
   - Output: string (without vowels)
   - In Dafny: `method remove_vowels(text: string) returns (result: string)`

2. **Logic analysis:**
   - The function iterates through each character in the input string
   - It checks if the character is a vowel (both lowercase and uppercase: "aeiouAEIOU")
   - If the character is not a vowel, it adds it to the result string
   - Returns the result string

3. **Pre-conditions and post-conditions:**
   - Pre-conditions: None really needed, any string is valid input
   - Post-conditions: 
     - The result should contain no vowels
     - The result should preserve the order of non-vowel characters from the input
     - The length of result should be <= length of input

4. **Loop invariants:**
   - The result so far contains no vowels
   - The result contains all non-vowel characters from text[0..i-1] in the same order
   - The result length is <= i

5. **Termination:**
   - The for loop will terminate because it iterates through a finite string
   - In Dafny, I'll use a while loop with an index, so the decreases clause will be the remaining characters to process

Let me implement this:

```dafny
method remove_vowels(text: string) returns (result: string)
    ensures forall i :: 0 <= i < |result| ==> result[i] !in "aeiouAEIOU"
    ensures |result| <= |text|
{
    var vowels := "aeiouAEIOU";
    result := "";
    var i := 0;
    
    while i < |text|
        invariant 0 <= i <= |text|
        invariant forall j :: 0 <= j < |result| ==> result[j] !in vowels
        invariant |result| <= i
        decreases |text| - i
    {
        if text[i] !in vowels {
            result := result + [text[i]];
        }
        i := i + 1;
    }
}
```

I'll carefully examine the string manipulation approach. Dafny treats strings as sequences of characters, so I need to ensure proper concatenation. The method uses a character-by-character approach, adding non-vowel characters to the result sequence. The loop invariants guarantee no vowels and maintain the original character order. I'll append the character to the result, creating a new string without vowels efficiently.

--- RESPONSE ---
<thinking>
Let me analyze the Python function:

1. **Function signature and types:**
   - Input: `text` (string)
   - Output: string (without vowels)
   - In Dafny: `method remove_vowels(text: string) returns (result: string)`

2. **Logic analysis:**
   - The function iterates through each character in the input string
   - It checks if the character is a vowel (both lowercase and uppercase: "aeiouAEIOU")
   - If the character is not a vowel, it adds it to the result string
   - Returns the result string

3. **Pre-conditions and post-conditions:**
   - Pre-conditions: None needed, any string is valid input
   - Post-conditions: 
     - The result should contain no vowels
     - The result should preserve the order of non-vowel characters from the input
     - The length of result should be <= length of input

4. **Loop invariants:**
   - The result so far contains no vowels
   - The result contains all non-vowel characters from text[0..i-1] in the same order
   - The result length is <= current index i

5. **Termination:**
   - The loop will terminate because it iterates through a finite string
   - I'll use a while loop with an index, so the decreases clause will be the remaining characters to process
</thinking>

```dafny
method remove_vowels(text: string) returns (result: string)
    ensures forall i :: 0 <= i < |result| ==> result[i] !in "aeiouAEIOU"
    ensures |result| <= |text|
{
    var vowels := "aeiouAEIOU";
    result := "";
    var i := 0;
    
    while i < |text|
        invariant 0 <= i <= |text|
        invariant forall j :: 0 <= j < |result| ==> result[j] !in vowels
        invariant |result| <= i
        decreases |text| - i
    {
        if text[i] !in vowels {
            result := result + [text[i]];
        }
        i := i + 1;
    }
}
```

