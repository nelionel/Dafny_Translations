=============== SYSTEM ===============
You are an expert in formal verification and Dafny specifications. Your task is to analyze whether Dafny method specifications properly describe the behavior of the corresponding Python function.

You will be given:
1. A Python function with its behavior
2. A Dafny method translation with specifications (requires, ensures clauses)

Your job is to determine if the Dafny specifications fully and accurately capture the Python function's behavior. If not, you should improve the specifications.

IMPORTANT: You must respond with EXACTLY one of these phrases:
- "THE SCRIPT HAS PROPER SPECS" - if the specifications correctly describe the function
- "THE SCRIPT HAD NOT A PROPER SPEC" - if the specifications need improvement

After this phrase, provide the complete Dafny code (either unchanged or with improved specifications).



=============== USER ===============
Please analyze whether the Dafny specifications properly describe the Python function behavior.

**Python Function:**
```python
def fib(n: int):
    """Return n-th Fibonacci number.
    >>> fib(10)
    55
    >>> fib(1)
    1
    >>> fib(8)
    21
    """
    if n <= 0:
        raise ValueError("n must be a positive integer")
    
    if n == 1 or n == 2:
        return 1
    
    a, b = 1, 1
    for i in range(3, n + 1):
        a, b = b, a + b
    
    return b
```

**Current Dafny Code:**
```dafny
function fibSpec(n: int): int
  requires n > 0
  decreases n
{
  if n == 1 || n == 2 then 1
  else fibSpec(n-1) + fibSpec(n-2)
}

method fib(n: int) returns (result: int)
  requires n > 0
  ensures result == fibSpec(n)
{
  if n == 1 || n == 2 {
    return 1;
  }
  
  var a := 1;
  var b := 1;
  var i := 3;
  
  while i <= n
    invariant 3 <= i <= n + 1
    invariant a == fibSpec(i-2)
    invariant b == fibSpec(i-1)
  {
    var temp := a + b;
    a := b;
    b := temp;
    i := i + 1;
  }
  
  return b;
}
```

**Analysis Task:**
1. Compare the Python function's behavior with the Dafny specifications
2. Check if the `requires` clauses capture all preconditions
3. Check if the `ensures` clauses capture all postconditions and behavior
4. Verify that the specifications fully describe what the function does

**Response Format:**
Start with exactly one of these phrases:
- "THE SCRIPT HAS PROPER SPECS" (if specifications are adequate)
- "THE SCRIPT HAD NOT A PROPER SPEC" (if specifications need improvement)

Then provide the complete Dafny code. If improving specifications:
- Add missing `requires` clauses for preconditions
- Add missing `ensures` clauses for postconditions
- Ensure specifications capture the function's complete behavior
- Preserve the existing method implementation unchanged

 


=============== ASSISTANT ===============
--- THINKING ---
Let me analyze the Python function behavior and compare it with the Dafny specifications:

**Python function behavior:**
1. If `n <= 0`, it raises a ValueError (not a valid Fibonacci number)
2. If `n == 1` or `n == 2`, it returns 1
3. For `n > 2`, it computes the Fibonacci number iteratively

**Dafny specifications:**
1. `requires n > 0` - this matches the Python precondition since the Python function raises an error for `n <= 0`
2. `ensures result == fibSpec(n)` - this ensures the result matches the mathematical definition of Fibonacci numbers
3. The `fibSpec` function correctly defines the mathematical Fibonacci sequence where `fib(1) = 1`, `fib(2) = 1`, and `fib(n) = fib(n-1) + fib(n-2)` for `n > 2`

Let me check if this is correct:
- Python: fib(1) = 1, fib(2) = 1 ✓
- Dafny: fibSpec(1) = 1, fibSpec(2) = 1 ✓
- Python: for n > 2, uses iterative approach that computes the same sequence ✓
- Dafny: fibSpec(n) = fibSpec(n-1) + fibSpec(n-2) for n > 2 ✓

The loop invariants in the Dafny method look correct:
- `invariant 3 <= i <= n + 1` - bounds for the loop variable
- `invariant a == fibSpec(i-2)` - maintains that `a` is the (i-2)th Fibonacci number
- `invariant b == fibSpec(i-1)` - maintains that `b` is the (i-1)th Fibonacci number

These invariants should be sufficient to prove that when the loop exits (i.e., when `i > n`), `b == fibSpec(n)`.
 
The specifications precisely capture the function's input validation and expected output. By requiring a positive integer and ensuring the mathematically correct Fibonacci number is returned, the Dafny specification effectively mirrors the Python implementation's core logic and constraints.

--- RESPONSE ---
THE SCRIPT HAS PROPER SPECS

```dafny
function fibSpec(n: int): int
  requires n > 0
  decreases n
{
  if n == 1 || n == 2 then 1
  else fibSpec(n-1) + fibSpec(n-2)
}

method fib(n: int) returns (result: int)
  requires n > 0
  ensures result == fibSpec(n)
{
  if n == 1 || n == 2 {
    return 1;
  }
  
  var a := 1;
  var b := 1;
  var i := 3;
  
  while i <= n
    invariant 3 <= i <= n + 1
    invariant a == fibSpec(i-2)
    invariant b == fibSpec(i-1)
  {
    var temp := a + b;
    a := b;
    b := temp;
    i := i + 1;
  }
  
  return b;
}
```

