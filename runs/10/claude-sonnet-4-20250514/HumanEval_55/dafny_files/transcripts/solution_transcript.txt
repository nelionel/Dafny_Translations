=============== SYSTEM ===============
You are an expert programmer specializing in translating Python code to the Dafny verification language. Your task is to translate the provided Python function into a Dafny method that is both verifiable and compilable. Pay close attention to types, specifications, and providing concrete implementations for all methods.



=============== USER ===============
I will provide you with a Python function and its documentation. Please translate the Python function into a Dafny method.

**Python Function and Documentation:**
```python


def fib(n: int):
    """Return n-th Fibonacci number.
    >>> fib(10)
    55
    >>> fib(1)
    1
    >>> fib(8)
    21
    """

def fib(n: int):
    """Return n-th Fibonacci number.
    >>> fib(10)
    55
    >>> fib(1)
    1
    >>> fib(8)
    21
    """
    if n <= 0:
        raise ValueError("n must be a positive integer")
    
    if n == 1 or n == 2:
        return 1
    
    a, b = 1, 1
    for i in range(3, n + 1):
        a, b = b, a + b
    
    return b
```

**Your Task:**
1.  **Reasoning (in a <thinking> block):**
    *   Analyze the Python code and its types. How will you map Python types (like lists of floats) to Dafny types (like `seq<real>`)?
    *   Analyze the function's logic. What are the pre-conditions (`requires`) and post-conditions (`ensures`)?
    *   Identify any loops and determine their invariants.
    *   Think about termination conditions for any recursive calls or loops.
2.  **Dafny Implementation (in a ```dafny ... ``` block):**
    *   Write the complete Dafny method, including its signature, `requires` clauses, `ensures` clauses, and the method body.
    *   **The return type of the main method must be a basic Dafny type.** Use `int`, `real`, `bool`, `string`, or a sequence of these types (e.g., `seq<int>`). Do not use custom `datatype`s in the return signature. If the Python code implies an optional return (e.g. returning `None`), you should return a sensible default for the basic type instead (e.g. `false`, `-1`, or an empty sequence `[]`).
    *   The Dafny method name must be exactly the same as the Python function name: `fib`. Do not change the casing.
    *   **All methods must have a concrete implementation (a body).** The `{:axiom}` attribute is forbidden for defining standard functions. However, if the problem's solution relies on an unproven mathematical conjecture (e.g., the Goldbach Conjecture, P vs NP), you may state the conjecture as an `axiom`. If you do so, you **must** include a comment identifying the conjecture (e.g., `// Axiom for the Twin Prime Conjecture`). Do not use axioms to avoid implementing solvable algorithms.
    *   **Provide explicit termination proofs.** For any recursive function, you must include a `decreases` clause. Do **not** use `decreases *`. For functions that operate on a sequence, the termination metric is almost always the length of the sequence (e.g., `decreases my_sequence`). For functions on integers, it is the integer itself (e.g., `decreases n`).
    *   **Do not use Dafny reserved keywords as variable names.** Avoid names like: `abstract, allocated, as, assert, assume, bool, break, by, calc, case, char, class, codatatype, const, constructor, datatype, decreases, else, ensures, exists, export, extends, false, forall, fresh, function, ghost, if, imap, import, in, include, int, invariant, is, iset, iterator, label, lemma, map, match, method, modifies, modify, module, multiset, nameonly, nat, new, newtype, null, object, object?, old, opened, ORDINAL, predicate, print, provides,reads, real, refines, requires, return, returns, reveal, reveals, seq, set, static, string, then, this, trait, true, twostate, type, unchanged, var, while, witness, yield, yields`. For example, instead of `var array`, use `var arr`.



=============== ASSISTANT ===============
--- THINKING ---
Let me analyze this Python function:

1. The function calculates the n-th Fibonacci number
2. It raises a ValueError if n <= 0, so the precondition should be n > 0
3. For n == 1 or n == 2, it returns 1
4. For n > 2, it uses an iterative approach with two variables a and b

Let me think about the Dafny translation:

1. **Types**: The input is `int` and the output is `int`, so that's straightforward.

2. **Preconditions**: `requires n > 0` (since the function raises ValueError for n <= 0)

3. **Postconditions**: I need to specify what the Fibonacci number should be. I can define it recursively:
   - fib(1) = 1
   - fib(2) = 1  
   - fib(n) = fib(n-1) + fib(n-2) for n > 2

4. **Loop invariants**: The loop runs from i = 3 to n+1. At each iteration:
   - a holds fib(i-2)
   - b holds fib(i-1)
   - After the iteration: a holds fib(i-1), b holds fib(i)

5. **Termination**: The loop has a clear bound, so termination is straightforward.

Let me define a recursive specification function first to help with the postcondition:

```dafny
function fibSpec(n: int): int
  requires n > 0
{
  if n == 1 || n == 2 then 1
  else fibSpec(n-1) + fibSpec(n-2)
}
```

Wait, I need to be careful about the decreases clause for the recursive function. Since we're calling fibSpec(n-1) and fibSpec(n-2), and both n-1 and n-2 are smaller than n (when n > 2), the decreases clause should be `decreases n`.


I'll continue working on the method implementation, focusing on the loop's core logic. The method needs to handle the iterative calculation of Fibonacci numbers, maintaining the correct state as it progresses through iterations. The key is to update the variables systematically to track the sequence correctly.

The temporary variable will help swap values, ensuring I can compute the next Fibonacci number while preserving the previous two values. This approach allows an efficient, linear-time calculation of the n-th Fibonacci number.

By tracking the index and maintaining two running variables, I can build the sequence incrementally until reaching the desired position. The loop invariants ensure that at each step, the variables represent the correct Fibonacci numbers for the current iteration.

As the loop progresses, the values of a and b shift, capturing the cumulative calculation of Fibonacci numbers. When the final iteration completes, the result is precisely the nth Fibonacci number.

--- RESPONSE ---
<thinking>
Let me analyze this Python function:

1. **Types**: The function takes an `int` parameter `n` and returns an `int` (the n-th Fibonacci number).

2. **Logic Analysis**: 
   - The function raises ValueError if n <= 0, so precondition should be `n > 0`
   - For n == 1 or n == 2, it returns 1
   - For n > 2, it uses iterative approach with two variables a, b starting at 1, 1
   - Loop runs from i = 3 to n (inclusive), updating a, b = b, a + b

3. **Specifications**:
   - Precondition: `requires n > 0` 
   - Postcondition: Should return the correct Fibonacci number
   - I'll need a specification function to define what the correct Fibonacci number is

4. **Loop invariants**: 
   - The loop variable i goes from 3 to n+1
   - At iteration i, a holds fib(i-2) and b holds fib(i-1)
   - After the loop body executes, a holds fib(i-1) and b holds fib(i)

5. **Termination**: The loop has clear bounds, no recursion in main method
</thinking>

```dafny
function fibSpec(n: int): int
  requires n > 0
  decreases n
{
  if n == 1 || n == 2 then 1
  else fibSpec(n-1) + fibSpec(n-2)
}

method fib(n: int) returns (result: int)
  requires n > 0
  ensures result == fibSpec(n)
{
  if n == 1 || n == 2 {
    return 1;
  }
  
  var a := 1;
  var b := 1;
  var i := 3;
  
  while i <= n
    invariant 3 <= i <= n + 1
    invariant a == fibSpec(i-2)
    invariant b == fibSpec(i-1)
  {
    var temp := a + b;
    a := b;
    b := temp;
    i := i + 1;
  }
  
  return b;
}
```

