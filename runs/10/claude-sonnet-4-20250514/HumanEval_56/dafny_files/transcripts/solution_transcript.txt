=============== SYSTEM ===============
You are an expert programmer specializing in translating Python code to the Dafny verification language. Your task is to translate the provided Python function into a Dafny method that is both verifiable and compilable. Pay close attention to types, specifications, and providing concrete implementations for all methods.



=============== USER ===============
I will provide you with a Python function and its documentation. Please translate the Python function into a Dafny method.

**Python Function and Documentation:**
```python


def correct_bracketing(brackets: str):
    """ brackets is a string of "<" and ">".
    return True if every opening bracket has a corresponding closing bracket.

    >>> correct_bracketing("<")
    False
    >>> correct_bracketing("<>")
    True
    >>> correct_bracketing("<<><>>")
    True
    >>> correct_bracketing("><<>")
    False
    """

def correct_bracketing(brackets: str):
    """ brackets is a string of "<" and ">".
    return True if every opening bracket has a corresponding closing bracket.

    >>> correct_bracketing("<")
    False
    >>> correct_bracketing("<>")
    True
    >>> correct_bracketing("<<><>>")
    True
    >>> correct_bracketing("><<>")
    False
    """
    counter = 0
    
    for bracket in brackets:
        if bracket == "<":
            counter += 1
        elif bracket == ">":
            counter -= 1
            # If counter goes negative, we have more closing than opening brackets
            if counter < 0:
                return False
    
    # All brackets are matched if counter is zero
    return counter == 0
```

**Your Task:**
1.  **Reasoning (in a <thinking> block):**
    *   Analyze the Python code and its types. How will you map Python types (like lists of floats) to Dafny types (like `seq<real>`)?
    *   Analyze the function's logic. What are the pre-conditions (`requires`) and post-conditions (`ensures`)?
    *   Identify any loops and determine their invariants.
    *   Think about termination conditions for any recursive calls or loops.
2.  **Dafny Implementation (in a ```dafny ... ``` block):**
    *   Write the complete Dafny method, including its signature, `requires` clauses, `ensures` clauses, and the method body.
    *   **The return type of the main method must be a basic Dafny type.** Use `int`, `real`, `bool`, `string`, or a sequence of these types (e.g., `seq<int>`). Do not use custom `datatype`s in the return signature. If the Python code implies an optional return (e.g. returning `None`), you should return a sensible default for the basic type instead (e.g. `false`, `-1`, or an empty sequence `[]`).
    *   The Dafny method name must be exactly the same as the Python function name: `correct_bracketing`. Do not change the casing.
    *   **All methods must have a concrete implementation (a body).** The `{:axiom}` attribute is forbidden for defining standard functions. However, if the problem's solution relies on an unproven mathematical conjecture (e.g., the Goldbach Conjecture, P vs NP), you may state the conjecture as an `axiom`. If you do so, you **must** include a comment identifying the conjecture (e.g., `// Axiom for the Twin Prime Conjecture`). Do not use axioms to avoid implementing solvable algorithms.
    *   **Provide explicit termination proofs.** For any recursive function, you must include a `decreases` clause. Do **not** use `decreases *`. For functions that operate on a sequence, the termination metric is almost always the length of the sequence (e.g., `decreases my_sequence`). For functions on integers, it is the integer itself (e.g., `decreases n`).
    *   **Do not use Dafny reserved keywords as variable names.** Avoid names like: `abstract, allocated, as, assert, assume, bool, break, by, calc, case, char, class, codatatype, const, constructor, datatype, decreases, else, ensures, exists, export, extends, false, forall, fresh, function, ghost, if, imap, import, in, include, int, invariant, is, iset, iterator, label, lemma, map, match, method, modifies, modify, module, multiset, nameonly, nat, new, newtype, null, object, object?, old, opened, ORDINAL, predicate, print, provides,reads, real, refines, requires, return, returns, reveal, reveals, seq, set, static, string, then, this, trait, true, twostate, type, unchanged, var, while, witness, yield, yields`. For example, instead of `var array`, use `var arr`.



=============== ASSISTANT ===============
--- THINKING ---
Let me analyze the Python code first:

1. The function `correct_bracketing` takes a string `brackets` containing only '<' and '>' characters.
2. It returns a bool - True if every opening bracket '<' has a corresponding closing bracket '>'.
3. The algorithm uses a counter approach:
   - For each '<', increment counter
   - For each '>', decrement counter
   - If counter goes negative at any point, return False (more closing than opening brackets so far)
   - At the end, return True if counter is 0 (all brackets matched)

For Dafny translation:
- Input: string (Dafny `string`)
- Output: bool (Dafny `bool`)
- The logic involves iterating through the string, so I need a loop
- Loop invariant: the counter represents the number of unmatched opening brackets seen so far, and it should never go negative during valid processing

Let me think about the specifications:
- Requires: The string should only contain '<' and '>' characters (though the original doesn't enforce this, I should consider it)
- Ensures: Returns true iff every opening bracket has a corresponding closing bracket

For the loop invariant:
- counter >= 0 (should never go negative during the loop if we haven't returned false)
- counter represents the number of unmatched opening brackets processed so far

The termination condition is straightforward - we iterate through each character in the string, so the loop will terminate when we've processed all characters.

Let me write the Dafny code:

```dafny
method correct_bracketing(brackets: string) returns (result: bool)
{
    var counter := 0;
    var i := 0;
    
    while i < |brackets|
        invariant 0 <= i <= |brackets|
        invariant counter >= 0
    {
        if brackets[i] == '<' {
            counter := counter + 1;
        } else if brackets[i] == '>' {
            counter := counter - 1;
            if counter < 0 {
                return false;
            }
        }
        i := i + 1;
    }
    
    return counter == 0;
}
```

I'll refine the specification to capture the precise bracket matching conditions. The key insight is tracking unmatched opening brackets throughout the string traversal. When a closing bracket appears, it must match a previous unmatched opening bracket. If at any point we have more closing brackets than opening brackets, the string is invalid. The final check ensures all opening brackets are matched by closing brackets.

The loop invariant captures the core logic: we maintain a running count of unmatched opening brackets, ensuring this count never goes negative. This elegantly handles the bracket matching problem with a simple counter approach.

--- RESPONSE ---
<thinking>
Let me analyze the Python code:

1. The function `correct_bracketing` takes a string containing only '<' and '>' characters
2. It returns a boolean - True if brackets are properly balanced
3. The algorithm uses a counter approach:
   - Increment counter for each '<'
   - Decrement counter for each '>'
   - If counter goes negative, return False immediately (more closing than opening brackets)
   - At the end, return True only if counter is 0 (all brackets matched)

For Dafny translation:
- Input: `string` (Dafny string type)
- Output: `bool` 
- Need a loop to iterate through characters
- Loop invariant: counter >= 0 (never negative during valid processing)
- Termination: loop processes each character once, so terminates when all characters processed

The key insight is that the counter tracks unmatched opening brackets, and it should never go negative (which would mean more closing than opening brackets at that point).
</thinking>

```dafny
method correct_bracketing(brackets: string) returns (result: bool)
    ensures result <==> (forall i :: 0 <= i <= |brackets| ==> 
        (|seq(j | 0 <= j < i && brackets[j] == '<')| >= |seq(j | 0 <= j < i && brackets[j] == '>')|)) &&
        |seq(j | 0 <= j < |brackets| && brackets[j] == '<')| == |seq(j | 0 <= j < |brackets| && brackets[j] == '>')|
{
    var counter := 0;
    var i := 0;
    
    while i < |brackets|
        invariant 0 <= i <= |brackets|
        invariant counter >= 0
        invariant counter == |seq(j | 0 <= j < i && brackets[j] == '<')| - |seq(j | 0 <= j < i && brackets[j] == '>')|
        decreases |brackets| - i
    {
        if brackets[i] == '<' {
            counter := counter + 1;
        } else if brackets[i] == '>' {
            counter := counter - 1;
            if counter < 0 {
                return false;
            }
        }
        i := i + 1;
    }
    
    return counter == 0;
}
```


=============== USER ===============
Your previous attempt failed to compile. Here is the error message:
<compilation_error>
temp_compile.dfy(3,50): Error: comma expected
  |
3 |         (|seq(j | 0 <= j < i && brackets[j] == '<')| >= |seq(j | 0 <= j < i && brackets[j] == '>')|)) &&
  |                                                   ^

temp_compile.dfy(3,97): Error: comma expected
  |
3 |         (|seq(j | 0 <= j < i && brackets[j] == '<')| >= |seq(j | 0 <= j < i && brackets[j] == '>')|)) &&
  |                                                                                                  ^

temp_compile.dfy(4,58): Error: comma expected
  |
4 |         |seq(j | 0 <= j < |brackets| && brackets[j] == '<')| == |seq(j | 0 <= j < |brackets| && brackets[j] == '>')|
  |                                                           ^

temp_compile.dfy(4,114): Error: comma expected
  |
4 |         |seq(j | 0 <= j < |brackets| && brackets[j] == '<')| == |seq(j | 0 <= j < |brackets| && brackets[j] == '>')|
  |                                                                                                                   ^

temp_compile.dfy(12,70): Error: comma expected
   |
12 |         invariant counter == |seq(j | 0 <= j < i && brackets[j] == '<')| - |seq(j | 0 <= j < i && brackets[j] == '>')|
   |                                                                       ^

temp_compile.dfy(12,116): Error: comma expected
   |
12 |         invariant counter == |seq(j | 0 <= j < i && brackets[j] == '<')| - |seq(j | 0 <= j < i && brackets[j] == '>')|
   |                                                                                                                     ^

6 parse errors detected in temp_compile.dfy

</compilation_error>

Please analyze the error and provide the COMPLETE Dafny code again with the fix applied. 
Do not provide just the missing pieces - provide the entire solution including any helper functions, the main method, and all specifications. 


=============== ASSISTANT ===============
--- THINKING ---
The error is in the sequence comprehension syntax. In Dafny, when using set or sequence comprehensions, the syntax should be:

`seq(j | 0 <= j < i :: brackets[j])`

But I was trying to use it as a filter with `&&`. I need to fix the syntax. The correct way would be to use set comprehensions for counting characters:

`|set j | 0 <= j < i && brackets[j] == '<'|`

Or I can simplify the specification by just stating the property more directly without trying to count explicitly.

Let me rewrite this with a simpler specification that captures the essence: the brackets are correctly balanced if at no point do we have more closing brackets than opening brackets, and at the end we have equal numbers of each.

--- RESPONSE ---
```dafny
method correct_bracketing(brackets: string) returns (result: bool)
    ensures result == (forall i :: 0 <= i <= |brackets| ==> 
        |set j | 0 <= j < i && brackets[j] == '<'| >= |set j | 0 <= j < i && brackets[j] == '>'|) &&
        |set j | 0 <= j < |brackets| && brackets[j] == '<'| == |set j | 0 <= j < |brackets| && brackets[j] == '>'|
{
    var counter := 0;
    var i := 0;
    
    while i < |brackets|
        invariant 0 <= i <= |brackets|
        invariant counter >= 0
        invariant counter == |set j | 0 <= j < i && brackets[j] == '<'| - |set j | 0 <= j < i && brackets[j] == '>'|
        decreases |brackets| - i
    {
        if brackets[i] == '<' {
            counter := counter + 1;
        } else if brackets[i] == '>' {
            counter := counter - 1;
            if counter < 0 {
                return false;
            }
        }
        i := i + 1;
    }
    
    return counter == 0;
}
```

