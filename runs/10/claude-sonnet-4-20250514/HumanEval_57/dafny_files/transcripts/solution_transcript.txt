=============== SYSTEM ===============
You are an expert programmer specializing in translating Python code to the Dafny verification language. Your task is to translate the provided Python function into a Dafny method that is both verifiable and compilable. Pay close attention to types, specifications, and providing concrete implementations for all methods.



=============== USER ===============
I will provide you with a Python function and its documentation. Please translate the Python function into a Dafny method.

**Python Function and Documentation:**
```python


def monotonic(l: list):
    """Return True is list elements are monotonically increasing or decreasing.
    >>> monotonic([1, 2, 4, 20])
    True
    >>> monotonic([1, 20, 4, 10])
    False
    >>> monotonic([4, 1, 0, -10])
    True
    """

def monotonic(l: list):
    """Return True is list elements are monotonically increasing or decreasing.
    >>> monotonic([1, 2, 4, 20])
    True
    >>> monotonic([1, 20, 4, 10])
    False
    >>> monotonic([4, 1, 0, -10])
    True
    """
    if len(l) <= 1:
        return True
    
    # Check if monotonically increasing (non-decreasing)
    increasing = all(l[i] <= l[i + 1] for i in range(len(l) - 1))
    
    # Check if monotonically decreasing (non-increasing)
    decreasing = all(l[i] >= l[i + 1] for i in range(len(l) - 1))
    
    return increasing or decreasing
```

**Your Task:**
1.  **Reasoning (in a <thinking> block):**
    *   Analyze the Python code and its types. How will you map Python types (like lists of floats) to Dafny types (like `seq<real>`)?
    *   Analyze the function's logic. What are the pre-conditions (`requires`) and post-conditions (`ensures`)?
    *   Identify any loops and determine their invariants.
    *   Think about termination conditions for any recursive calls or loops.
2.  **Dafny Implementation (in a ```dafny ... ``` block):**
    *   Write the complete Dafny method, including its signature, `requires` clauses, `ensures` clauses, and the method body.
    *   **The return type of the main method must be a basic Dafny type.** Use `int`, `real`, `bool`, `string`, or a sequence of these types (e.g., `seq<int>`). Do not use custom `datatype`s in the return signature. If the Python code implies an optional return (e.g. returning `None`), you should return a sensible default for the basic type instead (e.g. `false`, `-1`, or an empty sequence `[]`).
    *   The Dafny method name must be exactly the same as the Python function name: `monotonic`. Do not change the casing.
    *   **All methods must have a concrete implementation (a body).** The `{:axiom}` attribute is forbidden for defining standard functions. However, if the problem's solution relies on an unproven mathematical conjecture (e.g., the Goldbach Conjecture, P vs NP), you may state the conjecture as an `axiom`. If you do so, you **must** include a comment identifying the conjecture (e.g., `// Axiom for the Twin Prime Conjecture`). Do not use axioms to avoid implementing solvable algorithms.
    *   **Provide explicit termination proofs.** For any recursive function, you must include a `decreases` clause. Do **not** use `decreases *`. For functions that operate on a sequence, the termination metric is almost always the length of the sequence (e.g., `decreases my_sequence`). For functions on integers, it is the integer itself (e.g., `decreases n`).
    *   **Do not use Dafny reserved keywords as variable names.** Avoid names like: `abstract, allocated, as, assert, assume, bool, break, by, calc, case, char, class, codatatype, const, constructor, datatype, decreases, else, ensures, exists, export, extends, false, forall, fresh, function, ghost, if, imap, import, in, include, int, invariant, is, iset, iterator, label, lemma, map, match, method, modifies, modify, module, multiset, nameonly, nat, new, newtype, null, object, object?, old, opened, ORDINAL, predicate, print, provides,reads, real, refines, requires, return, returns, reveal, reveals, seq, set, static, string, then, this, trait, true, twostate, type, unchanged, var, while, witness, yield, yields`. For example, instead of `var array`, use `var arr`.



=============== ASSISTANT ===============
--- THINKING ---
Let me analyze the Python function:

1. The function takes a list of numbers and returns True if they are monotonically increasing or decreasing.
2. If the list has 0 or 1 elements, it returns True.
3. It checks if all consecutive pairs satisfy l[i] <= l[i+1] (non-decreasing).
4. It checks if all consecutive pairs satisfy l[i] >= l[i+1] (non-increasing).
5. It returns True if either condition is satisfied.

For Dafny translation:
- Input type: `seq<int>` (I'll use integers since the examples show integers)
- Return type: `bool`
- Pre-conditions: None really needed
- Post-conditions: The result should be true iff the sequence is monotonic

The logic involves checking all consecutive pairs, which suggests I need to iterate through the sequence. I can use a helper function or do it directly in the method.

Let me think about the invariants:
- For checking increasing: at each step i, all pairs from 0 to i satisfy the increasing condition
- For checking decreasing: at each step i, all pairs from 0 to i satisfy the decreasing condition

Actually, let me implement helper predicates first to make this cleaner.

--- RESPONSE ---
<thinking>
Let me analyze the Python function:

1. **Types**: The function takes a list and returns a boolean. In Dafny, I'll use `seq<int>` for the input (based on the examples which show integers) and `bool` for the return type.

2. **Logic**: 
   - If the sequence has â‰¤1 elements, return True
   - Check if the sequence is non-decreasing (monotonically increasing)
   - Check if the sequence is non-increasing (monotonically decreasing)  
   - Return True if either condition holds

3. **Pre/Post-conditions**:
   - No special preconditions needed
   - Post-condition: result is true iff the sequence is monotonically increasing or decreasing

4. **Implementation approach**: I'll need helper predicates to check if a sequence is non-decreasing or non-increasing. These will involve iterating through consecutive pairs, so I'll need loop invariants.

5. **Termination**: The loops will iterate through indices from 0 to |seq|-2, so they naturally terminate.
</thinking>

```dafny
predicate IsNonDecreasing(s: seq<int>)
{
  forall i :: 0 <= i < |s| - 1 ==> s[i] <= s[i + 1]
}

predicate IsNonIncreasing(s: seq<int>)
{
  forall i :: 0 <= i < |s| - 1 ==> s[i] >= s[i + 1]
}

method CheckNonDecreasing(s: seq<int>) returns (result: bool)
  ensures result <==> IsNonDecreasing(s)
{
  if |s| <= 1 {
    return true;
  }
  
  var i := 0;
  while i < |s| - 1
    invariant 0 <= i <= |s| - 1
    invariant forall j :: 0 <= j < i ==> s[j] <= s[j + 1]
  {
    if s[i] > s[i + 1] {
      return false;
    }
    i := i + 1;
  }
  return true;
}

method CheckNonIncreasing(s: seq<int>) returns (result: bool)
  ensures result <==> IsNonIncreasing(s)
{
  if |s| <= 1 {
    return true;
  }
  
  var i := 0;
  while i < |s| - 1
    invariant 0 <= i <= |s| - 1
    invariant forall j :: 0 <= j < i ==> s[j] >= s[j + 1]
  {
    if s[i] < s[i + 1] {
      return false;
    }
    i := i + 1;
  }
  return true;
}

method monotonic(l: seq<int>) returns (result: bool)
  ensures result <==> (|l| <= 1 || IsNonDecreasing(l) || IsNonIncreasing(l))
{
  if |l| <= 1 {
    return true;
  }
  
  var increasing := CheckNonDecreasing(l);
  var decreasing := CheckNonIncreasing(l);
  
  return increasing || decreasing;
}
```

