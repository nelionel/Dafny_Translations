=============== SYSTEM ===============
You are an expert programmer specializing in translating Python code to the Dafny verification language. Your task is to translate the provided Python function into a Dafny method that is both verifiable and compilable. Pay close attention to types, specifications, and providing concrete implementations for all methods.



=============== USER ===============
I will provide you with a Python function and its documentation. Please translate the Python function into a Dafny method.

**Python Function and Documentation:**
```python


def common(l1: list, l2: list):
    """Return sorted unique common elements for two lists.
    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])
    [1, 5, 653]
    >>> common([5, 3, 2, 8], [3, 2])
    [2, 3]

    """

def common(l1: list, l2: list):
    """Return sorted unique common elements for two lists.
    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])
    [1, 5, 653]
    >>> common([5, 3, 2, 8], [3, 2])
    [2, 3]

    """
    # Convert lists to sets to find intersection (common elements)
    # This automatically removes duplicates
    common_elements = set(l1) & set(l2)
    
    # Convert back to list and sort
    return sorted(list(common_elements))
```

**Your Task:**
1.  **Reasoning (in a <thinking> block):**
    *   Analyze the Python code and its types. How will you map Python types (like lists of floats) to Dafny types (like `seq<real>`)?
    *   Analyze the function's logic. What are the pre-conditions (`requires`) and post-conditions (`ensures`)?
    *   Identify any loops and determine their invariants.
    *   Think about termination conditions for any recursive calls or loops.
2.  **Dafny Implementation (in a ```dafny ... ``` block):**
    *   Write the complete Dafny method, including its signature, `requires` clauses, `ensures` clauses, and the method body.
    *   **The return type of the main method must be a basic Dafny type.** Use `int`, `real`, `bool`, `string`, or a sequence of these types (e.g., `seq<int>`). Do not use custom `datatype`s in the return signature. If the Python code implies an optional return (e.g. returning `None`), you should return a sensible default for the basic type instead (e.g. `false`, `-1`, or an empty sequence `[]`).
    *   The Dafny method name must be exactly the same as the Python function name: `common`. Do not change the casing.
    *   **All methods must have a concrete implementation (a body).** The `{:axiom}` attribute is forbidden for defining standard functions. However, if the problem's solution relies on an unproven mathematical conjecture (e.g., the Goldbach Conjecture, P vs NP), you may state the conjecture as an `axiom`. If you do so, you **must** include a comment identifying the conjecture (e.g., `// Axiom for the Twin Prime Conjecture`). Do not use axioms to avoid implementing solvable algorithms.
    *   **Provide explicit termination proofs.** For any recursive function, you must include a `decreases` clause. Do **not** use `decreases *`. For functions that operate on a sequence, the termination metric is almost always the length of the sequence (e.g., `decreases my_sequence`). For functions on integers, it is the integer itself (e.g., `decreases n`).
    *   **Do not use Dafny reserved keywords as variable names.** Avoid names like: `abstract, allocated, as, assert, assume, bool, break, by, calc, case, char, class, codatatype, const, constructor, datatype, decreases, else, ensures, exists, export, extends, false, forall, fresh, function, ghost, if, imap, import, in, include, int, invariant, is, iset, iterator, label, lemma, map, match, method, modifies, modify, module, multiset, nameonly, nat, new, newtype, null, object, object?, old, opened, ORDINAL, predicate, print, provides,reads, real, refines, requires, return, returns, reveal, reveals, seq, set, static, string, then, this, trait, true, twostate, type, unchanged, var, while, witness, yield, yields`. For example, instead of `var array`, use `var arr`.



=============== ASSISTANT ===============
--- THINKING ---
Let me analyze the Python function and translate it to Dafny.

**Python Function Analysis:**
1. The function takes two lists as input
2. It finds the common elements (intersection) between the two lists
3. It removes duplicates (since sets naturally don't have duplicates)
4. It returns the result as a sorted list

**Type Mapping:**
- Python `list` will map to Dafny `seq<int>` (assuming integer lists based on the examples)
- The return type will be `seq<int>`

**Logic Analysis:**
- Pre-conditions: None really needed, the function should work for any two sequences
- Post-conditions: 
  - The result should contain only elements that appear in both input sequences
  - The result should be sorted
  - The result should have no duplicates
  - All elements in the result should be present in both input sequences

**Implementation Strategy:**
I need to:
1. Find elements that are in both sequences
2. Remove duplicates
3. Sort the result

In Dafny, I'll need helper functions for:
- Checking if an element is in a sequence
- Removing duplicates from a sequence
- Sorting a sequence

Let me think about the implementation:

```dafny
method common(l1: seq<int>, l2: seq<int>) returns (result: seq<int>)
  ensures forall x :: x in result ==> x in l1 && x in l2
  ensures forall i, j :: 0 <= i < j < |result| ==> result[i] < result[j]  // sorted
  ensures forall i, j :: 0 <= i < j < |result| ==> result[i] != result[j]  // no duplicates
{
  // Find common elements
  var commons := [];
  var i := 0;
  while i < |l1|
    invariant 0 <= i <= |l1|
    invariant forall x :: x in commons ==> x in l1 && x in l2
  {
    if l1[i] in l2 && l1[i] !in commons {
      commons := commons + [l1[i]];
    }
    i := i + 1;
  }
  
  // Sort the commons
  result := sort(commons);
}
```

I'll focus on creating helper functions to support the core implementation. The key challenges will involve implementing sequence membership checks and sorting efficiently in Dafny's verification-friendly environment.

I'll start by developing a membership check function that can verify whether an element exists in a sequence. This will be crucial for the duplicate removal and common element identification process.

For sorting, I'm considering two primary approaches: insertion sort for smaller sequences and merge sort for more complex scenarios. Each method has verification and performance trade-offs I'll need to carefully evaluate.

--- RESPONSE ---
<thinking>
Let me analyze the Python function:

1. **Types**: The function takes two lists and returns a list. Based on the examples, these appear to be lists of integers, so I'll use `seq<int>` in Dafny.

2. **Logic**: The function finds the intersection of two lists (common elements), removes duplicates, and returns them sorted.

3. **Pre-conditions**: No specific requirements needed - the function should work with any two sequences.

4. **Post-conditions**: 
   - All elements in result must be present in both input sequences
   - Result must be sorted in ascending order
   - Result must have no duplicates

5. **Implementation strategy**: I'll need helper functions for:
   - Checking if an element exists in a sequence
   - Removing duplicates
   - Sorting

6. **Loops/Termination**: I'll need loops to iterate through sequences, with termination metrics based on sequence lengths.
</thinking>

```dafny
method common(l1: seq<int>, l2: seq<int>) returns (result: seq<int>)
  ensures forall x :: x in result ==> x in l1 && x in l2
  ensures forall i, j :: 0 <= i < j < |result| ==> result[i] < result[j]
  ensures forall i, j :: 0 <= i < j < |result| ==> result[i] != result[j]
{
  // Find common elements without duplicates
  var commons := [];
  var i := 0;
  
  while i < |l1|
    invariant 0 <= i <= |l1|
    invariant forall x :: x in commons ==> x in l1 && x in l2
    invariant forall x, y :: x in commons && y in commons && x != y ==> x != y
    decreases |l1| - i
  {
    if inSeq(l1[i], l2) && !inSeq(l1[i], commons) {
      commons := commons + [l1[i]];
    }
    i := i + 1;
  }
  
  // Sort the result
  result := insertionSort(commons);
}

function inSeq(x: int, s: seq<int>): bool
{
  x in s
}

method insertionSort(s: seq<int>) returns (sorted: seq<int>)
  ensures |sorted| == |s|
  ensures forall x :: x in s <==> x in sorted
  ensures forall i, j :: 0 <= i < j < |sorted| ==> sorted[i] <= sorted[j]
{
  sorted := [];
  var i := 0;
  
  while i < |s|
    invariant 0 <= i <= |s|
    invariant |sorted| == i
    invariant forall k :: 0 <= k < i ==> s[k] in sorted
    invariant forall x :: x in sorted ==> x in s[0..i]
    invariant forall p, q :: 0 <= p < q < |sorted| ==> sorted[p] <= sorted[q]
    decreases |s| - i
  {
    sorted := insertSorted(sorted, s[i]);
    i := i + 1;
  }
}

method insertSorted(sorted: seq<int>, x: int) returns (result: seq<int>)
  requires forall i, j :: 0 <= i < j < |sorted| ==> sorted[i] <= sorted[j]
  ensures |result| == |sorted| + 1
  ensures x in result
  ensures forall y :: y in sorted ==> y in result
  ensures forall i, j :: 0 <= i < j < |result| ==> result[i] <= result[j]
{
  var pos := 0;
  
  while pos < |sorted| && sorted[pos] <= x
    invariant 0 <= pos <= |sorted|
    invariant forall k :: 0 <= k < pos ==> sorted[k] <= x
    decreases |sorted| - pos
  {
    pos := pos + 1;
  }
  
  result := sorted[0..pos] + [x] + sorted[pos..];
}
```

