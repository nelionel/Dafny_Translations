=============== SYSTEM ===============
You are an expert in formal verification and Dafny specifications. Your task is to analyze whether Dafny method specifications properly describe the behavior of the corresponding Python function.

You will be given:
1. A Python function with its behavior
2. A Dafny method translation with specifications (requires, ensures clauses)

Your job is to determine if the Dafny specifications fully and accurately capture the Python function's behavior. If not, you should improve the specifications.

IMPORTANT: You must respond with EXACTLY one of these phrases:
- "THE SCRIPT HAS PROPER SPECS" - if the specifications correctly describe the function
- "THE SCRIPT HAD NOT A PROPER SPEC" - if the specifications need improvement

After this phrase, provide the complete Dafny code (either unchanged or with improved specifications).



=============== USER ===============
Please analyze whether the Dafny specifications properly describe the Python function behavior.

**Python Function:**
```python
def largest_prime_factor(n: int):
    """Return the largest prime factor of n. Assume n > 1 and is not a prime.
    >>> largest_prime_factor(13195)
    29
    >>> largest_prime_factor(2048)
    2
    """
    largest_factor = 1
    
    # Check for factor 2
    while n % 2 == 0:
        largest_factor = 2
        n = n // 2
    
    # Check for odd factors starting from 3
    factor = 3
    while factor * factor <= n:
        while n % factor == 0:
            largest_factor = factor
            n = n // factor
        factor += 2
    
    # If n is still greater than 1, then it's a prime factor
    if n > 1:
        largest_factor = n
    
    return largest_factor
```

**Current Dafny Code:**
```dafny
method largest_prime_factor(n: int) returns (result: int)
  requires n > 1
  ensures result >= 1
{
  var largest_factor := 1;
  var current_n := n;
  
  // Check for factor 2
  while current_n % 2 == 0
    invariant current_n >= 1
    invariant largest_factor >= 1
    decreases current_n
  {
    largest_factor := 2;
    current_n := current_n / 2;
  }
  
  // Check for odd factors starting from 3
  var factor := 3;
  while factor * factor <= current_n
    invariant factor >= 3
    invariant factor % 2 == 1
    invariant current_n >= 1
    invariant largest_factor >= 1
    decreases current_n
  {
    while current_n % factor == 0
      invariant current_n >= 1
      invariant factor >= 3
      invariant largest_factor >= 1
      decreases current_n
    {
      largest_factor := factor;
      current_n := current_n / factor;
    }
    factor := factor + 2;
  }
  
  // If current_n is still greater than 1, then it's a prime factor
  if current_n > 1 {
    largest_factor := current_n;
  }
  
  result := largest_factor;
}
```

**Analysis Task:**
1. Compare the Python function's behavior with the Dafny specifications
2. Check if the `requires` clauses capture all preconditions
3. Check if the `ensures` clauses capture all postconditions and behavior
4. Verify that the specifications fully describe what the function does

**Response Format:**
Start with exactly one of these phrases:
- "THE SCRIPT HAS PROPER SPECS" (if specifications are adequate)
- "THE SCRIPT HAD NOT A PROPER SPEC" (if specifications need improvement)

Then provide the complete Dafny code. If improving specifications:
- Add missing `requires` clauses for preconditions
- Add missing `ensures` clauses for postconditions
- Ensure specifications capture the function's complete behavior
- Preserve the existing method implementation unchanged

 


=============== ASSISTANT ===============
--- THINKING ---
Let me analyze the Python function and the Dafny specifications.

The Python function `largest_prime_factor(n)`:
1. Takes an integer n where n > 1 and is not a prime (according to the docstring)
2. Returns the largest prime factor of n
3. The examples show: largest_prime_factor(13195) = 29, largest_prime_factor(2048) = 2

Now let me look at the Dafny specifications:
- `requires n > 1` - This captures the precondition that n > 1
- `ensures result >= 1` - This only ensures the result is at least 1

But wait, the Python docstring says "Assume n > 1 and is not a prime". However, looking at the actual implementation, it seems like it would work even if n is prime (in that case, it would return n itself as the largest prime factor). Let me check:

If n = 7 (a prime):
- It's not divisible by 2, so largest_factor remains 1
- factor = 3, and 3*3 = 9 > 7, so the while loop doesn't execute
- current_n = 7 > 1, so largest_factor = 7
- Returns 7

So the function actually works for prime numbers too, returning the prime number itself.

But the more important issue is that the Dafny specifications don't capture the main behavior of the function - that it returns the largest prime factor of n. The current ensures clause only says `result >= 1`, which is very weak.

The specifications should capture:
1. The result is a prime factor of n
2. The result is the largest such prime factor
3. The result divides n

Let me think about what proper specifications would be:

```dafny
method largest_prime_factor(n: int) returns (result: int)
  requires n > 1
  ensures result >= 2  // prime factors are at least 2
  ensures n % result == 0  // result divides n
  ensures IsPrime(result)  // result is prime
  ensures forall p :: IsPrime(p) && n % p == 0 ==> p <= result  // result is the largest prime factor
```

I see the specifications need to precisely define the function's core behavior. The current approach lacks depth in capturing the essential characteristics of finding the largest prime factor. The key challenge lies in creating specifications that comprehensively describe the function's expected output while maintaining clarity and precision.

The implementation reveals nuanced behavior, particularly its ability to handle prime numbers as input. This suggests the need for robust specifications that account for various input scenarios while maintaining the core logic of identifying the largest prime factor.

Critically, the specifications must go beyond trivial constraints, focusing on the fundamental mathematical properties that define the largest prime factor calculation. The goal is to create a specification that is both mathematically rigorous and computationally meaningful.

--- RESPONSE ---
THE SCRIPT HAD NOT A PROPER SPEC

```dafny
method largest_prime_factor(n: int) returns (result: int)
  requires n > 1
  ensures result >= 2
  ensures n % result == 0
  ensures forall k :: k > result && n % k == 0 ==> exists m :: m > 1 && m < k && k % m == 0
{
  var largest_factor := 1;
  var current_n := n;
  
  // Check for factor 2
  while current_n % 2 == 0
    invariant current_n >= 1
    invariant largest_factor >= 1
    decreases current_n
  {
    largest_factor := 2;
    current_n := current_n / 2;
  }
  
  // Check for odd factors starting from 3
  var factor := 3;
  while factor * factor <= current_n
    invariant factor >= 3
    invariant factor % 2 == 1
    invariant current_n >= 1
    invariant largest_factor >= 1
    decreases current_n
  {
    while current_n % factor == 0
      invariant current_n >= 1
      invariant factor >= 3
      invariant largest_factor >= 1
      decreases current_n
    {
      largest_factor := factor;
      current_n := current_n / factor;
    }
    factor := factor + 2;
  }
  
  // If current_n is still greater than 1, then it's a prime factor
  if current_n > 1 {
    largest_factor := current_n;
  }
  
  result := largest_factor;
}
```


=============== USER ===============
Please analyze whether the Dafny specifications properly describe the Python function behavior.

**Python Function:**
```python
def largest_prime_factor(n: int):
    """Return the largest prime factor of n. Assume n > 1 and is not a prime.
    >>> largest_prime_factor(13195)
    29
    >>> largest_prime_factor(2048)
    2
    """
    largest_factor = 1
    
    # Check for factor 2
    while n % 2 == 0:
        largest_factor = 2
        n = n // 2
    
    # Check for odd factors starting from 3
    factor = 3
    while factor * factor <= n:
        while n % factor == 0:
            largest_factor = factor
            n = n // factor
        factor += 2
    
    # If n is still greater than 1, then it's a prime factor
    if n > 1:
        largest_factor = n
    
    return largest_factor
```

**Current Dafny Code:**
```dafny
method largest_prime_factor(n: int) returns (result: int)
  requires n > 1
  ensures result >= 2
  ensures n % result == 0
  ensures forall k :: k > result && n % k == 0 ==> exists m :: m > 1 && m < k && k % m == 0
{
  var largest_factor := 1;
  var current_n := n;
  
  // Check for factor 2
  while current_n % 2 == 0
    invariant current_n >= 1
    invariant largest_factor >= 1
    decreases current_n
  {
    largest_factor := 2;
    current_n := current_n / 2;
  }
  
  // Check for odd factors starting from 3
  var factor := 3;
  while factor * factor <= current_n
    invariant factor >= 3
    invariant factor % 2 == 1
    invariant current_n >= 1
    invariant largest_factor >= 1
    decreases current_n
  {
    while current_n % factor == 0
      invariant current_n >= 1
      invariant factor >= 3
      invariant largest_factor >= 1
      decreases current_n
    {
      largest_factor := factor;
      current_n := current_n / factor;
    }
    factor := factor + 2;
  }
  
  // If current_n is still greater than 1, then it's a prime factor
  if current_n > 1 {
    largest_factor := current_n;
  }
  
  result := largest_factor;
}
```

**Analysis Task:**
1. Compare the Python function's behavior with the Dafny specifications
2. Check if the `requires` clauses capture all preconditions
3. Check if the `ensures` clauses capture all postconditions and behavior
4. Verify that the specifications fully describe what the function does

**Response Format:**
Start with exactly one of these phrases:
- "THE SCRIPT HAS PROPER SPECS" (if specifications are adequate)
- "THE SCRIPT HAD NOT A PROPER SPEC" (if specifications need improvement)

Then provide the complete Dafny code. If improving specifications:
- Add missing `requires` clauses for preconditions
- Add missing `ensures` clauses for postconditions
- Ensure specifications capture the function's complete behavior
- Preserve the existing method implementation unchanged



This is attempt 2 to improve the specifications. Please analyze the current version and improve it further if needed. 


=============== ASSISTANT ===============
--- THINKING ---
Let me analyze the Python function and the Dafny specifications:

**Python Function Analysis:**
1. Takes an integer `n > 1` and assumes `n` is not a prime
2. Returns the largest prime factor of `n`
3. The algorithm:
   - First checks for factor 2 and removes all factors of 2
   - Then checks odd factors from 3 onwards up to sqrt(n)
   - If after all divisions n > 1, then n itself is a prime factor

**Current Dafny Specifications Analysis:**

```dafny
requires n > 1
ensures result >= 2
ensures n % result == 0
ensures forall k :: k > result && n % k == 0 ==> exists m :: m > 1 && m < k && k % m == 0
```

Let me check each specification:

1. `requires n > 1` - This matches the Python docstring assumption
2. `ensures result >= 2` - This is correct since the smallest prime is 2
3. `ensures n % result == 0` - This ensures result is a factor of n, which is correct
4. `ensures forall k :: k > result && n % k == 0 ==> exists m :: m > 1 && m < k && k % m == 0` - This is trying to say that any factor of n larger than result is composite (not prime)

However, there are some issues:
1. The Python docstring says "Assume n > 1 and is not a prime" - but the requires clause doesn't capture that n is not prime
2. The most important postcondition is missing: the result should be PRIME
3. The last ensures clause is trying to ensure that result is the LARGEST prime factor, but it's not quite right

The key missing specification is that the result should be prime. The current specification doesn't guarantee that `result` itself is prime.

Also, the specification should ensure that result is the LARGEST prime factor, meaning there's no prime factor larger than result.


I'll refine the specifications to address these key requirements. The primary goal is to precisely define the largest prime factor with clear, unambiguous conditions. 

I need specifications that confirm:
- The result is a factor of n
- The result is prime
- The result is the largest such prime factor

This means crafting precise logical constraints that capture the essence of finding the largest prime factor while ruling out any larger prime divisors. The specifications must be both mathematically rigorous and computationally verifiable.

The critical constraints involve proving that no larger factor exists that is prime, which requires showing any larger factor must be composite. This demands a nuanced logical approach that checks both divisibility and primality conditions systematically.

The key specifications will involve quantified statements that establish the result's primality and maximal nature, ensuring comprehensive coverage of the factor's mathematical properties.

--- RESPONSE ---
THE SCRIPT HAD NOT A PROPER SPEC

```dafny
method largest_prime_factor(n: int) returns (result: int)
  requires n > 1
  ensures result >= 2
  ensures n % result == 0
  ensures forall m :: 1 < m < result ==> result % m != 0
  ensures forall k :: k > result && n % k == 0 ==> exists m :: m > 1 && m < k && k % m == 0
{
  var largest_factor := 1;
  var current_n := n;
  
  // Check for factor 2
  while current_n % 2 == 0
    invariant current_n >= 1
    invariant largest_factor >= 1
    decreases current_n
  {
    largest_factor := 2;
    current_n := current_n / 2;
  }
  
  // Check for odd factors starting from 3
  var factor := 3;
  while factor * factor <= current_n
    invariant factor >= 3
    invariant factor % 2 == 1
    invariant current_n >= 1
    invariant largest_factor >= 1
    decreases current_n
  {
    while current_n % factor == 0
      invariant current_n >= 1
      invariant factor >= 3
      invariant largest_factor >= 1
      decreases current_n
    {
      largest_factor := factor;
      current_n := current_n / factor;
    }
    factor := factor + 2;
  }
  
  // If current_n is still greater than 1, then it's a prime factor
  if current_n > 1 {
    largest_factor := current_n;
  }
  
  result := largest_factor;
}
```


=============== USER ===============
Please analyze whether the Dafny specifications properly describe the Python function behavior.

**Python Function:**
```python
def largest_prime_factor(n: int):
    """Return the largest prime factor of n. Assume n > 1 and is not a prime.
    >>> largest_prime_factor(13195)
    29
    >>> largest_prime_factor(2048)
    2
    """
    largest_factor = 1
    
    # Check for factor 2
    while n % 2 == 0:
        largest_factor = 2
        n = n // 2
    
    # Check for odd factors starting from 3
    factor = 3
    while factor * factor <= n:
        while n % factor == 0:
            largest_factor = factor
            n = n // factor
        factor += 2
    
    # If n is still greater than 1, then it's a prime factor
    if n > 1:
        largest_factor = n
    
    return largest_factor
```

**Current Dafny Code:**
```dafny
method largest_prime_factor(n: int) returns (result: int)
  requires n > 1
  ensures result >= 2
  ensures n % result == 0
  ensures forall m :: 1 < m < result ==> result % m != 0
  ensures forall k :: k > result && n % k == 0 ==> exists m :: m > 1 && m < k && k % m == 0
{
  var largest_factor := 1;
  var current_n := n;
  
  // Check for factor 2
  while current_n % 2 == 0
    invariant current_n >= 1
    invariant largest_factor >= 1
    decreases current_n
  {
    largest_factor := 2;
    current_n := current_n / 2;
  }
  
  // Check for odd factors starting from 3
  var factor := 3;
  while factor * factor <= current_n
    invariant factor >= 3
    invariant factor % 2 == 1
    invariant current_n >= 1
    invariant largest_factor >= 1
    decreases current_n
  {
    while current_n % factor == 0
      invariant current_n >= 1
      invariant factor >= 3
      invariant largest_factor >= 1
      decreases current_n
    {
      largest_factor := factor;
      current_n := current_n / factor;
    }
    factor := factor + 2;
  }
  
  // If current_n is still greater than 1, then it's a prime factor
  if current_n > 1 {
    largest_factor := current_n;
  }
  
  result := largest_factor;
}
```

**Analysis Task:**
1. Compare the Python function's behavior with the Dafny specifications
2. Check if the `requires` clauses capture all preconditions
3. Check if the `ensures` clauses capture all postconditions and behavior
4. Verify that the specifications fully describe what the function does

**Response Format:**
Start with exactly one of these phrases:
- "THE SCRIPT HAS PROPER SPECS" (if specifications are adequate)
- "THE SCRIPT HAD NOT A PROPER SPEC" (if specifications need improvement)

Then provide the complete Dafny code. If improving specifications:
- Add missing `requires` clauses for preconditions
- Add missing `ensures` clauses for postconditions
- Ensure specifications capture the function's complete behavior
- Preserve the existing method implementation unchanged



This is attempt 3 to improve the specifications. Please analyze the current version and improve it further if needed. 


=============== ASSISTANT ===============
--- THINKING ---
Let me analyze the Python function and the Dafny specifications to see if they match up properly.

The Python function `largest_prime_factor(n)`:
1. Takes an integer n > 1 and assumes n is not a prime
2. Returns the largest prime factor of n
3. The algorithm works by:
   - First dividing out all factors of 2
   - Then checking odd factors from 3 upwards
   - If after all this n > 1, then n itself is a prime factor

Now let's look at the Dafny specifications:

```dafny
requires n > 1
ensures result >= 2
ensures n % result == 0
ensures forall m :: 1 < m < result ==> result % m != 0
ensures forall k :: k > result && n % k == 0 ==> exists m :: m > 1 && m < k && k % m == 0
```

Let me analyze each:

1. `requires n > 1` - This matches the Python assumption that n > 1.

2. `ensures result >= 2` - This is correct since the smallest prime is 2.

3. `ensures n % result == 0` - This says the result divides n, which is correct.

4. `ensures forall m :: 1 < m < result ==> result % m != 0` - This says result is prime (no factors between 1 and result), which is correct.

5. `ensures forall k :: k > result && n % k == 0 ==> exists m :: m > 1 && m < k && k % m == 0` - This says that any factor of n larger than result is composite (not prime). This ensures that result is the largest prime factor.

However, I'm missing something important. The Python function comment says "Assume n > 1 and is not a prime." But the Dafny specification doesn't capture this assumption that n is not prime. 


I realize the algorithm handles prime and non-prime cases differently. If n is prime, the largest prime factor would simply be n itself. The implementation would still work correctly, systematically breaking down the number until it reaches its final prime factor. The key is to ensure the specification captures the nuanced behavior for both prime and non-prime inputs.

The examples reveal a pattern: composite numbers like 13195 and 2048 require different factorization strategies. The docstring's explicit constraint about n being non-prime suggests a specific implementation focus. By restricting the input, the algorithm can optimize its prime factor detection approach.

The ensures clauses provide rigorous constraints on the result's properties, guaranteeing the returned value meets precise mathematical conditions about divisibility and primality.

I'll add a requirement ensuring the input is composite by checking for proper divisors, which prevents prime numbers from being processed directly. This specification matches the documented behavior and constrains the algorithm's input domain.

--- RESPONSE ---
THE SCRIPT HAD NOT A PROPER SPEC

```dafny
method largest_prime_factor(n: int) returns (result: int)
  requires n > 1
  requires exists k :: k > 1 && k < n && n % k == 0  // n is composite (not prime)
  ensures result >= 2
  ensures n % result == 0
  ensures forall m :: 1 < m < result ==> result % m != 0
  ensures forall k :: k > result && n % k == 0 ==> exists m :: m > 1 && m < k && k % m == 0
{
  var largest_factor := 1;
  var current_n := n;
  
  // Check for factor 2
  while current_n % 2 == 0
    invariant current_n >= 1
    invariant largest_factor >= 1
    decreases current_n
  {
    largest_factor := 2;
    current_n := current_n / 2;
  }
  
  // Check for odd factors starting from 3
  var factor := 3;
  while factor * factor <= current_n
    invariant factor >= 3
    invariant factor % 2 == 1
    invariant current_n >= 1
    invariant largest_factor >= 1
    decreases current_n
  {
    while current_n % factor == 0
      invariant current_n >= 1
      invariant factor >= 3
      invariant largest_factor >= 1
      decreases current_n
    {
      largest_factor := factor;
      current_n := current_n / factor;
    }
    factor := factor + 2;
  }
  
  // If current_n is still greater than 1, then it's a prime factor
  if current_n > 1 {
    largest_factor := current_n;
  }
  
  result := largest_factor;
}
```


=============== USER ===============
Please analyze whether the Dafny specifications properly describe the Python function behavior.

**Python Function:**
```python
def largest_prime_factor(n: int):
    """Return the largest prime factor of n. Assume n > 1 and is not a prime.
    >>> largest_prime_factor(13195)
    29
    >>> largest_prime_factor(2048)
    2
    """
    largest_factor = 1
    
    # Check for factor 2
    while n % 2 == 0:
        largest_factor = 2
        n = n // 2
    
    # Check for odd factors starting from 3
    factor = 3
    while factor * factor <= n:
        while n % factor == 0:
            largest_factor = factor
            n = n // factor
        factor += 2
    
    # If n is still greater than 1, then it's a prime factor
    if n > 1:
        largest_factor = n
    
    return largest_factor
```

**Current Dafny Code:**
```dafny
method largest_prime_factor(n: int) returns (result: int)
  requires n > 1
  requires exists k :: k > 1 && k < n && n % k == 0  // n is composite (not prime)
  ensures result >= 2
  ensures n % result == 0
  ensures forall m :: 1 < m < result ==> result % m != 0
  ensures forall k :: k > result && n % k == 0 ==> exists m :: m > 1 && m < k && k % m == 0
{
  var largest_factor := 1;
  var current_n := n;
  
  // Check for factor 2
  while current_n % 2 == 0
    invariant current_n >= 1
    invariant largest_factor >= 1
    decreases current_n
  {
    largest_factor := 2;
    current_n := current_n / 2;
  }
  
  // Check for odd factors starting from 3
  var factor := 3;
  while factor * factor <= current_n
    invariant factor >= 3
    invariant factor % 2 == 1
    invariant current_n >= 1
    invariant largest_factor >= 1
    decreases current_n
  {
    while current_n % factor == 0
      invariant current_n >= 1
      invariant factor >= 3
      invariant largest_factor >= 1
      decreases current_n
    {
      largest_factor := factor;
      current_n := current_n / factor;
    }
    factor := factor + 2;
  }
  
  // If current_n is still greater than 1, then it's a prime factor
  if current_n > 1 {
    largest_factor := current_n;
  }
  
  result := largest_factor;
}
```

**Analysis Task:**
1. Compare the Python function's behavior with the Dafny specifications
2. Check if the `requires` clauses capture all preconditions
3. Check if the `ensures` clauses capture all postconditions and behavior
4. Verify that the specifications fully describe what the function does

**Response Format:**
Start with exactly one of these phrases:
- "THE SCRIPT HAS PROPER SPECS" (if specifications are adequate)
- "THE SCRIPT HAD NOT A PROPER SPEC" (if specifications need improvement)

Then provide the complete Dafny code. If improving specifications:
- Add missing `requires` clauses for preconditions
- Add missing `ensures` clauses for postconditions
- Ensure specifications capture the function's complete behavior
- Preserve the existing method implementation unchanged



This is attempt 4 to improve the specifications. Please analyze the current version and improve it further if needed. 


=============== ASSISTANT ===============
--- THINKING ---
Let me analyze the Python function and the current Dafny specifications:

**Python Function Behavior:**
1. Takes an integer n > 1 that is not a prime (composite)
2. Returns the largest prime factor of n
3. The algorithm works by:
   - First checking for factor 2 repeatedly
   - Then checking odd factors from 3 onwards
   - If after all factorization, n > 1, then n itself is the largest prime factor

**Current Dafny Specifications Analysis:**

**Requires clauses:**
1. `requires n > 1` - This matches the Python docstring assumption
2. `requires exists k :: k > 1 && k < n && n % k == 0` - This ensures n is composite (not prime)

These seem correct for the preconditions.

**Ensures clauses:**
1. `ensures result >= 2` - This should be true since we're looking for prime factors and the smallest prime is 2
2. `ensures n % result == 0` - This ensures result is actually a factor of n
3. `ensures forall m :: 1 < m < result ==> result % m != 0` - This ensures result is prime
4. `ensures forall k :: k > result && n % k == 0 ==> exists m :: m > 1 && m < k && k % m == 0` - This ensures no larger prime factor exists

Let me think about whether these are sufficient:

The key question is: do these specifications fully capture that `result` is the LARGEST prime factor?

The fourth ensures clause is trying to say that any factor k larger than result must be composite (not prime). But wait, this doesn't quite capture what we want. We want to ensure that result is the largest PRIME factor.

Actually, let me think about this more carefully. The fourth ensures clause says: "for any k > result that divides n, k must be composite". This is trying to ensure that there's no prime factor larger than result.
 
I'm investigating a nuanced problem with prime factor specifications. The current clause attempts to rule out larger prime factors through a clever logical constraint. By requiring any larger divisor to be composite, the specification indirectly proves the primality and maximality of the result. The contradiction emerges if a larger prime factor existed - it would violate the compositeness requirement of larger divisors.

The logical reasoning suggests the specification successfully captures the largest prime factor constraint through an indirect proof mechanism. By forcing larger divisors to be non-prime, we effectively guarantee the result's primality and maximum value among prime factors.

However, I'm sensing potential edge cases that might need more rigorous examination. A direct specification might provide clearer, more explicit constraints on the prime factor selection.

The proposed formulation using quantifiers offers an elegant way to characterize the largest prime factor. By establishing conditions that no larger prime can divide the number, we effectively define the maximal prime divisor.

I'll verify this approach against concrete examples, checking how the specification handles different number types - prime numbers, composite numbers, and numbers with multiple prime factors. The goal is ensuring the method robustly identifies the largest prime factor across varied input scenarios.

The current specification appears sound, capturing the essential requirement of identifying the most significant prime divisor through logical constraints. Precise mathematical language allows us to precisely define this computational challenge.

--- RESPONSE ---
THE SCRIPT HAS PROPER SPECS

```dafny
method largest_prime_factor(n: int) returns (result: int)
  requires n > 1
  requires exists k :: k > 1 && k < n && n % k == 0  // n is composite (not prime)
  ensures result >= 2
  ensures n % result == 0
  ensures forall m :: 1 < m < result ==> result % m != 0
  ensures forall k :: k > result && n % k == 0 ==> exists m :: m > 1 && m < k && k % m == 0
{
  var largest_factor := 1;
  var current_n := n;
  
  // Check for factor 2
  while current_n % 2 == 0
    invariant current_n >= 1
    invariant largest_factor >= 1
    decreases current_n
  {
    largest_factor := 2;
    current_n := current_n / 2;
  }
  
  // Check for odd factors starting from 3
  var factor := 3;
  while factor * factor <= current_n
    invariant factor >= 3
    invariant factor % 2 == 1
    invariant current_n >= 1
    invariant largest_factor >= 1
    decreases current_n
  {
    while current_n % factor == 0
      invariant current_n >= 1
      invariant factor >= 3
      invariant largest_factor >= 1
      decreases current_n
    {
      largest_factor := factor;
      current_n := current_n / factor;
    }
    factor := factor + 2;
  }
  
  // If current_n is still greater than 1, then it's a prime factor
  if current_n > 1 {
    largest_factor := current_n;
  }
  
  result := largest_factor;
}
```

