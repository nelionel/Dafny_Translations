=============== SYSTEM ===============
You are an expert programmer specializing in translating Python tests to the Dafny verification language. Your task is to translate Python `assert` statements into Dafny test methods and provide a minimal dummy implementation for compilation checking.



=============== USER ===============
I need you to translate Python test assertions into Dafny test methods.

**The Method to Test:**
The Dafny method you need to test is named `parse_nested_parens`.

**Python Test Code:**
```python


METADATA = {
    'author': 'jt',
    'dataset': 'test'
}


def check(candidate):
    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]
    assert candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]
    assert candidate('(()(())((())))') == [4]

```

**Dafny Solution Code (that these tests should test):**
```dafny
method parse_nested_parens(paren_string: string) returns (result: seq<int>)
    ensures |result| >= 0
    ensures forall i :: 0 <= i < |result| ==> result[i] >= 0
{
    var groups := split_by_spaces(paren_string);
    result := [];
    
    var i := 0;
    while i < |groups|
        invariant 0 <= i <= |groups|
        invariant |result| == i
        invariant forall j :: 0 <= j < i ==> result[j] >= 0
        decreases |groups| - i
    {
        var max_depth := calculate_max_depth(groups[i]);
        result := result + [max_depth];
        i := i + 1;
    }
}

method split_by_spaces(s: string) returns (groups: seq<string>)
    ensures |groups| >= 0
{
    groups := [];
    if |s| == 0 {
        return;
    }
    
    var start := 0;
    var i := 0;
    
    // Skip leading spaces
    while i < |s| && s[i] == ' '
        invariant 0 <= i <= |s|
        decreases |s| - i
    {
        i := i + 1;
    }
    
    start := i;
    
    while i <= |s|
        invariant start <= i <= |s|
        invariant start <= |s|
        decreases |s| - i + 1
    {
        if i == |s| || s[i] == ' ' {
            if start < i {
                groups := groups + [s[start..i]];
            }
            // Skip spaces
            while i < |s| && s[i] == ' '
                invariant start <= i <= |s|
                decreases |s| - i
            {
                i := i + 1;
            }
            start := i;
        } else {
            i := i + 1;
        }
    }
}

method calculate_max_depth(group: string) returns (max_depth: int)
    ensures max_depth >= 0
{
    var current_depth := 0;
    max_depth := 0;
    
    var i := 0;
    while i < |group|
        invariant 0 <= i <= |group|
        invariant current_depth >= 0
        invariant max_depth >= 0
        invariant max_depth >= current_depth
        decreases |group| - i
    {
        if group[i] == '(' {
            current_depth := current_depth + 1;
            if current_depth > max_depth {
                max_depth := current_depth;
            }
        } else if group[i] == ')' {
            if current_depth > 0 {
                current_depth := current_depth - 1;
            }
        }
        i := i + 1;
    }
}
```

**Your Task:**
1. **Analyze the tests and solution:**
   - Note the exact name (`parse_nested_parens`) and signature of the Dafny method from the provided solution code.

2. **Create a minimal dummy implementation** (in a `<dummy>` block):
   - Create a dummy version of the `parse_nested_parens` Dafny method.
   - The dummy should have the same signature as the method in the full Dafny solution and return appropriate default values (0 for int, false for bool, [] for sequences, etc.).
   - This dummy is ONLY for validating that the test code compiles correctly.

3. **Translate the tests** (in a ```dafny ... ``` block):
   - For each `assert` statement in the Python code, create a Dafny test method with `{:test}` attribute.
   - **All generated test methods must have a complete body and be runnable.**
   - Name them `test_0`, `test_1`, etc.
   - Convert scientific notation (e.g., 1e-6) to decimal form (e.g., 0.000001).
   - Each test method should:
     a. Call the `parse_nested_parens` Dafny method and assign the result to a variable.
     b. Use `expect` to check if the result matches the expected value.

**Example:** If Python has `assert add(2, 3) == 5`, the method to test is `add`, and the Dafny solution has `function add(a: int, b: int): int`, then:
<dummy>
function add(a: int, b: int): int
{
    0
}
</dummy>

```dafny
method {:test} test_0()
{
    var result := add(2, 3);
    expect result == 5;
}
```



=============== ASSISTANT ===============
--- THINKING ---
Let me analyze the Python test code and the Dafny solution.

The Python tests are:
1. `assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]`
2. `assert candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]`
3. `assert candidate('(()(())((())))') == [4]`

The Dafny method to test is `parse_nested_parens` with the signature:
```dafny
method parse_nested_parens(paren_string: string) returns (result: seq<int>)
```

So I need to:
1. Create a dummy implementation of `parse_nested_parens` that returns a `seq<int>`
2. Create test methods that call `parse_nested_parens` and use `expect` to check the results

For the dummy implementation, I'll just return an empty sequence `[]` which is a valid default for `seq<int>`.

For the tests, I need to convert each assert into a Dafny test method:
- test_0: `parse_nested_parens('(()()) ((())) () ((())()())')` should return `[2, 3, 1, 3]`
- test_1: `parse_nested_parens('() (()) ((())) (((())))');` should return `[1, 2, 3, 4]`
- test_2: `parse_nested_parens('(()(())((())))');` should return `[4]`

--- RESPONSE ---
Looking at the Python tests and the Dafny solution, I can see that:

1. The method to test is `parse_nested_parens` which takes a string and returns a sequence of integers
2. The tests check that the method correctly parses nested parentheses and returns the maximum depth for each group

<dummy>
method parse_nested_parens(paren_string: string) returns (result: seq<int>)
{
    result := [];
}
</dummy>

```dafny
method {:test} test_0()
{
    var result := parse_nested_parens("(()()) ((())) () ((())()())");
    expect result == [2, 3, 1, 3];
}

method {:test} test_1()
{
    var result := parse_nested_parens("() (()) ((())) (((())))");
    expect result == [1, 2, 3, 4];
}

method {:test} test_2()
{
    var result := parse_nested_parens("(()(())((())))");
    expect result == [4];
}
```

