=============== SYSTEM ===============
You are an expert programmer specializing in translating Python code to the Dafny verification language. Your task is to translate the provided Python function into a Dafny method that is both verifiable and compilable. Pay close attention to types, specifications, and providing concrete implementations for all methods.



=============== USER ===============
I will provide you with a Python function and its documentation. Please translate the Python function into a Dafny method.

**Python Function and Documentation:**
```python


def sum_to_n(n: int):
    """sum_to_n is a function that sums numbers from 1 to n.
    >>> sum_to_n(30)
    465
    >>> sum_to_n(100)
    5050
    >>> sum_to_n(5)
    15
    >>> sum_to_n(10)
    55
    >>> sum_to_n(1)
    1
    """

def sum_to_n(n: int):
    """sum_to_n is a function that sums numbers from 1 to n.
    >>> sum_to_n(30)
    465
    >>> sum_to_n(100)
    5050
    >>> sum_to_n(5)
    15
    >>> sum_to_n(10)
    55
    >>> sum_to_n(1)
    1
    """
    return n * (n + 1) // 2
```

**Your Task:**
1.  **Reasoning (in a <thinking> block):**
    *   Analyze the Python code and its types. How will you map Python types (like lists of floats) to Dafny types (like `seq<real>`)?
    *   Analyze the function's logic. What are the pre-conditions (`requires`) and post-conditions (`ensures`)?
    *   Identify any loops and determine their invariants.
    *   Think about termination conditions for any recursive calls or loops.
2.  **Dafny Implementation (in a ```dafny ... ``` block):**
    *   Write the complete Dafny method, including its signature, `requires` clauses, `ensures` clauses, and the method body.
    *   **The return type of the main method must be a basic Dafny type.** Use `int`, `real`, `bool`, `string`, or a sequence of these types (e.g., `seq<int>`). Do not use custom `datatype`s in the return signature. If the Python code implies an optional return (e.g. returning `None`), you should return a sensible default for the basic type instead (e.g. `false`, `-1`, or an empty sequence `[]`).
    *   The Dafny method name must be exactly the same as the Python function name: `sum_to_n`. Do not change the casing.
    *   **All methods must have a concrete implementation (a body).** The `{:axiom}` attribute is forbidden for defining standard functions. However, if the problem's solution relies on an unproven mathematical conjecture (e.g., the Goldbach Conjecture, P vs NP), you may state the conjecture as an `axiom`. If you do so, you **must** include a comment identifying the conjecture (e.g., `// Axiom for the Twin Prime Conjecture`). Do not use axioms to avoid implementing solvable algorithms.
    *   **Provide explicit termination proofs.** For any recursive function, you must include a `decreases` clause. Do **not** use `decreases *`. For functions that operate on a sequence, the termination metric is almost always the length of the sequence (e.g., `decreases my_sequence`). For functions on integers, it is the integer itself (e.g., `decreases n`).
    *   **Do not use Dafny reserved keywords as variable names.** Avoid names like: `abstract, allocated, as, assert, assume, bool, break, by, calc, case, char, class, codatatype, const, constructor, datatype, decreases, else, ensures, exists, export, extends, false, forall, fresh, function, ghost, if, imap, import, in, include, int, invariant, is, iset, iterator, label, lemma, map, match, method, modifies, modify, module, multiset, nameonly, nat, new, newtype, null, object, object?, old, opened, ORDINAL, predicate, print, provides,reads, real, refines, requires, return, returns, reveal, reveals, seq, set, static, string, then, this, trait, true, twostate, type, unchanged, var, while, witness, yield, yields`. For example, instead of `var array`, use `var arr`.



=============== ASSISTANT ===============
--- THINKING ---
Let me analyze the Python function first:

1. The function `sum_to_n(n: int)` computes the sum of integers from 1 to n.
2. It uses the mathematical formula: sum = n * (n + 1) / 2
3. The Python function returns `n * (n + 1) // 2` where `//` is integer division.

Let me think about the Dafny translation:

**Types:**
- `n: int` in Python maps to `n: int` in Dafny
- The return type should be `int` in Dafny

**Preconditions:**
- We should probably require `n >= 0` to make sense mathematically, though the formula works for negative numbers too. Let me check the examples:
  - All examples use positive integers (1, 5, 10, 30, 100)
  - The formula `n * (n + 1) / 2` actually works for any integer, but the interpretation "sum from 1 to n" only makes sense for n >= 1
  - For n = 0, the sum should be 0 (empty sum)
  - For n < 0, the traditional interpretation doesn't make sense, but mathematically the formula still works

Let me be more permissive and allow any integer, but I should ensure the postcondition is correct.

**Postconditions:**
- The result should be `n * (n + 1) / 2`
- In Dafny, I need to be careful about integer division. The Python `//` operator is floor division.
- Since `n * (n + 1)` is always even (either n or n+1 is even), the division by 2 will always be exact.

**Implementation:**
- Direct translation: `return n * (n + 1) / 2;`
- In Dafny, `/` is integer division (like `//` in Python) when both operands are integers.


I've verified the calculations match the expected results. Each example demonstrates the formula's correctness:
- 30 yields 465
- 100 produces 5050
- 5 results in 15
- 10 gives 55

These computations confirm the mathematical formula consistently generates the correct sum of consecutive integers from 1 to n.

The function handles edge cases thoughtfully:
- Zero input returns zero
- Mathematically, the formula works even for negative inputs, though conceptually nonsensical

I'll maintain the precondition of n >= 0 to ensure meaningful summation while preserving mathematical flexibility.

The implementation appears robust and elegant, avoiding complex looping or recursive approaches.

Critically, the formula ensures precise division by leveraging the mathematical property that n * (n + 1) is always divisible by 2, guaranteeing an exact result across all valid inputs.

--- RESPONSE ---
<thinking>
Let me analyze the Python function:

1. **Function Analysis**: The function `sum_to_n(n: int)` calculates the sum of integers from 1 to n using the mathematical formula: n * (n + 1) / 2. This is a well-known closed-form formula for arithmetic series.

2. **Type Mapping**: 
   - `n: int` in Python maps to `n: int` in Dafny
   - Return type should be `int` in Dafny

3. **Preconditions**: 
   - The examples show positive integers (1, 5, 10, 30, 100)
   - The formula works for any integer, but "sum from 1 to n" conceptually makes sense for n ≥ 0
   - For n = 0, it should return 0 (empty sum), and 0 * 1 / 2 = 0 works
   - I'll require n ≥ 0 to be safe

4. **Postconditions**:
   - The result should equal n * (n + 1) / 2
   - Since either n or (n+1) is even, n * (n + 1) is always divisible by 2, so integer division is exact

5. **Implementation**: Direct translation using the formula. No loops or recursion needed.

6. **Verification**: Let me check the examples:
   - sum_to_n(30) = 30 * 31 / 2 = 465 ✓
   - sum_to_n(100) = 100 * 101 / 2 = 5050 ✓
   - sum_to_n(5) = 5 * 6 / 2 = 15 ✓
   - sum_to_n(10) = 10 * 11 / 2 = 55 ✓  
   - sum_to_n(1) = 1 * 2 / 2 = 1 ✓
</thinking>

```dafny
method sum_to_n(n: int) returns (result: int)
    requires n >= 0
    ensures result == n * (n + 1) / 2
{
    result := n * (n + 1) / 2;
}
```

