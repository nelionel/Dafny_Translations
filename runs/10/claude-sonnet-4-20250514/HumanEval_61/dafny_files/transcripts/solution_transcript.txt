=============== SYSTEM ===============
You are an expert programmer specializing in translating Python code to the Dafny verification language. Your task is to translate the provided Python function into a Dafny method that is both verifiable and compilable. Pay close attention to types, specifications, and providing concrete implementations for all methods.



=============== USER ===============
I will provide you with a Python function and its documentation. Please translate the Python function into a Dafny method.

**Python Function and Documentation:**
```python


def correct_bracketing(brackets: str):
    """ brackets is a string of "(" and ")".
    return True if every opening bracket has a corresponding closing bracket.

    >>> correct_bracketing("(")
    False
    >>> correct_bracketing("()")
    True
    >>> correct_bracketing("(()())")
    True
    >>> correct_bracketing(")(()")
    False
    """

def correct_bracketing(brackets: str):
    """ brackets is a string of "(" and ")".
    return True if every opening bracket has a corresponding closing bracket.

    >>> correct_bracketing("(")
    False
    >>> correct_bracketing("()")
    True
    >>> correct_bracketing("(()())")
    True
    >>> correct_bracketing(")(()")
    False
    """
    count = 0
    
    for bracket in brackets:
        if bracket == "(":
            count += 1
        elif bracket == ")":
            count -= 1
            # If count goes negative, we have more closing than opening brackets
            if count < 0:
                return False
    
    # All brackets should be matched (count should be 0)
    return count == 0
```

**Your Task:**
1.  **Reasoning (in a <thinking> block):**
    *   Analyze the Python code and its types. How will you map Python types (like lists of floats) to Dafny types (like `seq<real>`)?
    *   Analyze the function's logic. What are the pre-conditions (`requires`) and post-conditions (`ensures`)?
    *   Identify any loops and determine their invariants.
    *   Think about termination conditions for any recursive calls or loops.
2.  **Dafny Implementation (in a ```dafny ... ``` block):**
    *   Write the complete Dafny method, including its signature, `requires` clauses, `ensures` clauses, and the method body.
    *   **The return type of the main method must be a basic Dafny type.** Use `int`, `real`, `bool`, `string`, or a sequence of these types (e.g., `seq<int>`). Do not use custom `datatype`s in the return signature. If the Python code implies an optional return (e.g. returning `None`), you should return a sensible default for the basic type instead (e.g. `false`, `-1`, or an empty sequence `[]`).
    *   The Dafny method name must be exactly the same as the Python function name: `correct_bracketing`. Do not change the casing.
    *   **All methods must have a concrete implementation (a body).** The `{:axiom}` attribute is forbidden for defining standard functions. However, if the problem's solution relies on an unproven mathematical conjecture (e.g., the Goldbach Conjecture, P vs NP), you may state the conjecture as an `axiom`. If you do so, you **must** include a comment identifying the conjecture (e.g., `// Axiom for the Twin Prime Conjecture`). Do not use axioms to avoid implementing solvable algorithms.
    *   **Provide explicit termination proofs.** For any recursive function, you must include a `decreases` clause. Do **not** use `decreases *`. For functions that operate on a sequence, the termination metric is almost always the length of the sequence (e.g., `decreases my_sequence`). For functions on integers, it is the integer itself (e.g., `decreases n`).
    *   **Do not use Dafny reserved keywords as variable names.** Avoid names like: `abstract, allocated, as, assert, assume, bool, break, by, calc, case, char, class, codatatype, const, constructor, datatype, decreases, else, ensures, exists, export, extends, false, forall, fresh, function, ghost, if, imap, import, in, include, int, invariant, is, iset, iterator, label, lemma, map, match, method, modifies, modify, module, multiset, nameonly, nat, new, newtype, null, object, object?, old, opened, ORDINAL, predicate, print, provides,reads, real, refines, requires, return, returns, reveal, reveals, seq, set, static, string, then, this, trait, true, twostate, type, unchanged, var, while, witness, yield, yields`. For example, instead of `var array`, use `var arr`.



=============== ASSISTANT ===============
--- THINKING ---
Let me analyze the Python function first:

1. **Function signature**: `correct_bracketing(brackets: str) -> bool` (implicit return type)
2. **Logic**: It checks if brackets are correctly matched by:
   - Keeping a count of open brackets
   - Incrementing count for each "("
   - Decrementing count for each ")"
   - If count goes negative at any point, return False (more closing than opening)
   - At the end, return True if count is 0 (all brackets matched)

**Mapping to Dafny:**
- `str` in Python maps to `string` in Dafny
- The function returns `bool`, which maps directly to `bool` in Dafny
- We'll need to iterate through the string characters

**Pre-conditions and post-conditions:**
- Pre-condition: The input string should only contain '(' and ')' characters (though the original doesn't enforce this, I should consider whether to add this constraint)
- Post-condition: The method returns true if and only if the brackets are properly matched

**Loop invariants:**
- The count variable represents the number of unmatched opening brackets at any point
- The count should never go negative during valid bracket sequences
- If we've processed i characters, count represents the balance of brackets in the first i characters

**Termination:**
- The loop will terminate because we're iterating through a finite string
- We can use `decreases |brackets| - i` where i is the loop index

Let me write the Dafny code:

```dafny
method correct_bracketing(brackets: string) returns (result: bool)
{
    var count := 0;
    var i := 0;
    
    while i < |brackets|
        invariant 0 <= i <= |brackets|
        invariant count >= 0 ==> (forall j :: 0 <= j < i ==> brackets[j] == '(' || brackets[j] == ')')
        decreases |brackets| - i
    {
        if brackets[i] == '(' {
            count := count + 1;
        } else if brackets[i] == ')' {
            count := count - 1;
            if count < 0 {
                return false;
            }
        }
        i := i + 1;
    }
    
    result := count == 0;
}
```

I'm refining my understanding of the invariants. The key insights are about maintaining the bracket balance and ensuring valid character constraints. The method tracks unmatched opening brackets, immediately detecting invalid sequences by checking the count's negativity. The final check ensures complete bracket matching by verifying the count reaches zero.

The core logic ensures that:
- Opening brackets increment the count
- Closing brackets decrement the count
- Negative count triggers immediate invalidation
- Final zero count confirms perfect bracketing

--- RESPONSE ---
<thinking>
Let me analyze the Python function:

1. **Function signature**: `correct_bracketing(brackets: str) -> bool` (return type inferred from logic)
2. **Logic**: It maintains a counter to track bracket balance:
   - Increment for each "("
   - Decrement for each ")"
   - Return False immediately if counter goes negative (more closing than opening brackets at any point)
   - Return True if counter is 0 at the end (all brackets matched)

**Mapping to Dafny:**
- `str` maps to `string`
- Return type is `bool`
- Need to iterate through string characters with a while loop

**Pre/Post-conditions:**
- No explicit pre-conditions needed (function should handle any string)
- Post-condition: returns true iff brackets are properly matched

**Loop invariants:**
- Loop index bounds: `0 <= i <= |brackets|`
- Counter non-negative: `count >= 0` (because we return false as soon as it goes negative)

**Termination:**
- Loop terminates because we increment `i` each iteration until `i >= |brackets|`
- Use `decreases |brackets| - i`
</thinking>

```dafny
method correct_bracketing(brackets: string) returns (result: bool)
{
    var count := 0;
    var i := 0;
    
    while i < |brackets|
        invariant 0 <= i <= |brackets|
        invariant count >= 0
        decreases |brackets| - i
    {
        if brackets[i] == '(' {
            count := count + 1;
        } else if brackets[i] == ')' {
            count := count - 1;
            if count < 0 {
                return false;
            }
        }
        i := i + 1;
    }
    
    result := count == 0;
}
```

