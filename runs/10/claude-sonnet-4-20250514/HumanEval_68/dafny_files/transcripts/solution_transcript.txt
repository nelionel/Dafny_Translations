=============== SYSTEM ===============
You are an expert programmer specializing in translating Python code to the Dafny verification language. Your task is to translate the provided Python function into a Dafny method that is both verifiable and compilable. Pay close attention to types, specifications, and providing concrete implementations for all methods.



=============== USER ===============
I will provide you with a Python function and its documentation. Please translate the Python function into a Dafny method.

**Python Function and Documentation:**
```python

def pluck(arr):
    """
    "Given an array representing a branch of a tree that has non-negative integer nodes
    your task is to pluck one of the nodes and return it.
    The plucked node should be the node with the smallest even value.
    If multiple nodes with the same smallest even value are found return the node that has smallest index.

    The plucked node should be returned in a list, [ smalest_value, its index ],
    If there are no even values or the given array is empty, return [].

    Example 1:
        Input: [4,2,3]
        Output: [2, 1]
        Explanation: 2 has the smallest even value, and 2 has the smallest index.

    Example 2:
        Input: [1,2,3]
        Output: [2, 1]
        Explanation: 2 has the smallest even value, and 2 has the smallest index. 

    Example 3:
        Input: []
        Output: []
    
    Example 4:
        Input: [5, 0, 3, 0, 4, 2]
        Output: [0, 1]
        Explanation: 0 is the smallest value, but  there are two zeros,
                     so we will choose the first zero, which has the smallest index.

    Constraints:
        * 1 <= nodes.length <= 10000
        * 0 <= node.value
    """

def pluck(arr):
    """
    "Given an array representing a branch of a tree that has non-negative integer nodes
    your task is to pluck one of the nodes and return it.
    The plucked node should be the node with the smallest even value.
    If multiple nodes with the same smallest even value are found return the node that has smallest index.

    The plucked node should be returned in a list, [ smalest_value, its index ],
    If there are no even values or the given array is empty, return [].
    """
    if not arr:
        return []
    
    smallest_even = None
    smallest_index = None
    
    for i, value in enumerate(arr):
        if value % 2 == 0:  # Check if the value is even
            if smallest_even is None or value < smallest_even:
                smallest_even = value
                smallest_index = i
            elif value == smallest_even and i < smallest_index:
                # This case actually won't happen since we iterate left to right
                # and we only update when we find a smaller value
                smallest_index = i
    
    if smallest_even is None:
        return []
    
    return [smallest_even, smallest_index]
```

**Your Task:**
1.  **Reasoning (in a <thinking> block):**
    *   Analyze the Python code and its types. How will you map Python types (like lists of floats) to Dafny types (like `seq<real>`)?
    *   Analyze the function's logic. What are the pre-conditions (`requires`) and post-conditions (`ensures`)?
    *   Identify any loops and determine their invariants.
    *   Think about termination conditions for any recursive calls or loops.
2.  **Dafny Implementation (in a ```dafny ... ``` block):**
    *   Write the complete Dafny method, including its signature, `requires` clauses, `ensures` clauses, and the method body.
    *   **The return type of the main method must be a basic Dafny type.** Use `int`, `real`, `bool`, `string`, or a sequence of these types (e.g., `seq<int>`). Do not use custom `datatype`s in the return signature. If the Python code implies an optional return (e.g. returning `None`), you should return a sensible default for the basic type instead (e.g. `false`, `-1`, or an empty sequence `[]`).
    *   The Dafny method name must be exactly the same as the Python function name: `pluck`. Do not change the casing.
    *   **All methods must have a concrete implementation (a body).** The `{:axiom}` attribute is forbidden for defining standard functions. However, if the problem's solution relies on an unproven mathematical conjecture (e.g., the Goldbach Conjecture, P vs NP), you may state the conjecture as an `axiom`. If you do so, you **must** include a comment identifying the conjecture (e.g., `// Axiom for the Twin Prime Conjecture`). Do not use axioms to avoid implementing solvable algorithms.
    *   **Provide explicit termination proofs.** For any recursive function, you must include a `decreases` clause. Do **not** use `decreases *`. For functions that operate on a sequence, the termination metric is almost always the length of the sequence (e.g., `decreases my_sequence`). For functions on integers, it is the integer itself (e.g., `decreases n`).
    *   **Do not use Dafny reserved keywords as variable names.** Avoid names like: `abstract, allocated, as, assert, assume, bool, break, by, calc, case, char, class, codatatype, const, constructor, datatype, decreases, else, ensures, exists, export, extends, false, forall, fresh, function, ghost, if, imap, import, in, include, int, invariant, is, iset, iterator, label, lemma, map, match, method, modifies, modify, module, multiset, nameonly, nat, new, newtype, null, object, object?, old, opened, ORDINAL, predicate, print, provides,reads, real, refines, requires, return, returns, reveal, reveals, seq, set, static, string, then, this, trait, true, twostate, type, unchanged, var, while, witness, yield, yields`. For example, instead of `var array`, use `var arr`.



=============== ASSISTANT ===============
--- THINKING ---
Let me analyze the Python function:

1. The function takes an array of non-negative integers.
2. It finds the smallest even value in the array.
3. If there are multiple instances of the smallest even value, it returns the one with the smallest index (though the comment in the code mentions this scenario won't happen because of the iteration order).
4. It returns a list containing [smallest_even_value, its_index] or an empty list if no even values exist or the array is empty.

For Dafny translation:

1. **Types**: 
   - Input: `seq<int>` (sequence of integers)
   - Output: `seq<int>` (sequence containing either 2 elements or empty)

2. **Logic**:
   - Check if array is empty -> return empty sequence
   - Iterate through array, find smallest even value and its index
   - Return [value, index] or empty sequence

3. **Pre-conditions**: 
   - All values in the array should be non-negative (based on constraints)

4. **Post-conditions**:
   - If result is empty, then either input was empty or no even values exist
   - If result has 2 elements, first element is the smallest even value from input, second is its index
   - The index should be valid (0 <= index < |arr|)
   - The value at that index should be even
   - The value should be the minimum among all even values

5. **Loop invariants**:
   - Need to track the current smallest even value and its index
   - Ensure we've checked all elements up to current position

Let me write the Dafny code:

--- RESPONSE ---
<thinking>
Let me analyze the Python function:

1. **Types**: The function takes a list of integers and returns either an empty list or a list with two integers [value, index].
2. **Logic**: Find the smallest even value in the array, and if multiple exist with the same value, return the one with the smallest index.
3. **Edge cases**: Empty array or no even values return empty list.

For Dafny translation:
- Input: `seq<int>` (sequence of integers)  
- Output: `seq<int>` (either empty or length 2)
- Need loop invariants to track the smallest even value found so far and its index
- Pre-condition: all values are non-negative (from constraints)
- Post-conditions: validate the result is correct

The loop will iterate through the sequence, maintaining the smallest even value and its index found so far.
</thinking>

```dafny
method pluck(arr: seq<int>) returns (result: seq<int>)
    requires forall i :: 0 <= i < |arr| ==> arr[i] >= 0
    ensures |result| == 0 || |result| == 2
    ensures |result| == 0 ==> (|arr| == 0 || forall i :: 0 <= i < |arr| ==> arr[i] % 2 == 1)
    ensures |result| == 2 ==> (
        0 <= result[1] < |arr| &&
        arr[result[1]] == result[0] &&
        result[0] % 2 == 0 &&
        forall i :: 0 <= i < |arr| && arr[i] % 2 == 0 ==> result[0] <= arr[i] &&
        forall i :: 0 <= i < |arr| && arr[i] % 2 == 0 && arr[i] == result[0] ==> result[1] <= i
    )
{
    if |arr| == 0 {
        return [];
    }
    
    var smallestEven: int := -1;
    var smallestIndex: int := -1;
    var found: bool := false;
    
    var i: int := 0;
    while i < |arr|
        invariant 0 <= i <= |arr|
        invariant found ==> (
            0 <= smallestIndex < i &&
            arr[smallestIndex] == smallestEven &&
            smallestEven % 2 == 0 &&
            forall j :: 0 <= j < i && arr[j] % 2 == 0 ==> smallestEven <= arr[j] &&
            forall j :: 0 <= j < i && arr[j] % 2 == 0 && arr[j] == smallestEven ==> smallestIndex <= j
        )
        invariant !found ==> forall j :: 0 <= j < i ==> arr[j] % 2 == 1
        decreases |arr| - i
    {
        if arr[i] % 2 == 0 {
            if !found || arr[i] < smallestEven {
                smallestEven := arr[i];
                smallestIndex := i;
                found := true;
            }
        }
        i := i + 1;
    }
    
    if !found {
        return [];
    } else {
        return [smallestEven, smallestIndex];
    }
}
```

