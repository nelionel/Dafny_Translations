=============== SYSTEM ===============
You are an expert programmer specializing in translating Python code to the Dafny verification language. Your task is to translate the provided Python function into a Dafny method that is both verifiable and compilable. Pay close attention to types, specifications, and providing concrete implementations for all methods.



=============== USER ===============
I will provide you with a Python function and its documentation. Please translate the Python function into a Dafny method.

**Python Function and Documentation:**
```python
from typing import List


def filter_by_substring(strings: List[str], substring: str) -> List[str]:
    """ Filter an input list of strings only for ones that contain given substring
    >>> filter_by_substring([], 'a')
    []
    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')
    ['abc', 'bacd', 'array']
    """

from typing import List


def filter_by_substring(strings: List[str], substring: str) -> List[str]:
    """ Filter an input list of strings only for ones that contain given substring
    >>> filter_by_substring([], 'a')
    []
    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')
    ['abc', 'bacd', 'array']
    """
    return [string for string in strings if substring in string]
```

**Your Task:**
1.  **Reasoning (in a <thinking> block):**
    *   Analyze the Python code and its types. How will you map Python types (like lists of floats) to Dafny types (like `seq<real>`)?
    *   Analyze the function's logic. What are the pre-conditions (`requires`) and post-conditions (`ensures`)?
    *   Identify any loops and determine their invariants.
    *   Think about termination conditions for any recursive calls or loops.
2.  **Dafny Implementation (in a ```dafny ... ``` block):**
    *   Write the complete Dafny method, including its signature, `requires` clauses, `ensures` clauses, and the method body.
    *   **The return type of the main method must be a basic Dafny type.** Use `int`, `real`, `bool`, `string`, or a sequence of these types (e.g., `seq<int>`). Do not use custom `datatype`s in the return signature. If the Python code implies an optional return (e.g. returning `None`), you should return a sensible default for the basic type instead (e.g. `false`, `-1`, or an empty sequence `[]`).
    *   The Dafny method name must be exactly the same as the Python function name: `filter_by_substring`. Do not change the casing.
    *   **All methods must have a concrete implementation (a body).** The `{:axiom}` attribute is forbidden for defining standard functions. However, if the problem's solution relies on an unproven mathematical conjecture (e.g., the Goldbach Conjecture, P vs NP), you may state the conjecture as an `axiom`. If you do so, you **must** include a comment identifying the conjecture (e.g., `// Axiom for the Twin Prime Conjecture`). Do not use axioms to avoid implementing solvable algorithms.
    *   **Provide explicit termination proofs.** For any recursive function, you must include a `decreases` clause. Do **not** use `decreases *`. For functions that operate on a sequence, the termination metric is almost always the length of the sequence (e.g., `decreases my_sequence`). For functions on integers, it is the integer itself (e.g., `decreases n`).
    *   **Do not use Dafny reserved keywords as variable names.** Avoid names like: `abstract, allocated, as, assert, assume, bool, break, by, calc, case, char, class, codatatype, const, constructor, datatype, decreases, else, ensures, exists, export, extends, false, forall, fresh, function, ghost, if, imap, import, in, include, int, invariant, is, iset, iterator, label, lemma, map, match, method, modifies, modify, module, multiset, nameonly, nat, new, newtype, null, object, object?, old, opened, ORDINAL, predicate, print, provides,reads, real, refines, requires, return, returns, reveal, reveals, seq, set, static, string, then, this, trait, true, twostate, type, unchanged, var, while, witness, yield, yields`. For example, instead of `var array`, use `var arr`.



=============== ASSISTANT ===============
--- THINKING ---
Let me analyze the Python function first:
- It takes a list of strings and a substring
- It returns a list of strings that contain the given substring
- It uses a list comprehension to filter strings

Mapping to Dafny:
- List[str] -> seq<string>
- str -> string

Logic analysis:
- The function filters strings based on whether they contain a substring
- Pre-conditions: No specific requirements needed
- Post-conditions: 
  - The result should be a subsequence of the input
  - All strings in the result should contain the substring
  - All strings from input that contain the substring should be in the result

Since this involves checking if a string contains a substring, I need to implement a helper function to check if one string is a substring of another.

For the main method, I'll need to iterate through the input sequence and build a result sequence.

Let me think about the termination condition - since I'll be iterating through the sequence, I can use a decreases clause based on the remaining elements to process.

Actually, let me implement this recursively or iteratively. I think iteratively might be cleaner.

I need to implement a helper to check if a string contains a substring. In Dafny, I can check this by looking for the substring at each position.

--- RESPONSE ---
<thinking>
Let me analyze the Python function:

1. **Types mapping**: 
   - `List[str]` maps to `seq<string>` in Dafny
   - `str` maps to `string` in Dafny

2. **Function logic**:
   - Takes a sequence of strings and a substring
   - Returns a new sequence containing only strings that contain the given substring
   - Uses Python's `in` operator to check if substring is contained in each string

3. **Pre-conditions**: No specific requirements needed

4. **Post-conditions**:
   - Result should only contain strings from the input that contain the substring
   - All strings in the result should contain the substring
   - The order should be preserved

5. **Implementation approach**:
   - I'll need a helper method to check if a string contains a substring
   - Then iterate through the input sequence and build the result
   - For termination, I can use an iterative approach with a while loop

6. **Helper method needed**: A method to check if one string contains another as a substring
</thinking>

```dafny
method contains_substring(s: string, sub: string) returns (result: bool)
  ensures result <==> exists i :: 0 <= i <= |s| - |sub| && s[i..i+|sub|] == sub
{
  if |sub| > |s| {
    return false;
  }
  
  var i := 0;
  while i <= |s| - |sub|
    invariant 0 <= i <= |s| - |sub| + 1
    invariant forall j :: 0 <= j < i ==> s[j..j+|sub|] != sub
  {
    if s[i..i+|sub|] == sub {
      return true;
    }
    i := i + 1;
  }
  return false;
}

method filter_by_substring(strings: seq<string>, substring: string) returns (result: seq<string>)
  ensures forall s :: s in result ==> s in strings
  ensures forall s :: s in result ==> exists i :: 0 <= i <= |s| - |substring| && s[i..i+|substring|] == substring
  ensures forall s :: s in strings && (exists i :: 0 <= i <= |s| - |substring| && s[i..i+|substring|] == substring) ==> s in result
{
  result := [];
  var i := 0;
  
  while i < |strings|
    invariant 0 <= i <= |strings|
    invariant forall s :: s in result ==> s in strings
    invariant forall s :: s in result ==> exists j :: 0 <= j <= |s| - |substring| && s[j..j+|substring|] == substring
    invariant forall k :: 0 <= k < i ==> (strings[k] in result <==> exists j :: 0 <= j <= |strings[k]| - |substring| && strings[k][j..j+|substring|] == substring)
  {
    var contains := contains_substring(strings[i], substring);
    if contains {
      result := result + [strings[i]];
    }
    i := i + 1;
  }
}
```

