=============== SYSTEM ===============
You are an expert programmer specializing in translating Python tests to the Dafny verification language. Your task is to translate Python `assert` statements into Dafny test methods and provide a minimal dummy implementation for compilation checking.



=============== USER ===============
I need you to translate Python test assertions into Dafny test methods.

**The Method to Test:**
The Dafny method you need to test is named `filter_by_substring`.

**Python Test Code:**
```python


METADATA = {
    'author': 'jt',
    'dataset': 'test'
}


def check(candidate):
    assert candidate([], 'john') == []
    assert candidate(['xxx', 'asd', 'xxy', 'john doe', 'xxxAAA', 'xxx'], 'xxx') == ['xxx', 'xxxAAA', 'xxx']
    assert candidate(['xxx', 'asd', 'aaaxxy', 'john doe', 'xxxAAA', 'xxx'], 'xx') == ['xxx', 'aaaxxy', 'xxxAAA', 'xxx']
    assert candidate(['grunt', 'trumpet', 'prune', 'gruesome'], 'run') == ['grunt', 'prune']

```

**Dafny Solution Code (that these tests should test):**
```dafny
method contains_substring(s: string, sub: string) returns (result: bool)
  ensures result <==> exists i :: 0 <= i <= |s| - |sub| && s[i..i+|sub|] == sub
{
  if |sub| > |s| {
    return false;
  }
  
  var i := 0;
  while i <= |s| - |sub|
    invariant 0 <= i <= |s| - |sub| + 1
    invariant forall j :: 0 <= j < i ==> s[j..j+|sub|] != sub
  {
    if s[i..i+|sub|] == sub {
      return true;
    }
    i := i + 1;
  }
  return false;
}

method filter_by_substring(strings: seq<string>, substring: string) returns (result: seq<string>)
  ensures forall s :: s in result ==> s in strings
  ensures forall s :: s in result ==> exists i :: 0 <= i <= |s| - |substring| && s[i..i+|substring|] == substring
  ensures forall s :: s in strings && (exists i :: 0 <= i <= |s| - |substring| && s[i..i+|substring|] == substring) ==> s in result
{
  result := [];
  var i := 0;
  
  while i < |strings|
    invariant 0 <= i <= |strings|
    invariant forall s :: s in result ==> s in strings
    invariant forall s :: s in result ==> exists j :: 0 <= j <= |s| - |substring| && s[j..j+|substring|] == substring
    invariant forall k :: 0 <= k < i ==> (strings[k] in result <==> exists j :: 0 <= j <= |strings[k]| - |substring| && strings[k][j..j+|substring|] == substring)
  {
    var contains := contains_substring(strings[i], substring);
    if contains {
      result := result + [strings[i]];
    }
    i := i + 1;
  }
}
```

**Your Task:**
1. **Analyze the tests and solution:**
   - Note the exact name (`filter_by_substring`) and signature of the Dafny method from the provided solution code.

2. **Create a minimal dummy implementation** (in a `<dummy>` block):
   - Create a dummy version of the `filter_by_substring` Dafny method.
   - The dummy should have the same signature as the method in the full Dafny solution and return appropriate default values (0 for int, false for bool, [] for sequences, etc.).
   - This dummy is ONLY for validating that the test code compiles correctly.

3. **Translate the tests** (in a ```dafny ... ``` block):
   - For each `assert` statement in the Python code, create a Dafny test method with `{:test}` attribute.
   - **All generated test methods must have a complete body and be runnable.**
   - Name them `test_0`, `test_1`, etc.
   - Convert scientific notation (e.g., 1e-6) to decimal form (e.g., 0.000001).
   - Each test method should:
     a. Call the `filter_by_substring` Dafny method and assign the result to a variable.
     b. Use `expect` to check if the result matches the expected value.

**Example:** If Python has `assert add(2, 3) == 5`, the method to test is `add`, and the Dafny solution has `function add(a: int, b: int): int`, then:
<dummy>
function add(a: int, b: int): int
{
    0
}
</dummy>

```dafny
method {:test} test_0()
{
    var result := add(2, 3);
    expect result == 5;
}
```



=============== ASSISTANT ===============
--- THINKING ---
Let me analyze the Python tests and Dafny solution:

1. The method to test is `filter_by_substring`
2. From the Dafny solution, I can see the signature:
   ```dafny
   method filter_by_substring(strings: seq<string>, substring: string) returns (result: seq<string>)
   ```

3. The Python tests are:
   - `candidate([], 'john') == []`
   - `candidate(['xxx', 'asd', 'xxy', 'john doe', 'xxxAAA', 'xxx'], 'xxx') == ['xxx', 'xxxAAA', 'xxx']`
   - `candidate(['xxx', 'asd', 'aaaxxy', 'john doe', 'xxxAAA', 'xxx'], 'xx') == ['xxx', 'aaaxxy', 'xxxAAA', 'xxx']`
   - `candidate(['grunt', 'trumpet', 'prune', 'gruesome'], 'run') == ['grunt', 'prune']`

I need to create:
1. A dummy implementation of `filter_by_substring` that returns an empty sequence
2. Test methods that call `filter_by_substring` and check the expected results

For the dummy implementation, I need to have the same signature but just return an empty sequence.

For the tests, I need to convert the Python lists to Dafny sequences and strings.

Let me write this out:

--- RESPONSE ---
Looking at the Python tests and Dafny solution:

1. **Method to test:** `filter_by_substring` with signature `method filter_by_substring(strings: seq<string>, substring: string) returns (result: seq<string>)`

2. **Dummy implementation:**

<dummy>
method filter_by_substring(strings: seq<string>, substring: string) returns (result: seq<string>)
{
    result := [];
}
</dummy>

3. **Translated tests:**

```dafny
method {:test} test_0()
{
    var result := filter_by_substring([], "john");
    expect result == [];
}

method {:test} test_1()
{
    var result := filter_by_substring(["xxx", "asd", "xxy", "john doe", "xxxAAA", "xxx"], "xxx");
    expect result == ["xxx", "xxxAAA", "xxx"];
}

method {:test} test_2()
{
    var result := filter_by_substring(["xxx", "asd", "aaaxxy", "john doe", "xxxAAA", "xxx"], "xx");
    expect result == ["xxx", "aaaxxy", "xxxAAA", "xxx"];
}

method {:test} test_3()
{
    var result := filter_by_substring(["grunt", "trumpet", "prune", "gruesome"], "run");
    expect result == ["grunt", "prune"];
}
```

