======SYSTEM PROMPT======
You are a Python coding assistant. Your task is to write a Python script with the full implementation of the function described in the user prompt. The implementation should be inside a markdown code block.

======USER PROMPT======

def smallest_change(arr):
    """
    Given an array arr of integers, find the minimum number of elements that
    need to be changed to make the array palindromic. A palindromic array is an array that
    is read the same backwards and forwards. In one change, you can change one element to any other element.

    For example:
    smallest_change([1,2,3,5,4,7,9,6]) == 4
    smallest_change([1, 2, 3, 4, 3, 2, 2]) == 1
    smallest_change([1, 2, 3, 2, 1]) == 0
    """


======MODEL OUTPUT======
Looking at this problem, I need to find the minimum number of changes to make an array palindromic.

The key insight is that in a palindromic array, elements at symmetric positions (i and n-1-i) must be equal. So I need to compare elements from both ends moving towards the center, and count how many pairs don't match.

For each mismatched pair, I need to change one element to match the other (1 change per pair).

```python
def smallest_change(arr):
    """
    Given an array arr of integers, find the minimum number of elements that
    need to be changed to make the array palindromic. A palindromic array is an array that
    is read the same backwards and forwards. In one change, you can change one element to any other element.

    For example:
    smallest_change([1,2,3,5,4,7,9,6]) == 4
    smallest_change([1, 2, 3, 4, 3, 2, 2]) == 1
    smallest_change([1, 2, 3, 2, 1]) == 0
    """
    n = len(arr)
    changes = 0
    
    # Compare elements from both ends moving towards center
    for i in range(n // 2):
        # Compare element at position i with element at symmetric position
        if arr[i] != arr[n - 1 - i]:
            changes += 1
    
    return changes
```

The algorithm works as follows:

1. I iterate through the first half of the array (up to `n // 2`)
2. For each position `i`, I compare `arr[i]` with its symmetric counterpart `arr[n-1-i]`
3. If they don't match, I increment the change counter
4. Return the total number of changes needed

Let me trace through the examples:
- `[1,2,3,5,4,7,9,6]`: Compare (1,6), (2,9), (3,7), (5,4) - all different, so 4 changes
- `[1,2,3,4,3,2,2]`: Compare (1,2), (2,2), (3,3) - first pair different, so 1 change  
- `[1,2,3,2,1]`: Compare (1,1), (2,2) - both same, so 0 changes