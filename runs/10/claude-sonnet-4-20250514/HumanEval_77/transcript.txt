======SYSTEM PROMPT======
You are a Python coding assistant. Your task is to write a Python script with the full implementation of the function described in the user prompt. The implementation should be inside a markdown code block.

======USER PROMPT======

def iscube(a):
    '''
    Write a function that takes an integer a and returns True 
    if this ingeger is a cube of some integer number.
    Note: you may assume the input is always valid.
    Examples:
    iscube(1) ==> True
    iscube(2) ==> False
    iscube(-1) ==> True
    iscube(64) ==> True
    iscube(0) ==> True
    iscube(180) ==> False
    '''


======MODEL OUTPUT======
Looking at this problem, I need to determine if a given integer is a perfect cube of some integer.

Key observations:
1. A number is a perfect cube if there exists an integer n such that n³ = a
2. I need to handle negative numbers (since (-2)³ = -8)
3. Zero is a perfect cube (0³ = 0)
4. I need to find the cube root and check if it's an integer

My approach:
1. Handle the special case of 0
2. For positive numbers, find the cube root and check if it's an integer
3. For negative numbers, find the cube root of the absolute value and check if it's an integer

```python
def iscube(a):
    '''
    Write a function that takes an integer a and returns True 
    if this ingeger is a cube of some integer number.
    Note: you may assume the input is always valid.
    Examples:
    iscube(1) ==> True
    iscube(2) ==> False
    iscube(-1) ==> True
    iscube(64) ==> True
    iscube(0) ==> True
    iscube(180) ==> False
    '''
    if a == 0:
        return True
    
    # Handle negative numbers
    if a < 0:
        # For negative numbers, we need the cube root of the absolute value
        cube_root = round((-a) ** (1/3))
        return (-cube_root) ** 3 == a
    else:
        # For positive numbers
        cube_root = round(a ** (1/3))
        return cube_root ** 3 == a
```

The solution works as follows:
- For `a = 0`: Returns `True` directly
- For negative numbers: Takes the cube root of the absolute value, rounds it, then checks if the negative of that cubed equals the original number
- For positive numbers: Takes the cube root, rounds it, then checks if that cubed equals the original number

I use `round()` to handle floating-point precision issues that might occur when taking fractional powers.