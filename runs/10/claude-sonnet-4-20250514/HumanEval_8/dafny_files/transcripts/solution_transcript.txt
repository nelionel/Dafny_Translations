=============== SYSTEM ===============
You are an expert programmer specializing in translating Python code to the Dafny verification language. Your task is to translate the provided Python function into a Dafny method that is both verifiable and compilable. Pay close attention to types, specifications, and providing concrete implementations for all methods.



=============== USER ===============
I will provide you with a Python function and its documentation. Please translate the Python function into a Dafny method.

**Python Function and Documentation:**
```python
from typing import List, Tuple


def sum_product(numbers: List[int]) -> Tuple[int, int]:
    """ For a given list of integers, return a tuple consisting of a sum and a product of all the integers in a list.
    Empty sum should be equal to 0 and empty product should be equal to 1.
    >>> sum_product([])
    (0, 1)
    >>> sum_product([1, 2, 3, 4])
    (10, 24)
    """

from typing import List, Tuple


def sum_product(numbers: List[int]) -> Tuple[int, int]:
    """ For a given list of integers, return a tuple consisting of a sum and a product of all the integers in a list.
    Empty sum should be equal to 0 and empty product should be equal to 1.
    >>> sum_product([])
    (0, 1)
    >>> sum_product([1, 2, 3, 4])
    (10, 24)
    """
    # Handle empty list case
    if not numbers:
        return (0, 1)
    
    # Calculate sum and product
    total_sum = sum(numbers)
    total_product = 1
    
    for num in numbers:
        total_product *= num
    
    return (total_sum, total_product)
```

**Your Task:**
1.  **Reasoning (in a <thinking> block):**
    *   Analyze the Python code and its types. How will you map Python types (like lists of floats) to Dafny types (like `seq<real>`)?
    *   Analyze the function's logic. What are the pre-conditions (`requires`) and post-conditions (`ensures`)?
    *   Identify any loops and determine their invariants.
    *   Think about termination conditions for any recursive calls or loops.
2.  **Dafny Implementation (in a ```dafny ... ``` block):**
    *   Write the complete Dafny method, including its signature, `requires` clauses, `ensures` clauses, and the method body.
    *   **The return type of the main method must be a basic Dafny type.** Use `int`, `real`, `bool`, `string`, or a sequence of these types (e.g., `seq<int>`). Do not use custom `datatype`s in the return signature. If the Python code implies an optional return (e.g. returning `None`), you should return a sensible default for the basic type instead (e.g. `false`, `-1`, or an empty sequence `[]`).
    *   The Dafny method name must be exactly the same as the Python function name: `sum_product`. Do not change the casing.
    *   **All methods must have a concrete implementation (a body).** The `{:axiom}` attribute is forbidden for defining standard functions. However, if the problem's solution relies on an unproven mathematical conjecture (e.g., the Goldbach Conjecture, P vs NP), you may state the conjecture as an `axiom`. If you do so, you **must** include a comment identifying the conjecture (e.g., `// Axiom for the Twin Prime Conjecture`). Do not use axioms to avoid implementing solvable algorithms.
    *   **Provide explicit termination proofs.** For any recursive function, you must include a `decreases` clause. Do **not** use `decreases *`. For functions that operate on a sequence, the termination metric is almost always the length of the sequence (e.g., `decreases my_sequence`). For functions on integers, it is the integer itself (e.g., `decreases n`).
    *   **Do not use Dafny reserved keywords as variable names.** Avoid names like: `abstract, allocated, as, assert, assume, bool, break, by, calc, case, char, class, codatatype, const, constructor, datatype, decreases, else, ensures, exists, export, extends, false, forall, fresh, function, ghost, if, imap, import, in, include, int, invariant, is, iset, iterator, label, lemma, map, match, method, modifies, modify, module, multiset, nameonly, nat, new, newtype, null, object, object?, old, opened, ORDINAL, predicate, print, provides,reads, real, refines, requires, return, returns, reveal, reveals, seq, set, static, string, then, this, trait, true, twostate, type, unchanged, var, while, witness, yield, yields`. For example, instead of `var array`, use `var arr`.



=============== ASSISTANT ===============
--- THINKING ---
Let me analyze the Python function:

1. The function takes a list of integers and returns a tuple with two integers: sum and product.
2. For an empty list, it returns (0, 1).
3. For a non-empty list, it calculates the sum and product of all elements.

Type mapping:
- Python `List[int]` maps to Dafny `seq<int>`
- Python `Tuple[int, int]` maps to... well, Dafny doesn't have tuples as basic types. The instructions say to use basic types only. So I need to return two separate values or use a sequence. Since the instruction says the return type must be a basic Dafny type, I think I should return a `seq<int>` with exactly 2 elements: the sum and the product.

Logic analysis:
- Pre-conditions: None really, any sequence of integers is valid input.
- Post-conditions: 
  - If the input sequence is empty, return [0, 1]
  - If the input sequence is non-empty, return [sum of all elements, product of all elements]
  - The returned sequence always has length 2

Loop analysis:
- There's a for loop that multiplies all numbers. The loop invariant would be that total_product is the product of all elements processed so far.
- The sum is calculated using Python's built-in sum(), which I'll need to implement as a loop or use Dafny's built-in functions if available.

Let me write the Dafny implementation:

```dafny
method sum_product(numbers: seq<int>) returns (result: seq<int>)
  ensures |result| == 2
  ensures |numbers| == 0 ==> result == [0, 1]
  ensures |numbers| > 0 ==> result[0] == sum_seq(numbers) && result[1] == product_seq(numbers)
{
  if |numbers| == 0 {
    result := [0, 1];
  } else {
    var total_sum := sum_seq(numbers);
    var total_product := product_seq(numbers);
    result := [total_sum, total_product];
  }
}

I'll implement recursive helper functions to calculate sum and product. The base cases handle empty sequences, while recursive cases break down the sequence into first element and remaining elements. This approach ensures we can compute sum and product for any input sequence.

The method handles two scenarios: empty and non-empty sequences. For empty sequences, it returns the predefined [0, 1]. For non-empty sequences, it computes sum and product using recursive functions and returns them in a sequence.

I'll add decreases clauses to prove termination, ensuring the recursive functions always make progress by reducing sequence length. This helps verify the functions will eventually reach their base cases.

Switching to loops might improve performance, especially for large sequences. Loops can be more memory-efficient and potentially faster than recursive calls.

The method calculates both sum and product simultaneously, tracking running totals through a loop. Invariants ensure correct intermediate state tracking, verifying the computation maintains expected properties at each iteration.

I'll define helper functions to compute sum and product of entire sequences and prefixes, using recursive definitions that mirror the loop's logic. These functions provide clear, mathematically verifiable implementations of sequence aggregation operations.

The recursive prefix functions use decreasing length as a termination metric, ensuring they always converge to a base case when the length reaches zero.

--- RESPONSE ---
<thinking>
Let me analyze the Python function:

1. **Type Mapping**: Python `List[int]` maps to Dafny `seq<int>`. Since the return type must be a basic Dafny type and not a tuple, I'll return a `seq<int>` with exactly 2 elements: [sum, product].

2. **Logic Analysis**: 
   - For empty list: return (0, 1)
   - For non-empty list: calculate sum and product of all elements
   - No special preconditions needed

3. **Loop Analysis**: The Python code has a for loop that calculates the product. I'll implement this with a while loop in Dafny, maintaining loop invariants for both sum and product calculations.

4. **Post-conditions**: 
   - Result always has length 2
   - For empty input: result is [0, 1]  
   - For non-empty input: result[0] is sum, result[1] is product

I'll need helper functions to define what sum and product mean mathematically for verification purposes.
</thinking>

```dafny
method sum_product(numbers: seq<int>) returns (result: seq<int>)
  ensures |result| == 2
  ensures |numbers| == 0 ==> result == [0, 1]
  ensures |numbers| > 0 ==> result[0] == sum_of_seq(numbers) && result[1] == product_of_seq(numbers)
{
  if |numbers| == 0 {
    result := [0, 1];
  } else {
    var total_sum := 0;
    var total_product := 1;
    var i := 0;
    
    while i < |numbers|
      invariant 0 <= i <= |numbers|
      invariant total_sum == sum_of_prefix(numbers, i)
      invariant total_product == product_of_prefix(numbers, i)
    {
      total_sum := total_sum + numbers[i];
      total_product := total_product * numbers[i];
      i := i + 1;
    }
    
    result := [total_sum, total_product];
  }
}

function sum_of_seq(s: seq<int>): int
{
  sum_of_prefix(s, |s|)
}

function product_of_seq(s: seq<int>): int
{
  product_of_prefix(s, |s|)
}

function sum_of_prefix(s: seq<int>, n: int): int
  requires 0 <= n <= |s|
  decreases n
{
  if n == 0 then 0
  else s[n-1] + sum_of_prefix(s, n-1)
}

function product_of_prefix(s: seq<int>, n: int): int
  requires 0 <= n <= |s|
  decreases n
{
  if n == 0 then 1
  else s[n-1] * product_of_prefix(s, n-1)
}
```

