=============== SYSTEM ===============
You are an expert programmer specializing in translating Python tests to the Dafny verification language. Your task is to translate Python `assert` statements into Dafny test methods and provide a minimal dummy implementation for compilation checking.



=============== USER ===============
I need you to translate Python test assertions into Dafny test methods.

**The Method to Test:**
The Dafny method you need to test is named `sum_product`.

**Python Test Code:**
```python


METADATA = {
    'author': 'jt',
    'dataset': 'test'
}


def check(candidate):
    assert candidate([]) == (0, 1)
    assert candidate([1, 1, 1]) == (3, 1)
    assert candidate([100, 0]) == (100, 0)
    assert candidate([3, 5, 7]) == (3 + 5 + 7, 3 * 5 * 7)
    assert candidate([10]) == (10, 10)

```

**Dafny Solution Code (that these tests should test):**
```dafny
method sum_product(numbers: seq<int>) returns (result: seq<int>)
  ensures |result| == 2
  ensures |numbers| == 0 ==> result == [0, 1]
  ensures |numbers| > 0 ==> result[0] == sum_of_seq(numbers) && result[1] == product_of_seq(numbers)
{
  if |numbers| == 0 {
    result := [0, 1];
  } else {
    var total_sum := 0;
    var total_product := 1;
    var i := 0;
    
    while i < |numbers|
      invariant 0 <= i <= |numbers|
      invariant total_sum == sum_of_prefix(numbers, i)
      invariant total_product == product_of_prefix(numbers, i)
    {
      total_sum := total_sum + numbers[i];
      total_product := total_product * numbers[i];
      i := i + 1;
    }
    
    result := [total_sum, total_product];
  }
}

function sum_of_seq(s: seq<int>): int
{
  sum_of_prefix(s, |s|)
}

function product_of_seq(s: seq<int>): int
{
  product_of_prefix(s, |s|)
}

function sum_of_prefix(s: seq<int>, n: int): int
  requires 0 <= n <= |s|
  decreases n
{
  if n == 0 then 0
  else s[n-1] + sum_of_prefix(s, n-1)
}

function product_of_prefix(s: seq<int>, n: int): int
  requires 0 <= n <= |s|
  decreases n
{
  if n == 0 then 1
  else s[n-1] * product_of_prefix(s, n-1)
}
```

**Your Task:**
1. **Analyze the tests and solution:**
   - Note the exact name (`sum_product`) and signature of the Dafny method from the provided solution code.

2. **Create a minimal dummy implementation** (in a `<dummy>` block):
   - Create a dummy version of the `sum_product` Dafny method.
   - The dummy should have the same signature as the method in the full Dafny solution and return appropriate default values (0 for int, false for bool, [] for sequences, etc.).
   - This dummy is ONLY for validating that the test code compiles correctly.

3. **Translate the tests** (in a ```dafny ... ``` block):
   - For each `assert` statement in the Python code, create a Dafny test method with `{:test}` attribute.
   - **All generated test methods must have a complete body and be runnable.**
   - Name them `test_0`, `test_1`, etc.
   - Convert scientific notation (e.g., 1e-6) to decimal form (e.g., 0.000001).
   - Each test method should:
     a. Call the `sum_product` Dafny method and assign the result to a variable.
     b. Use `expect` to check if the result matches the expected value.

**Example:** If Python has `assert add(2, 3) == 5`, the method to test is `add`, and the Dafny solution has `function add(a: int, b: int): int`, then:
<dummy>
function add(a: int, b: int): int
{
    0
}
</dummy>

```dafny
method {:test} test_0()
{
    var result := add(2, 3);
    expect result == 5;
}
```



=============== ASSISTANT ===============
--- THINKING ---
Let me analyze the Python test code and the Dafny solution to understand what I need to do.

From the Python test code:
```python
def check(candidate):
    assert candidate([]) == (0, 1)
    assert candidate([1, 1, 1]) == (3, 1)
    assert candidate([100, 0]) == (100, 0)
    assert candidate([3, 5, 7]) == (3 + 5 + 7, 3 * 5 * 7)
    assert candidate([10]) == (10, 10)
```

The function being tested takes a list and returns a tuple of two values.

From the Dafny solution code:
```dafny
method sum_product(numbers: seq<int>) returns (result: seq<int>)
```

So the method `sum_product` takes a sequence of integers and returns a sequence of integers (length 2 based on the ensures clause).

Let me look at the Python tests more carefully:
1. `candidate([]) == (0, 1)` - empty list returns (0, 1)
2. `candidate([1, 1, 1]) == (3, 1)` - [1,1,1] returns (3, 1) - sum is 3, product is 1
3. `candidate([100, 0]) == (100, 0)` - [100, 0] returns (100, 0) - sum is 100, product is 0
4. `candidate([3, 5, 7]) == (3 + 5 + 7, 3 * 5 * 7)` - [3,5,7] returns (15, 105) - sum is 15, product is 105
5. `candidate([10]) == (10, 10)` - [10] returns (10, 10) - sum is 10, product is 10


I'll adapt the implementation to handle different input scenarios, converting between Python tuples and Dafny sequences. The key is to create a method that returns a sequence representing the sum and product of input numbers.

I'll start with a basic implementation that uses default values for edge cases like empty lists. The method needs to work with various input lengths and handle special conditions like zero values or single-element lists.

The tests cover multiple scenarios: empty sequences, lists with repeated elements, lists with zero values, and lists of different lengths. Each test checks the method's ability to correctly compute and return the sum and product as a two-element sequence.

--- RESPONSE ---
Looking at the Python tests and Dafny solution:

**Analysis:**
- The Python function takes a list and returns a tuple (sum, product)
- The Dafny method `sum_product` takes a `seq<int>` and returns a `seq<int>` of length 2
- The Python tuples need to be converted to Dafny sequences

<dummy>
method sum_product(numbers: seq<int>) returns (result: seq<int>)
{
    result := [0, 0];
}
</dummy>

```dafny
method {:test} test_0()
{
    var result := sum_product([]);
    expect result == [0, 1];
}

method {:test} test_1()
{
    var result := sum_product([1, 1, 1]);
    expect result == [3, 1];
}

method {:test} test_2()
{
    var result := sum_product([100, 0]);
    expect result == [100, 0];
}

method {:test} test_3()
{
    var result := sum_product([3, 5, 7]);
    expect result == [15, 105];
}

method {:test} test_4()
{
    var result := sum_product([10]);
    expect result == [10, 10];
}
```

