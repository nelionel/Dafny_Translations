=============== SYSTEM ===============
You are an expert programmer specializing in translating Python code to the Dafny verification language. Your task is to translate the provided Python function into a Dafny method that is both verifiable and compilable. Pay close attention to types, specifications, and providing concrete implementations for all methods.



=============== USER ===============
I will provide you with a Python function and its documentation. Please translate the Python function into a Dafny method.

**Python Function and Documentation:**
```python

def is_happy(s):
    """You are given a string s.
    Your task is to check if the string is happy or not.
    A string is happy if its length is at least 3 and every 3 consecutive letters are distinct
    For example:
    is_happy(a) => False
    is_happy(aa) => False
    is_happy(abcd) => True
    is_happy(aabb) => False
    is_happy(adb) => True
    is_happy(xyy) => False
    """

def is_happy(s):
    """You are given a string s.
    Your task is to check if the string is happy or not.
    A string is happy if its length is at least 3 and every 3 consecutive letters are distinct
    For example:
    is_happy(a) => False
    is_happy(aa) => False
    is_happy(abcd) => True
    is_happy(aabb) => False
    is_happy(adb) => True
    is_happy(xyy) => False
    """
    # Check if length is at least 3
    if len(s) < 3:
        return False
    
    # Check every 3 consecutive characters
    for i in range(len(s) - 2):
        # Get 3 consecutive characters
        three_chars = s[i:i+3]
        
        # Check if all 3 characters are distinct
        if len(set(three_chars)) != 3:
            return False
    
    return True
```

**Your Task:**
1.  **Reasoning (in a <thinking> block):**
    *   Analyze the Python code and its types. How will you map Python types (like lists of floats) to Dafny types (like `seq<real>`)?
    *   Analyze the function's logic. What are the pre-conditions (`requires`) and post-conditions (`ensures`)?
    *   Identify any loops and determine their invariants.
    *   Think about termination conditions for any recursive calls or loops.
2.  **Dafny Implementation (in a ```dafny ... ``` block):**
    *   Write the complete Dafny method, including its signature, `requires` clauses, `ensures` clauses, and the method body.
    *   **The return type of the main method must be a basic Dafny type.** Use `int`, `real`, `bool`, `string`, or a sequence of these types (e.g., `seq<int>`). Do not use custom `datatype`s in the return signature. If the Python code implies an optional return (e.g. returning `None`), you should return a sensible default for the basic type instead (e.g. `false`, `-1`, or an empty sequence `[]`).
    *   The Dafny method name must be exactly the same as the Python function name: `is_happy`. Do not change the casing.
    *   **All methods must have a concrete implementation (a body).** The `{:axiom}` attribute is forbidden for defining standard functions. However, if the problem's solution relies on an unproven mathematical conjecture (e.g., the Goldbach Conjecture, P vs NP), you may state the conjecture as an `axiom`. If you do so, you **must** include a comment identifying the conjecture (e.g., `// Axiom for the Twin Prime Conjecture`). Do not use axioms to avoid implementing solvable algorithms.
    *   **Provide explicit termination proofs.** For any recursive function, you must include a `decreases` clause. Do **not** use `decreases *`. For functions that operate on a sequence, the termination metric is almost always the length of the sequence (e.g., `decreases my_sequence`). For functions on integers, it is the integer itself (e.g., `decreases n`).
    *   **Do not use Dafny reserved keywords as variable names.** Avoid names like: `abstract, allocated, as, assert, assume, bool, break, by, calc, case, char, class, codatatype, const, constructor, datatype, decreases, else, ensures, exists, export, extends, false, forall, fresh, function, ghost, if, imap, import, in, include, int, invariant, is, iset, iterator, label, lemma, map, match, method, modifies, modify, module, multiset, nameonly, nat, new, newtype, null, object, object?, old, opened, ORDINAL, predicate, print, provides,reads, real, refines, requires, return, returns, reveal, reveals, seq, set, static, string, then, this, trait, true, twostate, type, unchanged, var, while, witness, yield, yields`. For example, instead of `var array`, use `var arr`.



=============== ASSISTANT ===============
--- THINKING ---
Let me analyze the Python function:

1. The function `is_happy` takes a string `s` as input
2. It returns a boolean value
3. The logic is:
   - If the string length is less than 3, return False
   - For every 3 consecutive characters in the string, check if all 3 are distinct (no duplicates)
   - If any 3 consecutive characters have duplicates, return False
   - If all groups of 3 consecutive characters are distinct, return True

In Dafny:
- The input will be a `string` (which is `seq<char>` in Dafny)
- The return type will be `bool`
- I need to iterate through the string checking every 3 consecutive characters

For the loop invariant, I need to ensure that:
- The loop index `i` is within bounds
- All groups of 3 consecutive characters from 0 to i-1 have been checked and are distinct

Let me think about the pre-conditions and post-conditions:
- Pre-condition: None really needed, the string can be any string
- Post-condition: The result is true if and only if the string length is at least 3 and every 3 consecutive characters are distinct

For the helper logic to check if 3 characters are distinct, I need to check that no two characters are the same among the three.

Let me write the Dafny code:

```dafny
method is_happy(s: string) returns (result: bool)
  ensures result == (|s| >= 3 && forall i :: 0 <= i <= |s| - 3 ==> 
    s[i] != s[i+1] && s[i] != s[i+2] && s[i+1] != s[i+2])
{
  if |s| < 3 {
    return false;
  }
  
  I'll track the loop's progress by checking consecutive character groups. The method systematically examines each set of three characters, ensuring no duplicates exist. If any group contains repeated characters, the method immediately returns false. The loop continues until all possible three-character combinations have been verified or a duplicate is found.

  The bounds are carefully validated to handle strings of different lengths, including edge cases like three-character strings. By incrementing the index and maintaining strict comparison rules, the algorithm efficiently determines whether the string meets the unique character requirement.

  For a four-character string, the loop systematically checks consecutive three-character groups, ensuring no repeated characters within each group. The first iteration examines characters at indices 0, 1, and 2, while the second iteration shifts to examine characters at indices 1, 2, and 3.

  The method's goal is to verify a string's "happiness" by confirming that every three-character subsequence contains unique characters. It starts by handling short strings, immediately returning false if the length is less than three.

  The implementation uses a while loop to traverse potential three-character windows, methodically checking each group's character distinctness.

  If any three-character subsequence contains repeated characters, the method immediately returns false. Otherwise, it continues advancing through the string, incrementing the index and maintaining the distinctness invariant.

  The loop's termination ensures comprehensive checking of all possible three-character subsequences, ultimately returning true if no repeated characters are found. I'll verify the loop's termination by examining how the decreasing expression changes. Initially, i starts at 0, making the decreases expression |s| - 3. Each iteration increments i, reducing the expression by 1. When i reaches |s| - 3, the decreases value hits 0, and the loop condition becomes false, ensuring termination.

--- RESPONSE ---
<thinking>
Let me analyze the Python function:

1. **Types**: The function takes a string `s` and returns a boolean. In Dafny, this maps to `string` (which is `seq<char>`) and `bool`.

2. **Logic**: 
   - If string length < 3, return False
   - For every 3 consecutive characters, check if all are distinct
   - Return True only if all groups of 3 consecutive characters are distinct

3. **Pre/Post conditions**:
   - No real pre-conditions needed
   - Post-condition: result is true iff length >= 3 and every 3 consecutive characters are distinct

4. **Loop analysis**:
   - The loop iterates from 0 to len(s)-3 (inclusive)
   - Loop invariant: all groups of 3 consecutive characters from 0 to i-1 have been checked and are distinct
   - Termination: decreases |s| - 3 - i

5. **Implementation details**:
   - Need to check that among any 3 consecutive characters s[i], s[i+1], s[i+2], no two are equal
</thinking>

```dafny
method is_happy(s: string) returns (result: bool)
  ensures result == (|s| >= 3 && forall i :: 0 <= i <= |s| - 3 ==> 
    s[i] != s[i+1] && s[i] != s[i+2] && s[i+1] != s[i+2])
{
  if |s| < 3 {
    return false;
  }
  
  var i := 0;
  while i <= |s| - 3
    invariant 0 <= i <= |s| - 2
    invariant forall j :: 0 <= j < i ==> 
      s[j] != s[j+1] && s[j] != s[j+2] && s[j+1] != s[j+2]
    decreases |s| - 3 - i
  {
    if s[i] == s[i+1] || s[i] == s[i+2] || s[i+1] == s[i+2] {
      return false;
    }
    i := i + 1;
  }
  
  return true;
}
```

