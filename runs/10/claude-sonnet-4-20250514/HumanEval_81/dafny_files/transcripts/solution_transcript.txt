=============== SYSTEM ===============
You are an expert programmer specializing in translating Python code to the Dafny verification language. Your task is to translate the provided Python function into a Dafny method that is both verifiable and compilable. Pay close attention to types, specifications, and providing concrete implementations for all methods.



=============== USER ===============
I will provide you with a Python function and its documentation. Please translate the Python function into a Dafny method.

**Python Function and Documentation:**
```python

def numerical_letter_grade(grades):
    """It is the last week of the semester and the teacher has to give the grades
    to students. The teacher has been making her own algorithm for grading.
    The only problem is, she has lost the code she used for grading.
    She has given you a list of GPAs for some students and you have to write 
    a function that can output a list of letter grades using the following table:
             GPA       |    Letter grade
              4.0                A+
            > 3.7                A 
            > 3.3                A- 
            > 3.0                B+
            > 2.7                B 
            > 2.3                B-
            > 2.0                C+
            > 1.7                C
            > 1.3                C-
            > 1.0                D+ 
            > 0.7                D 
            > 0.0                D-
              0.0                E
    

    Example:
    grade_equation([4.0, 3, 1.7, 2, 3.5]) ==> ['A+', 'B', 'C-', 'C', 'A-']
    """

def numerical_letter_grade(grades):
    """It is the last week of the semester and the teacher has to give the grades
    to students. The teacher has been making her own algorithm for grading.
    The only problem is, she has lost the code she used for grading.
    She has given you a list of GPAs for some students and you have to write 
    a function that can output a list of letter grades using the following table:
             GPA       |    Letter grade
              4.0                A+
            > 3.7                A 
            > 3.3                A- 
            > 3.0                B+
            > 2.7                B 
            > 2.3                B-
            > 2.0                C+
            > 1.7                C
            > 1.3                C-
            > 1.0                D+ 
            > 0.7                D 
            > 0.0                D-
              0.0                E
    

    Example:
    grade_equation([4.0, 3, 1.7, 2, 3.5]) ==> ['A+', 'B', 'C-', 'C', 'A-']
    """
    letter_grades = []
    
    for gpa in grades:
        if gpa == 4.0:
            letter_grades.append('A+')
        elif gpa > 3.7:
            letter_grades.append('A')
        elif gpa > 3.3:
            letter_grades.append('A-')
        elif gpa > 3.0:
            letter_grades.append('B+')
        elif gpa > 2.7:
            letter_grades.append('B')
        elif gpa > 2.3:
            letter_grades.append('B-')
        elif gpa > 2.0:
            letter_grades.append('C+')
        elif gpa > 1.7:
            letter_grades.append('C')
        elif gpa > 1.3:
            letter_grades.append('C-')
        elif gpa > 1.0:
            letter_grades.append('D+')
        elif gpa > 0.7:
            letter_grades.append('D')
        elif gpa > 0.0:
            letter_grades.append('D-')
        else:  # gpa == 0.0
            letter_grades.append('E')
    
    return letter_grades
```

**Your Task:**
1.  **Reasoning (in a <thinking> block):**
    *   Analyze the Python code and its types. How will you map Python types (like lists of floats) to Dafny types (like `seq<real>`)?
    *   Analyze the function's logic. What are the pre-conditions (`requires`) and post-conditions (`ensures`)?
    *   Identify any loops and determine their invariants.
    *   Think about termination conditions for any recursive calls or loops.
2.  **Dafny Implementation (in a ```dafny ... ``` block):**
    *   Write the complete Dafny method, including its signature, `requires` clauses, `ensures` clauses, and the method body.
    *   **The return type of the main method must be a basic Dafny type.** Use `int`, `real`, `bool`, `string`, or a sequence of these types (e.g., `seq<int>`). Do not use custom `datatype`s in the return signature. If the Python code implies an optional return (e.g. returning `None`), you should return a sensible default for the basic type instead (e.g. `false`, `-1`, or an empty sequence `[]`).
    *   The Dafny method name must be exactly the same as the Python function name: `numerical_letter_grade`. Do not change the casing.
    *   **All methods must have a concrete implementation (a body).** The `{:axiom}` attribute is forbidden for defining standard functions. However, if the problem's solution relies on an unproven mathematical conjecture (e.g., the Goldbach Conjecture, P vs NP), you may state the conjecture as an `axiom`. If you do so, you **must** include a comment identifying the conjecture (e.g., `// Axiom for the Twin Prime Conjecture`). Do not use axioms to avoid implementing solvable algorithms.
    *   **Provide explicit termination proofs.** For any recursive function, you must include a `decreases` clause. Do **not** use `decreases *`. For functions that operate on a sequence, the termination metric is almost always the length of the sequence (e.g., `decreases my_sequence`). For functions on integers, it is the integer itself (e.g., `decreases n`).
    *   **Do not use Dafny reserved keywords as variable names.** Avoid names like: `abstract, allocated, as, assert, assume, bool, break, by, calc, case, char, class, codatatype, const, constructor, datatype, decreases, else, ensures, exists, export, extends, false, forall, fresh, function, ghost, if, imap, import, in, include, int, invariant, is, iset, iterator, label, lemma, map, match, method, modifies, modify, module, multiset, nameonly, nat, new, newtype, null, object, object?, old, opened, ORDINAL, predicate, print, provides,reads, real, refines, requires, return, returns, reveal, reveals, seq, set, static, string, then, this, trait, true, twostate, type, unchanged, var, while, witness, yield, yields`. For example, instead of `var array`, use `var arr`.



=============== ASSISTANT ===============
--- THINKING ---
Let me analyze the Python function first:

1. **Function purpose**: It takes a list of GPA values (floats) and returns a list of letter grade strings based on the given grading scale.

2. **Python types mapping to Dafny**:
   - Python list of floats → Dafny `seq<real>`
   - Python list of strings → Dafny `seq<string>`

3. **Logic analysis**:
   - The function iterates through each GPA in the input list
   - For each GPA, it applies a series of if-elif-else conditions to determine the letter grade
   - The conditions are ordered from highest to lowest GPA thresholds
   - The result is accumulated in a list that's returned

4. **Pre-conditions and post-conditions**:
   - Pre-condition: The input should be a valid sequence of real numbers (GPAs are typically non-negative, but the code handles negative values by giving them 'E')
   - Post-condition: The output sequence should have the same length as the input sequence, and each element should be a valid letter grade string

5. **Loop analysis**:
   - There's a for loop that iterates through the grades
   - Loop invariant: The length of letter_grades built so far equals the number of grades processed
   - Loop invariant: Each element in letter_grades corresponds to the correct letter grade for the corresponding GPA

6. **Termination**:
   - The loop terminates because it processes a finite sequence
   - The decreases clause would be the remaining length of the sequence to process

Now let me implement this in Dafny:

```dafny
method numerical_letter_grade(grades: seq<real>) returns (letter_grades: seq<string>)
  ensures |letter_grades| == |grades|
  ensures forall i :: 0 <= i < |grades| ==> 
    letter_grades[i] == grade_to_letter(grades[i])


{
  letter_grades := [];
  
  var i := 0;
  while i < |grades|
    invariant 0 <= i <= |grades|
    invariant |letter_grades| == i
    invariant forall j :: 0 <= j < i ==> 
      letter_grades[j] == grade_to_letter(grades[j])
  {
    var grade := grades[i];
    var letter_grade: string;
    
    if grade == 4.0 {
      letter_grade := "A

I'll continue the implementation by completing the partial thought. The code is setting up a method to convert numerical grades to letter grades, initializing an empty sequence and preparing to iterate through the input grades. The current conditional block is determining the letter grade for a specific GPA value.

The conversion follows a standard grading scale, mapping numerical ranges to corresponding letter grades. Each grade range triggers a specific letter assignment, creating a systematic way to translate numeric performance into a more traditional grading format.

The implementation ensures type safety by declaring variables with explicit types and uses an invariant-guarded loop to maintain the integrity of the letter grade conversion process. This approach allows for precise tracking of grade transformations while preserving the original grade sequence.

--- RESPONSE ---
<thinking>
Let me analyze the Python function:

1. **Function purpose**: It takes a list of GPA values (floats) and returns a list of letter grade strings based on a grading scale.

2. **Type mapping**:
   - Python list of floats → Dafny `seq<real>`
   - Python list of strings → Dafny `seq<string>`

3. **Logic analysis**:
   - Iterates through each GPA in the input list
   - Applies if-elif-else conditions to determine letter grades based on GPA thresholds
   - Accumulates results in a list

4. **Specifications**:
   - Pre-condition: Input should be a valid sequence of real numbers
   - Post-condition: Output sequence has same length as input, with correct letter grades
   - Loop invariant: Length of result matches number of grades processed so far

5. **Termination**: The loop processes a finite sequence, so it will terminate.
</thinking>

```dafny
method numerical_letter_grade(grades: seq<real>) returns (letter_grades: seq<string>)
  ensures |letter_grades| == |grades|
  ensures forall i :: 0 <= i < |grades| ==> 
    letter_grades[i] == grade_to_letter(grades[i])
{
  letter_grades := [];
  
  var i := 0;
  while i < |grades|
    invariant 0 <= i <= |grades|
    invariant |letter_grades| == i
    invariant forall j :: 0 <= j < i ==> 
      letter_grades[j] == grade_to_letter(grades[j])
    decreases |grades| - i
  {
    var gpa := grades[i];
    var letter_grade: string;
    
    if gpa == 4.0 {
      letter_grade := "A+";
    } else if gpa > 3.7 {
      letter_grade := "A";
    } else if gpa > 3.3 {
      letter_grade := "A-";
    } else if gpa > 3.0 {
      letter_grade := "B+";
    } else if gpa > 2.7 {
      letter_grade := "B";
    } else if gpa > 2.3 {
      letter_grade := "B-";
    } else if gpa > 2.0 {
      letter_grade := "C+";
    } else if gpa > 1.7 {
      letter_grade := "C";
    } else if gpa > 1.3 {
      letter_grade := "C-";
    } else if gpa > 1.0 {
      letter_grade := "D+";
    } else if gpa > 0.7 {
      letter_grade := "D";
    } else if gpa > 0.0 {
      letter_grade := "D-";
    } else {
      letter_grade := "E";
    }
    
    letter_grades := letter_grades + [letter_grade];
    i := i + 1;
  }
}

function grade_to_letter(gpa: real): string
{
  if gpa == 4.0 then "A+"
  else if gpa > 3.7 then "A"
  else if gpa > 3.3 then "A-"
  else if gpa > 3.0 then "B+"
  else if gpa > 2.7 then "B"
  else if gpa > 2.3 then "B-"
  else if gpa > 2.0 then "C+"
  else if gpa > 1.7 then "C"
  else if gpa > 1.3 then "C-"
  else if gpa > 1.0 then "D+"
  else if gpa > 0.7 then "D"
  else if gpa > 0.0 then "D-"
  else "E"
}
```

