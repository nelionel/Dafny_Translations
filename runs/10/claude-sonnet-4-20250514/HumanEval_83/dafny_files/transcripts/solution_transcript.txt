=============== SYSTEM ===============
You are an expert programmer specializing in translating Python code to the Dafny verification language. Your task is to translate the provided Python function into a Dafny method that is both verifiable and compilable. Pay close attention to types, specifications, and providing concrete implementations for all methods.



=============== USER ===============
I will provide you with a Python function and its documentation. Please translate the Python function into a Dafny method.

**Python Function and Documentation:**
```python

def starts_one_ends(n):
    """
    Given a positive integer n, return the count of the numbers of n-digit
    positive integers that start or end with 1.
    """

def starts_one_ends(n):
    """
    Given a positive integer n, return the count of the numbers of n-digit
    positive integers that start or end with 1.
    """
    if n <= 0:
        return 0
    
    if n == 1:
        return 1  # Only the number "1"
    
    # Numbers that start with 1: 1 followed by (n-1) digits
    # The remaining (n-1) digits can be anything from 0-9
    starts_with_1 = 10 ** (n - 1)
    
    # Numbers that end with 1: (n-1) digits followed by 1
    # The first digit can be 1-9 (not 0, as we need n-digit numbers)
    # The remaining (n-2) digits can be anything from 0-9
    ends_with_1 = 9 * (10 ** (n - 2))
    
    # Numbers that both start and end with 1: 1 followed by (n-2) digits followed by 1
    # The middle (n-2) digits can be anything from 0-9
    if n == 2:
        starts_and_ends_with_1 = 1  # Only "11"
    else:
        starts_and_ends_with_1 = 10 ** (n - 2)
    
    # Apply inclusion-exclusion principle
    result = starts_with_1 + ends_with_1 - starts_and_ends_with_1
    
    return result
```

**Your Task:**
1.  **Reasoning (in a <thinking> block):**
    *   Analyze the Python code and its types. How will you map Python types (like lists of floats) to Dafny types (like `seq<real>`)?
    *   Analyze the function's logic. What are the pre-conditions (`requires`) and post-conditions (`ensures`)?
    *   Identify any loops and determine their invariants.
    *   Think about termination conditions for any recursive calls or loops.
2.  **Dafny Implementation (in a ```dafny ... ``` block):**
    *   Write the complete Dafny method, including its signature, `requires` clauses, `ensures` clauses, and the method body.
    *   **The return type of the main method must be a basic Dafny type.** Use `int`, `real`, `bool`, `string`, or a sequence of these types (e.g., `seq<int>`). Do not use custom `datatype`s in the return signature. If the Python code implies an optional return (e.g. returning `None`), you should return a sensible default for the basic type instead (e.g. `false`, `-1`, or an empty sequence `[]`).
    *   The Dafny method name must be exactly the same as the Python function name: `starts_one_ends`. Do not change the casing.
    *   **All methods must have a concrete implementation (a body).** The `{:axiom}` attribute is forbidden for defining standard functions. However, if the problem's solution relies on an unproven mathematical conjecture (e.g., the Goldbach Conjecture, P vs NP), you may state the conjecture as an `axiom`. If you do so, you **must** include a comment identifying the conjecture (e.g., `// Axiom for the Twin Prime Conjecture`). Do not use axioms to avoid implementing solvable algorithms.
    *   **Provide explicit termination proofs.** For any recursive function, you must include a `decreases` clause. Do **not** use `decreases *`. For functions that operate on a sequence, the termination metric is almost always the length of the sequence (e.g., `decreases my_sequence`). For functions on integers, it is the integer itself (e.g., `decreases n`).
    *   **Do not use Dafny reserved keywords as variable names.** Avoid names like: `abstract, allocated, as, assert, assume, bool, break, by, calc, case, char, class, codatatype, const, constructor, datatype, decreases, else, ensures, exists, export, extends, false, forall, fresh, function, ghost, if, imap, import, in, include, int, invariant, is, iset, iterator, label, lemma, map, match, method, modifies, modify, module, multiset, nameonly, nat, new, newtype, null, object, object?, old, opened, ORDINAL, predicate, print, provides,reads, real, refines, requires, return, returns, reveal, reveals, seq, set, static, string, then, this, trait, true, twostate, type, unchanged, var, while, witness, yield, yields`. For example, instead of `var array`, use `var arr`.



=============== ASSISTANT ===============
--- THINKING ---
Let me analyze the Python function:

1. It takes a positive integer `n` and returns the count of n-digit positive integers that start or end with 1.

2. The logic:
   - If n <= 0, return 0
   - If n == 1, return 1 (only the number "1")
   - Otherwise, use inclusion-exclusion principle:
     - Numbers starting with 1: 10^(n-1) (first digit is 1, remaining (n-1) digits can be 0-9)
     - Numbers ending with 1: 9 * 10^(n-2) (last digit is 1, first digit is 1-9, remaining (n-2) digits can be 0-9)
     - Numbers both starting and ending with 1: 10^(n-2) for n > 2, or 1 for n == 2
     - Result = starts_with_1 + ends_with_1 - starts_and_ends_with_1

For the Dafny implementation:
- Input type: `n: int`
- Return type: `int`
- I'll need to implement exponentiation (10^x) as a helper function since Dafny doesn't have built-in exponentiation
- Preconditions: n should be a positive integer, but the function handles n <= 0, so I won't add a requires clause for that
- Post-conditions: the result should be non-negative

Let me implement the power function first, then the main function.

--- RESPONSE ---
<thinking>
Let me analyze the Python function:

1. **Types**: The function takes an integer `n` and returns an integer count. This maps directly to Dafny's `int` type.

2. **Logic**: The function counts n-digit positive integers that start or end with 1 using the inclusion-exclusion principle:
   - Numbers starting with 1: 10^(n-1)
   - Numbers ending with 1: 9 * 10^(n-2) 
   - Numbers both starting and ending with 1: 10^(n-2) (or 1 if n=2)
   - Result = starts_with_1 + ends_with_1 - starts_and_ends_with_1

3. **Preconditions**: The function handles n <= 0 by returning 0, so no strict preconditions needed.

4. **Post-conditions**: The result should be non-negative for any input.

5. **Helper functions needed**: I need to implement exponentiation (10^x) since Dafny doesn't have built-in exponentiation.

6. **No loops or recursion** in the main logic, but the power function will be recursive and need a decreases clause.
</thinking>

```dafny
function power(base: int, exp: int): int
  requires exp >= 0
  decreases exp
{
  if exp == 0 then 1
  else base * power(base, exp - 1)
}

method starts_one_ends(n: int) returns (result: int)
  ensures result >= 0
{
  if n <= 0 {
    result := 0;
    return;
  }
  
  if n == 1 {
    result := 1;  // Only the number "1"
    return;
  }
  
  // Numbers that start with 1: 1 followed by (n-1) digits
  // The remaining (n-1) digits can be anything from 0-9
  var starts_with_1 := power(10, n - 1);
  
  // Numbers that end with 1: (n-1) digits followed by 1
  // The first digit can be 1-9 (not 0, as we need n-digit numbers)
  // The remaining (n-2) digits can be anything from 0-9
  var ends_with_1 := 9 * power(10, n - 2);
  
  // Numbers that both start and end with 1: 1 followed by (n-2) digits followed by 1
  // The middle (n-2) digits can be anything from 0-9
  var starts_and_ends_with_1: int;
  if n == 2 {
    starts_and_ends_with_1 := 1;  // Only "11"
  } else {
    starts_and_ends_with_1 := power(10, n - 2);
  }
  
  // Apply inclusion-exclusion principle
  result := starts_with_1 + ends_with_1 - starts_and_ends_with_1;
}
```

