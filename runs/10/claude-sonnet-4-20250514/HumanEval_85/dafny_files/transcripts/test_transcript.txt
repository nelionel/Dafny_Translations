=============== SYSTEM ===============
You are an expert programmer specializing in translating Python tests to the Dafny verification language. Your task is to translate Python `assert` statements into Dafny test methods and provide a minimal dummy implementation for compilation checking.



=============== USER ===============
I need you to translate Python test assertions into Dafny test methods.

**The Method to Test:**
The Dafny method you need to test is named `add`.

**Python Test Code:**
```python
def check(candidate):

    # Check some simple cases
    assert candidate([4, 88]) == 88
    assert candidate([4, 5, 6, 7, 2, 122]) == 122
    assert candidate([4, 0, 6, 7]) == 0
    assert candidate([4, 4, 6, 8]) == 12

    # Check some edge cases that are easy to work out by hand.
    

```

**Dafny Solution Code (that these tests should test):**
```dafny
method add(lst: seq<int>) returns (result: int)
    requires |lst| > 0
    ensures result == SumEvenAtOddIndices(lst)
{
    var total := 0;
    var i := 1;
    
    while i < |lst|
        invariant 1 <= i
        invariant i % 2 == 1  // i is always odd
        invariant total == SumEvenAtOddIndicesUpTo(lst, i)
        decreases |lst| - i
    {
        if lst[i] % 2 == 0 {
            total := total + lst[i];
        }
        i := i + 2;
    }
    
    result := total;
}

function SumEvenAtOddIndices(lst: seq<int>): int
{
    SumEvenAtOddIndicesUpTo(lst, |lst|)
}

function SumEvenAtOddIndicesUpTo(lst: seq<int>, limit: int): int
    requires 0 <= limit <= |lst|
    decreases limit
{
    if limit <= 1 then 0
    else
        var prev := SumEvenAtOddIndicesUpTo(lst, limit - 1);
        var idx := limit - 1;
        if idx % 2 == 1 && lst[idx] % 2 == 0 then
            prev + lst[idx]
        else
            prev
}
```

**Your Task:**
1. **Analyze the tests and solution:**
   - Note the exact name (`add`) and signature of the Dafny method from the provided solution code.

2. **Create a minimal dummy implementation** (in a `<dummy>` block):
   - Create a dummy version of the `add` Dafny method.
   - The dummy should have the same signature as the method in the full Dafny solution and return appropriate default values (0 for int, false for bool, [] for sequences, etc.).
   - This dummy is ONLY for validating that the test code compiles correctly.

3. **Translate the tests** (in a ```dafny ... ``` block):
   - For each `assert` statement in the Python code, create a Dafny test method with `{:test}` attribute.
   - **All generated test methods must have a complete body and be runnable.**
   - Name them `test_0`, `test_1`, etc.
   - Convert scientific notation (e.g., 1e-6) to decimal form (e.g., 0.000001).
   - Each test method should:
     a. Call the `add` Dafny method and assign the result to a variable.
     b. Use `expect` to check if the result matches the expected value.

**Example:** If Python has `assert add(2, 3) == 5`, the method to test is `add`, and the Dafny solution has `function add(a: int, b: int): int`, then:
<dummy>
function add(a: int, b: int): int
{
    0
}
</dummy>

```dafny
method {:test} test_0()
{
    var result := add(2, 3);
    expect result == 5;
}
```



=============== ASSISTANT ===============
--- THINKING ---
Let me analyze the given code:

1. The Python tests are testing a `candidate` function that takes a list and returns an integer.
2. The Dafny solution code has a method named `add` that takes a `seq<int>` and returns an `int`.
3. Looking at the tests and the solution:
   - `candidate([4, 88])` should return `88`
   - `candidate([4, 5, 6, 7, 2, 122])` should return `122`
   - `candidate([4, 0, 6, 7])` should return `0`
   - `candidate([4, 4, 6, 8])` should return `12`

Looking at the solution code, it appears to sum even numbers at odd indices. Let me trace through:

For `[4, 88]`:
- Index 0: 4 (even index, skip)
- Index 1: 88 (odd index, 88 is even, add it)
- Result: 88 ✓

For `[4, 5, 6, 7, 2, 122]`:
- Index 0: 4 (even index, skip)
- Index 1: 5 (odd index, 5 is odd, skip)
- Index 2: 6 (even index, skip)
- Index 3: 7 (odd index, 7 is odd, skip)
- Index 4: 2 (even index, skip)
- Index 5: 122 (odd index, 122 is even, add it)
- Result: 122 ✓

For `[4, 0, 6, 7]`:
- Index 0: 4 (even index, skip)
- Index 1: 0 (odd index, 0 is even, add it)
- Index 2: 6 (even index, skip)  


- Index 3: 7 (odd index, 7 is odd, skip)
- Result: 0 ✓

For `[4, 4, 6, 8]`:
- Index 0: 4 (even index, skip)
- Index 1: 4 (odd index, 4 is even, add it)
- Index 2: 6 (even index, skip)
- Index 3: 8 (odd index, 8 is even, add it)
- Result: 4 + 8 = 12 ✓

I'll develop an algorithm that systematically processes the list, focusing on odd indices and selecting even numbers. The key steps involve:
- Iterating through the list
- Checking index parity
- Identifying even values
- Accumulating the sum

I'll implement a straightforward method in Dafny, starting with a basic zero-return placeholder and then constructing test sequences to validate the logic.

--- RESPONSE ---
Looking at the tests and solution code, I can see that:

1. The method to test is named `add` 
2. It takes a `seq<int>` parameter and returns an `int`
3. The tests verify that the method sums even numbers at odd indices

<dummy>
method add(lst: seq<int>) returns (result: int)
    requires |lst| > 0
{
    result := 0;
}
</dummy>

```dafny
method {:test} test_0()
{
    var result := add([4, 88]);
    expect result == 88;
}

method {:test} test_1()
{
    var result := add([4, 5, 6, 7, 2, 122]);
    expect result == 122;
}

method {:test} test_2()
{
    var result := add([4, 0, 6, 7]);
    expect result == 0;
}

method {:test} test_3()
{
    var result := add([4, 4, 6, 8]);
    expect result == 12;
}
```

