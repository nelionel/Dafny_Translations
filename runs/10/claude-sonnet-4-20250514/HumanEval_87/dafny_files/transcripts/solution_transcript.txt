=============== SYSTEM ===============
You are an expert programmer specializing in translating Python code to the Dafny verification language. Your task is to translate the provided Python function into a Dafny method that is both verifiable and compilable. Pay close attention to types, specifications, and providing concrete implementations for all methods.



=============== USER ===============
I will provide you with a Python function and its documentation. Please translate the Python function into a Dafny method.

**Python Function and Documentation:**
```python

def get_row(lst, x):
    """
    You are given a 2 dimensional data, as a nested lists,
    which is similar to matrix, however, unlike matrices,
    each row may contain a different number of columns.
    Given lst, and integer x, find integers x in the list,
    and return list of tuples, [(x1, y1), (x2, y2) ...] such that
    each tuple is a coordinate - (row, columns), starting with 0.
    Sort coordinates initially by rows in ascending order.
    Also, sort coordinates of the row by columns in descending order.
    
    Examples:
    get_row([
      [1,2,3,4,5,6],
      [1,2,3,4,1,6],
      [1,2,3,4,5,1]
    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]
    get_row([], 1) == []
    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]
    """

def get_row(lst, x):
    """
    You are given a 2 dimensional data, as a nested lists,
    which is similar to matrix, however, unlike matrices,
    each row may contain a different number of columns.
    Given lst, and integer x, find integers x in the list,
    and return list of tuples, [(x1, y1), (x2, y2) ...] such that
    each tuple is a coordinate - (row, columns), starting with 0.
    Sort coordinates initially by rows in ascending order.
    Also, sort coordinates of the row by columns in descending order.
    """
    coordinates = []
    
    # Find all occurrences of x
    for row_idx, row in enumerate(lst):
        for col_idx, value in enumerate(row):
            if value == x:
                coordinates.append((row_idx, col_idx))
    
    # Sort by row ascending, then by column descending
    coordinates.sort(key=lambda coord: (coord[0], -coord[1]))
    
    return coordinates
```

**Your Task:**
1.  **Reasoning (in a <thinking> block):**
    *   Analyze the Python code and its types. How will you map Python types (like lists of floats) to Dafny types (like `seq<real>`)?
    *   Analyze the function's logic. What are the pre-conditions (`requires`) and post-conditions (`ensures`)?
    *   Identify any loops and determine their invariants.
    *   Think about termination conditions for any recursive calls or loops.
2.  **Dafny Implementation (in a ```dafny ... ``` block):**
    *   Write the complete Dafny method, including its signature, `requires` clauses, `ensures` clauses, and the method body.
    *   **The return type of the main method must be a basic Dafny type.** Use `int`, `real`, `bool`, `string`, or a sequence of these types (e.g., `seq<int>`). Do not use custom `datatype`s in the return signature. If the Python code implies an optional return (e.g. returning `None`), you should return a sensible default for the basic type instead (e.g. `false`, `-1`, or an empty sequence `[]`).
    *   The Dafny method name must be exactly the same as the Python function name: `get_row`. Do not change the casing.
    *   **All methods must have a concrete implementation (a body).** The `{:axiom}` attribute is forbidden for defining standard functions. However, if the problem's solution relies on an unproven mathematical conjecture (e.g., the Goldbach Conjecture, P vs NP), you may state the conjecture as an `axiom`. If you do so, you **must** include a comment identifying the conjecture (e.g., `// Axiom for the Twin Prime Conjecture`). Do not use axioms to avoid implementing solvable algorithms.
    *   **Provide explicit termination proofs.** For any recursive function, you must include a `decreases` clause. Do **not** use `decreases *`. For functions that operate on a sequence, the termination metric is almost always the length of the sequence (e.g., `decreases my_sequence`). For functions on integers, it is the integer itself (e.g., `decreases n`).
    *   **Do not use Dafny reserved keywords as variable names.** Avoid names like: `abstract, allocated, as, assert, assume, bool, break, by, calc, case, char, class, codatatype, const, constructor, datatype, decreases, else, ensures, exists, export, extends, false, forall, fresh, function, ghost, if, imap, import, in, include, int, invariant, is, iset, iterator, label, lemma, map, match, method, modifies, modify, module, multiset, nameonly, nat, new, newtype, null, object, object?, old, opened, ORDINAL, predicate, print, provides,reads, real, refines, requires, return, returns, reveal, reveals, seq, set, static, string, then, this, trait, true, twostate, type, unchanged, var, while, witness, yield, yields`. For example, instead of `var array`, use `var arr`.



=============== ASSISTANT ===============
--- THINKING ---
Let me analyze the Python code:

1. The function `get_row(lst, x)` takes a 2D list (nested lists) and an integer `x`.
2. It searches for all occurrences of `x` in the 2D list.
3. It returns a list of tuples representing coordinates (row, column) where `x` was found.
4. The coordinates are sorted first by row (ascending), then by column (descending).

For the Dafny translation:
- `lst` will be `seq<seq<int>>` (sequence of sequences of integers)
- `x` will be `int`
- The return type will be `seq<(int, int)>` (sequence of tuples representing coordinates)

The logic:
1. Iterate through each row (with row index)
2. For each row, iterate through each element (with column index)
3. If the element equals `x`, add the coordinate (row_idx, col_idx) to the result
4. Sort the result by row ascending, then column descending

For the preconditions:
- No specific preconditions needed, the function should work with any valid 2D sequence.

For the postconditions:
- All returned coordinates should be valid indices in the input
- All coordinates should point to locations containing `x`
- The result should be sorted correctly

Let me think about the implementation:

```dafny
method get_row(lst: seq<seq<int>>, x: int) returns (coordinates: seq<(int, int)>)
{
    coordinates := [];
    
    for row_idx := 0 to |lst|
        invariant 0 <= row_idx <= |lst|
        invariant forall coord :: coord in coordinates ==> 0 <= coord.0 < row_idx && 0 <= coord.1 < |lst[coord.0]| && lst[coord.0][coord.1] == x
    {
        for col_idx := 0 to |lst[row_idx]|
            invariant 0 <= col_idx <= |lst[row_idx]|
            invariant forall coord :: coord in coordinates ==> 
                (coord.0 < row_idx || (coord.0 == row_idx && coord.1 < col_idx)) ==> 
                0 <= coord.0 < |lst| && 0 <= coord.1 < |lst[coord.0]| && lst[coord.0][coord.1] == x
        {
            if lst[row_idx][col_

I'll continue the nested loop's implementation, focusing on checking and adding matching coordinates to the result sequence.

idx] == x {
                coordinates := coordinates + [(row_idx, col_idx)];
            }
        }
    }
    
    I recognize I need a systematic way to organize the coordinates. The current approach requires careful sorting to meet the specific requirements. My strategy will involve collecting coordinates row by row, ensuring each row's coordinates are properly ordered before combining them into a final result.

The sorting challenge involves two key constraints: first sorting by row ascending, then within each row sorting by column in descending order. This means I'll need a method that can handle multi-level sorting efficiently.

I'm considering building a custom sorting approach that can handle these specific coordinate ordering requirements precisely and predictably. I'll find all occurrences of a value x in a 2D list, collecting their coordinates and sorting them efficiently. The method uses nested loops to scan the entire list, tracking row and column indices where x is found. A custom sorting function will order coordinates first by row, then by column in a specific way.

The approach prioritizes clarity and direct implementation, using insertion sort for coordinate arrangement. The comparison function ensures a predictable sorting order, first comparing rows, then columns with a nuanced descending column sorting strategy.

--- RESPONSE ---
<thinking>
Let me analyze the Python code:

1. The function `get_row(lst, x)` takes a 2D list (nested lists) and an integer `x`.
2. It finds all occurrences of `x` in the nested lists.
3. It returns coordinates as tuples (row, column) where `x` was found.
4. The coordinates are sorted first by row (ascending), then by column (descending).

For the Dafny translation:
- `lst` will be `seq<seq<int>>` (sequence of sequences of integers)
- `x` will be `int`
- The return type will be `seq<(int, int)>` (sequence of tuples representing coordinates)

I need to:
1. Iterate through each row and column to find occurrences of `x`
2. Collect all coordinates
3. Sort them according to the specified criteria (row ascending, column descending)

For the sorting, I can implement a simple comparison-based sort. The comparison should prioritize row index first (ascending), then column index (descending for same row).
</thinking>

```dafny
method get_row(lst: seq<seq<int>>, x: int) returns (coordinates: seq<(int, int)>)
    ensures forall coord :: coord in coordinates ==> 
        0 <= coord.0 < |lst| && 0 <= coord.1 < |lst[coord.0]| && lst[coord.0][coord.1] == x
    ensures forall i, j :: 0 <= i < j < |coordinates| ==> 
        coordinates[i].0 <= coordinates[j].0 && 
        (coordinates[i].0 == coordinates[j].0 ==> coordinates[i].1 >= coordinates[j].1)
{
    coordinates := [];
    
    // Find all occurrences of x
    for row_idx := 0 to |lst|
        invariant 0 <= row_idx <= |lst|
        invariant forall coord :: coord in coordinates ==> 
            0 <= coord.0 < row_idx && 0 <= coord.1 < |lst[coord.0]| && lst[coord.0][coord.1] == x
    {
        for col_idx := 0 to |lst[row_idx]|
            invariant 0 <= col_idx <= |lst[row_idx]|
            invariant forall coord :: coord in coordinates ==> 
                (coord.0 < row_idx || (coord.0 == row_idx && coord.1 >= col_idx)) ==> 
                0 <= coord.0 < |lst| && 0 <= coord.1 < |lst[coord.0]| && lst[coord.0][coord.1] == x
        {
            if lst[row_idx][col_idx] == x {
                coordinates := coordinates + [(row_idx, col_idx)];
            }
        }
    }
    
    // Sort coordinates: first by row ascending, then by column descending
    coordinates := SortCoordinates(coordinates);
}

method SortCoordinates(coords: seq<(int, int)>) returns (sorted: seq<(int, int)>)
    ensures |sorted| == |coords|
    ensures forall coord :: coord in coords <==> coord in sorted
    ensures forall i, j :: 0 <= i < j < |sorted| ==> 
        sorted[i].0 <= sorted[j].0 && 
        (sorted[i].0 == sorted[j].0 ==> sorted[i].1 >= sorted[j].1)
    decreases |coords|
{
    if |coords| <= 1 {
        sorted := coords;
        return;
    }
    
    // Simple insertion sort
    sorted := [];
    for i := 0 to |coords|
        invariant 0 <= i <= |coords|
        invariant |sorted| == i
        invariant forall coord :: coord in sorted ==> coord in coords
        invariant forall k, l :: 0 <= k < l < |sorted| ==> 
            sorted[k].0 <= sorted[l].0 && 
            (sorted[k].0 == sorted[l].0 ==> sorted[k].1 >= sorted[l].1)
    {
        var coord := coords[i];
        var j := |sorted|;
        
        while j > 0 && CompareCoordinates(sorted[j-1], coord) > 0
            invariant 0 <= j <= |sorted|
            decreases j
        {
            j := j - 1;
        }
        
        sorted := sorted[..j] + [coord] + sorted[j..];
    }
}

function CompareCoordinates(a: (int, int), b: (int, int)): int
{
    if a.0 < b.0 then -1
    else if a.0 > b.0 then 1
    else if a.1 > b.1 then -1  // descending order for columns within same row
    else if a.1 < b.1 then 1
    else 0
}
```

