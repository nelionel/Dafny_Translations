=============== SYSTEM ===============
You are an expert programmer specializing in translating Python code to the Dafny verification language. Your task is to translate the provided Python function into a Dafny method that is both verifiable and compilable. Pay close attention to types, specifications, and providing concrete implementations for all methods.



=============== USER ===============
I will provide you with a Python function and its documentation. Please translate the Python function into a Dafny method.

**Python Function and Documentation:**
```python

def sort_array(array):
    """
    Given an array of non-negative integers, return a copy of the given array after sorting,
    you will sort the given array in ascending order if the sum( first index value, last index value) is odd,
    or sort it in descending order if the sum( first index value, last index value) is even.

    Note:
    * don't change the given array.

    Examples:
    * sort_array([]) => []
    * sort_array([5]) => [5]
    * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2, 3, 4, 5]
    * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]
    """

def sort_array(array):
    """
    Given an array of non-negative integers, return a copy of the given array after sorting,
    you will sort the given array in ascending order if the sum( first index value, last index value) is odd,
    or sort it in descending order if the sum( first index value, last index value) is even.

    Note:
    * don't change the given array.

    Examples:
    * sort_array([]) => []
    * sort_array([5]) => [5]
    * sort_array([2, 4, 3, 0, 1, 5]) => [0, 1, 2, 3, 4, 5]
    * sort_array([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]
    """
    # Handle edge cases
    if len(array) <= 1:
        return array.copy()
    
    # Calculate sum of first and last elements
    first_last_sum = array[0] + array[-1]
    
    # Create a copy of the array
    array_copy = array.copy()
    
    # Sort based on whether sum is odd or even
    if first_last_sum % 2 == 1:  # odd sum
        array_copy.sort()  # ascending order
    else:  # even sum
        array_copy.sort(reverse=True)  # descending order
    
    return array_copy
```

**Your Task:**
1.  **Reasoning (in a <thinking> block):**
    *   Analyze the Python code and its types. How will you map Python types (like lists of floats) to Dafny types (like `seq<real>`)?
    *   Analyze the function's logic. What are the pre-conditions (`requires`) and post-conditions (`ensures`)?
    *   Identify any loops and determine their invariants.
    *   Think about termination conditions for any recursive calls or loops.
2.  **Dafny Implementation (in a ```dafny ... ``` block):**
    *   Write the complete Dafny method, including its signature, `requires` clauses, `ensures` clauses, and the method body.
    *   **The return type of the main method must be a basic Dafny type.** Use `int`, `real`, `bool`, `string`, or a sequence of these types (e.g., `seq<int>`). Do not use custom `datatype`s in the return signature. If the Python code implies an optional return (e.g. returning `None`), you should return a sensible default for the basic type instead (e.g. `false`, `-1`, or an empty sequence `[]`).
    *   The Dafny method name must be exactly the same as the Python function name: `sort_array`. Do not change the casing.
    *   **All methods must have a concrete implementation (a body).** The `{:axiom}` attribute is forbidden for defining standard functions. However, if the problem's solution relies on an unproven mathematical conjecture (e.g., the Goldbach Conjecture, P vs NP), you may state the conjecture as an `axiom`. If you do so, you **must** include a comment identifying the conjecture (e.g., `// Axiom for the Twin Prime Conjecture`). Do not use axioms to avoid implementing solvable algorithms.
    *   **Provide explicit termination proofs.** For any recursive function, you must include a `decreases` clause. Do **not** use `decreases *`. For functions that operate on a sequence, the termination metric is almost always the length of the sequence (e.g., `decreases my_sequence`). For functions on integers, it is the integer itself (e.g., `decreases n`).
    *   **Do not use Dafny reserved keywords as variable names.** Avoid names like: `abstract, allocated, as, assert, assume, bool, break, by, calc, case, char, class, codatatype, const, constructor, datatype, decreases, else, ensures, exists, export, extends, false, forall, fresh, function, ghost, if, imap, import, in, include, int, invariant, is, iset, iterator, label, lemma, map, match, method, modifies, modify, module, multiset, nameonly, nat, new, newtype, null, object, object?, old, opened, ORDINAL, predicate, print, provides,reads, real, refines, requires, return, returns, reveal, reveals, seq, set, static, string, then, this, trait, true, twostate, type, unchanged, var, while, witness, yield, yields`. For example, instead of `var array`, use `var arr`.



=============== ASSISTANT ===============
--- THINKING ---
Let me analyze the Python function:

1. It takes an array (sequence) of non-negative integers
2. If the length is 0 or 1, it returns a copy as is
3. Otherwise, it calculates the sum of the first and last elements
4. If the sum is odd, it sorts in ascending order
5. If the sum is even, it sorts in descending order
6. It returns a copy, not modifying the original array

Let me think about types:
- Input: `seq<nat>` (since they are non-negative integers)
- Output: `seq<nat>`

Pre-conditions:
- The array contains non-negative integers (already enforced by type `seq<nat>`)

Post-conditions:
- The returned array has the same length as the input
- The returned array is a permutation of the input array
- If length <= 1, the result equals the input
- If length > 1 and (first + last) is odd, the result is sorted in ascending order
- If length > 1 and (first + last) is even, the result is sorted in descending order

I need to implement sorting. In Dafny, I can't just call `.sort()` like in Python, so I need to implement a sorting algorithm or use Dafny's built-in sorting capabilities if available.

Actually, let me think about this more carefully. Dafny doesn't have built-in sorting functions that I can easily use in a method body. I'll need to implement sorting myself.

Let me implement a simple sorting algorithm like insertion sort or bubble sort. I'll go with a simpler approach and use bubble sort for clarity.

Wait, let me check what's available in Dafny standard library... Actually, for this exercise, I should implement the sorting myself to make it self-contained.

Let me implement bubble sort for both ascending and descending order.

--- RESPONSE ---
<thinking>
Let me analyze the Python function:

1. **Types**: The function takes a list of non-negative integers and returns a list of non-negative integers. In Dafny, this maps to `seq<nat>` for both input and output.

2. **Logic**: 
   - If array length ≤ 1, return a copy
   - Calculate sum of first and last elements
   - If sum is odd, sort ascending; if even, sort descending
   - Return the sorted copy

3. **Pre-conditions**: The input should be a sequence of non-negative integers (enforced by type `seq<nat>`)

4. **Post-conditions**:
   - Result has same length as input
   - Result is a permutation of input
   - If length ≤ 1, result equals input
   - If length > 1, sorting order depends on (first + last) % 2

5. **Implementation challenges**: Dafny doesn't have built-in sort methods, so I need to implement sorting algorithms (bubble sort for simplicity).

6. **Termination**: The sorting loops will decrease based on array indices.
</thinking>

```dafny
method sort_array(arr: seq<nat>) returns (result: seq<nat>)
  ensures |result| == |arr|
  ensures multiset(result) == multiset(arr)
  ensures |arr| <= 1 ==> result == arr
  ensures |arr| > 1 && (arr[0] + arr[|arr|-1]) % 2 == 1 ==> is_sorted_ascending(result)
  ensures |arr| > 1 && (arr[0] + arr[|arr|-1]) % 2 == 0 ==> is_sorted_descending(result)
{
  if |arr| <= 1 {
    return arr;
  }
  
  var first_last_sum := arr[0] + arr[|arr|-1];
  var arr_copy := arr;
  
  if first_last_sum % 2 == 1 {
    // Sort ascending
    arr_copy := bubble_sort_ascending(arr_copy);
  } else {
    // Sort descending  
    arr_copy := bubble_sort_descending(arr_copy);
  }
  
  return arr_copy;
}

method bubble_sort_ascending(arr: seq<nat>) returns (sorted: seq<nat>)
  ensures |sorted| == |arr|
  ensures multiset(sorted) == multiset(arr)
  ensures is_sorted_ascending(sorted)
{
  if |arr| <= 1 {
    return arr;
  }
  
  var a := arr;
  var n := |a|;
  var i := 0;
  
  while i < n
    invariant 0 <= i <= n
    invariant |a| == n
    invariant multiset(a) == multiset(arr)
    invariant forall k :: 0 <= k < i ==> forall j :: i <= j < n ==> a[k] <= a[j]
    invariant forall k :: 0 <= k < i-1 ==> a[k] <= a[k+1]
  {
    var j := 0;
    while j < n - 1 - i
      invariant 0 <= j <= n - 1 - i
      invariant |a| == n
      invariant multiset(a) == multiset(arr)
      invariant forall k :: 0 <= k < i ==> forall l :: i <= l < n ==> a[k] <= a[l]
      invariant forall k :: 0 <= k < i-1 ==> a[k] <= a[k+1]
      invariant forall k :: j+1 <= k < n - i ==> a[n-1-i] <= a[k]
    {
      if a[j] > a[j+1] {
        a := a[j := a[j+1]][j+1 := a[j]];
      }
      j := j + 1;
    }
    i := i + 1;
  }
  
  return a;
}

method bubble_sort_descending(arr: seq<nat>) returns (sorted: seq<nat>)
  ensures |sorted| == |arr|
  ensures multiset(sorted) == multiset(arr)
  ensures is_sorted_descending(sorted)
{
  if |arr| <= 1 {
    return arr;
  }
  
  var a := arr;
  var n := |a|;
  var i := 0;
  
  while i < n
    invariant 0 <= i <= n
    invariant |a| == n
    invariant multiset(a) == multiset(arr)
    invariant forall k :: 0 <= k < i ==> forall j :: i <= j < n ==> a[k] >= a[j]
    invariant forall k :: 0 <= k < i-1 ==> a[k] >= a[k+1]
  {
    var j := 0;
    while j < n - 1 - i
      invariant 0 <= j <= n - 1 - i
      invariant |a| == n
      invariant multiset(a) == multiset(arr)
      invariant forall k :: 0 <= k < i ==> forall l :: i <= l < n ==> a[k] >= a[l]
      invariant forall k :: 0 <= k < i-1 ==> a[k] >= a[k+1]
      invariant forall k :: j+1 <= k < n - i ==> a[n-1-i] >= a[k]
    {
      if a[j] < a[j+1] {
        a := a[j := a[j+1]][j+1 := a[j]];
      }
      j := j + 1;
    }
    i := i + 1;
  }
  
  return a;
}

predicate is_sorted_ascending(s: seq<nat>)
{
  forall i :: 0 <= i < |s| - 1 ==> s[i] <= s[i+1]
}

predicate is_sorted_descending(s: seq<nat>)
{
  forall i :: 0 <= i < |s| - 1 ==> s[i] >= s[i+1]
}
```

