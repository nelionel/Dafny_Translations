=============== SYSTEM ===============
You are an expert programmer specializing in translating Python tests to the Dafny verification language. Your task is to translate Python `assert` statements into Dafny test methods and provide a minimal dummy implementation for compilation checking.



=============== USER ===============
I need you to translate Python test assertions into Dafny test methods.

**The Method to Test:**
The Dafny method you need to test is named `sort_array`.

**Python Test Code:**
```python
def check(candidate):

    # Check some simple cases
    assert True, "This prints if this assert fails 1 (good for debugging!)"
    assert candidate([]) == [], "Error"
    assert candidate([5]) == [5], "Error"
    assert candidate([2, 4, 3, 0, 1, 5]) == [0, 1, 2, 3, 4, 5], "Error"
    assert candidate([2, 4, 3, 0, 1, 5, 6]) == [6, 5, 4, 3, 2, 1, 0], "Error"

    # Check some edge cases that are easy to work out by hand.
    assert True, "This prints if this assert fails 2 (also good for debugging!)"
    assert candidate([2, 1]) == [1, 2], "Error"
    assert candidate([15, 42, 87, 32 ,11, 0]) == [0, 11, 15, 32, 42, 87], "Error"
    assert candidate([21, 14, 23, 11]) == [23, 21, 14, 11], "Error"


```

**Dafny Solution Code (that these tests should test):**
```dafny
method sort_array(arr: seq<nat>) returns (result: seq<nat>)
  ensures |result| == |arr|
  ensures multiset(result) == multiset(arr)
  ensures |arr| <= 1 ==> result == arr
  ensures |arr| > 1 && (arr[0] + arr[|arr|-1]) % 2 == 1 ==> is_sorted_ascending(result)
  ensures |arr| > 1 && (arr[0] + arr[|arr|-1]) % 2 == 0 ==> is_sorted_descending(result)
{
  if |arr| <= 1 {
    return arr;
  }
  
  var first_last_sum := arr[0] + arr[|arr|-1];
  var arr_copy := arr;
  
  if first_last_sum % 2 == 1 {
    // Sort ascending
    arr_copy := bubble_sort_ascending(arr_copy);
  } else {
    // Sort descending  
    arr_copy := bubble_sort_descending(arr_copy);
  }
  
  return arr_copy;
}

method bubble_sort_ascending(arr: seq<nat>) returns (sorted: seq<nat>)
  ensures |sorted| == |arr|
  ensures multiset(sorted) == multiset(arr)
  ensures is_sorted_ascending(sorted)
{
  if |arr| <= 1 {
    return arr;
  }
  
  var a := arr;
  var n := |a|;
  var i := 0;
  
  while i < n
    invariant 0 <= i <= n
    invariant |a| == n
    invariant multiset(a) == multiset(arr)
    invariant forall k :: 0 <= k < i ==> forall j :: i <= j < n ==> a[k] <= a[j]
    invariant forall k :: 0 <= k < i-1 ==> a[k] <= a[k+1]
  {
    var j := 0;
    while j < n - 1 - i
      invariant 0 <= j <= n - 1 - i
      invariant |a| == n
      invariant multiset(a) == multiset(arr)
      invariant forall k :: 0 <= k < i ==> forall l :: i <= l < n ==> a[k] <= a[l]
      invariant forall k :: 0 <= k < i-1 ==> a[k] <= a[k+1]
      invariant forall k :: j+1 <= k < n - i ==> a[n-1-i] <= a[k]
    {
      if a[j] > a[j+1] {
        a := a[j := a[j+1]][j+1 := a[j]];
      }
      j := j + 1;
    }
    i := i + 1;
  }
  
  return a;
}

method bubble_sort_descending(arr: seq<nat>) returns (sorted: seq<nat>)
  ensures |sorted| == |arr|
  ensures multiset(sorted) == multiset(arr)
  ensures is_sorted_descending(sorted)
{
  if |arr| <= 1 {
    return arr;
  }
  
  var a := arr;
  var n := |a|;
  var i := 0;
  
  while i < n
    invariant 0 <= i <= n
    invariant |a| == n
    invariant multiset(a) == multiset(arr)
    invariant forall k :: 0 <= k < i ==> forall j :: i <= j < n ==> a[k] >= a[j]
    invariant forall k :: 0 <= k < i-1 ==> a[k] >= a[k+1]
  {
    var j := 0;
    while j < n - 1 - i
      invariant 0 <= j <= n - 1 - i
      invariant |a| == n
      invariant multiset(a) == multiset(arr)
      invariant forall k :: 0 <= k < i ==> forall l :: i <= l < n ==> a[k] >= a[l]
      invariant forall k :: 0 <= k < i-1 ==> a[k] >= a[k+1]
      invariant forall k :: j+1 <= k < n - i ==> a[n-1-i] >= a[k]
    {
      if a[j] < a[j+1] {
        a := a[j := a[j+1]][j+1 := a[j]];
      }
      j := j + 1;
    }
    i := i + 1;
  }
  
  return a;
}

predicate is_sorted_ascending(s: seq<nat>)
{
  forall i :: 0 <= i < |s| - 1 ==> s[i] <= s[i+1]
}

predicate is_sorted_descending(s: seq<nat>)
{
  forall i :: 0 <= i < |s| - 1 ==> s[i] >= s[i+1]
}
```

**Your Task:**
1. **Analyze the tests and solution:**
   - Note the exact name (`sort_array`) and signature of the Dafny method from the provided solution code.

2. **Create a minimal dummy implementation** (in a `<dummy>` block):
   - Create a dummy version of the `sort_array` Dafny method.
   - The dummy should have the same signature as the method in the full Dafny solution and return appropriate default values (0 for int, false for bool, [] for sequences, etc.).
   - This dummy is ONLY for validating that the test code compiles correctly.

3. **Translate the tests** (in a ```dafny ... ``` block):
   - For each `assert` statement in the Python code, create a Dafny test method with `{:test}` attribute.
   - **All generated test methods must have a complete body and be runnable.**
   - Name them `test_0`, `test_1`, etc.
   - Convert scientific notation (e.g., 1e-6) to decimal form (e.g., 0.000001).
   - Each test method should:
     a. Call the `sort_array` Dafny method and assign the result to a variable.
     b. Use `expect` to check if the result matches the expected value.

**Example:** If Python has `assert add(2, 3) == 5`, the method to test is `add`, and the Dafny solution has `function add(a: int, b: int): int`, then:
<dummy>
function add(a: int, b: int): int
{
    0
}
</dummy>

```dafny
method {:test} test_0()
{
    var result := add(2, 3);
    expect result == 5;
}
```



=============== ASSISTANT ===============
--- THINKING ---
Let me analyze the provided code:

1. The method to test is `sort_array` based on the Dafny solution code.
2. Looking at the solution, `sort_array` has signature: `method sort_array(arr: seq<nat>) returns (result: seq<nat>)`
3. The Python tests are:
   - `candidate([]) == []`
   - `candidate([5]) == [5]`
   - `candidate([2, 4, 3, 0, 1, 5]) == [0, 1, 2, 3, 4, 5]`
   - `candidate([2, 4, 3, 0, 1, 5, 6]) == [6, 5, 4, 3, 2, 1, 0]`
   - `candidate([2, 1]) == [1, 2]`
   - `candidate([15, 42, 87, 32 ,11, 0]) == [0, 11, 15, 32, 42, 87]`
   - `candidate([21, 14, 23, 11]) == [23, 21, 14, 11]`

I need to:
1. Create a dummy implementation of `sort_array` that returns an empty sequence
2. Create test methods for each assert

Let me create the dummy first:
- The method takes `arr: seq<nat>` and returns `result: seq<nat>`
- For dummy, I'll just return an empty sequence `[]`

For the tests, I need to convert Python lists to Dafny sequences:
- `[]` → `[]`
- `[5]` → `[5]`
- `[2, 4, 3, 0, 1, 5]` → `[2, 4, 3, 0, 1, 5]`
- etc.


I'll continue tracking the assertions systematically. I see six test cases so far, with one partially written. I'll carefully count and verify each unique test scenario to ensure comprehensive coverage of the sorting method's behavior.

The new test cases expand the range of input complexity:
6. `candidate([15, 42, 87, 32, 11, 0]) == [0, 11, 15, 32, 42, 87]`
7. `candidate([21, 14, 23, 11]) == [23, 21, 14, 11]`

These additional tests demonstrate the function's ability to handle:
- Mixed positive integers
- Unsorted input with varied magnitudes
- Different sorting patterns

I'll need test_0 through test_6 to validate the candidate function's implementation across diverse scenarios.

--- RESPONSE ---
<dummy>
method sort_array(arr: seq<nat>) returns (result: seq<nat>)
{
    result := [];
}
</dummy>

```dafny
method {:test} test_0()
{
    var result := sort_array([]);
    expect result == [];
}

method {:test} test_1()
{
    var result := sort_array([5]);
    expect result == [5];
}

method {:test} test_2()
{
    var result := sort_array([2, 4, 3, 0, 1, 5]);
    expect result == [0, 1, 2, 3, 4, 5];
}

method {:test} test_3()
{
    var result := sort_array([2, 4, 3, 0, 1, 5, 6]);
    expect result == [6, 5, 4, 3, 2, 1, 0];
}

method {:test} test_4()
{
    var result := sort_array([2, 1]);
    expect result == [1, 2];
}

method {:test} test_5()
{
    var result := sort_array([15, 42, 87, 32, 11, 0]);
    expect result == [0, 11, 15, 32, 42, 87];
}

method {:test} test_6()
{
    var result := sort_array([21, 14, 23, 11]);
    expect result == [23, 21, 14, 11];
}
```

