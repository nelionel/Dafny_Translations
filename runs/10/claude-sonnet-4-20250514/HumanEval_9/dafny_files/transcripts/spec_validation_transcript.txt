=============== SYSTEM ===============
You are an expert in formal verification and Dafny specifications. Your task is to analyze whether Dafny method specifications properly describe the behavior of the corresponding Python function.

You will be given:
1. A Python function with its behavior
2. A Dafny method translation with specifications (requires, ensures clauses)

Your job is to determine if the Dafny specifications fully and accurately capture the Python function's behavior. If not, you should improve the specifications.

IMPORTANT: You must respond with EXACTLY one of these phrases:
- "THE SCRIPT HAS PROPER SPECS" - if the specifications correctly describe the function
- "THE SCRIPT HAD NOT A PROPER SPEC" - if the specifications need improvement

After this phrase, provide the complete Dafny code (either unchanged or with improved specifications).



=============== USER ===============
Please analyze whether the Dafny specifications properly describe the Python function behavior.

**Python Function:**
```python
from typing import List, Tuple


def rolling_max(numbers: List[int]) -> List[int]:
    """ From a given list of integers, generate a list of rolling maximum element found until given moment
    in the sequence.
    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])
    [1, 2, 3, 3, 3, 4, 4]
    """
    if not numbers:
        return []
    
    result = []
    current_max = numbers[0]
    
    for num in numbers:
        current_max = max(current_max, num)
        result.append(current_max)
    
    return result
```

**Current Dafny Code:**
```dafny
method rolling_max(numbers: seq<int>) returns (result: seq<int>)
    ensures |result| == |numbers|
    ensures forall i :: 0 <= i < |result| ==> result[i] == max_up_to(numbers, i)
    ensures forall i :: 0 <= i < |result| - 1 ==> result[i] <= result[i+1]
{
    if |numbers| == 0 {
        return [];
    }
    
    result := [];
    var current_max := numbers[0];
    var index := 0;
    
    while index < |numbers|
        invariant 0 <= index <= |numbers|
        invariant |result| == index
        invariant index > 0 ==> current_max == max_up_to(numbers, index-1)
        invariant forall i :: 0 <= i < index ==> result[i] == max_up_to(numbers, i)
        invariant forall i :: 0 <= i < index - 1 ==> result[i] <= result[i+1]
        decreases |numbers| - index
    {
        if index == 0 {
            current_max := numbers[0];
        } else {
            current_max := if numbers[index] > current_max then numbers[index] else current_max;
        }
        result := result + [current_max];
        index := index + 1;
    }
}

function max_up_to(numbers: seq<int>, i: int): int
    requires 0 <= i < |numbers|
    decreases i
{
    if i == 0 then 
        numbers[0]
    else
        var prev_max := max_up_to(numbers, i-1);
        if numbers[i] > prev_max then numbers[i] else prev_max
}
```

**Analysis Task:**
1. Compare the Python function's behavior with the Dafny specifications
2. Check if the `requires` clauses capture all preconditions
3. Check if the `ensures` clauses capture all postconditions and behavior
4. Verify that the specifications fully describe what the function does

**Response Format:**
Start with exactly one of these phrases:
- "THE SCRIPT HAS PROPER SPECS" (if specifications are adequate)
- "THE SCRIPT HAD NOT A PROPER SPEC" (if specifications need improvement)

Then provide the complete Dafny code. If improving specifications:
- Add missing `requires` clauses for preconditions
- Add missing `ensures` clauses for postconditions
- Ensure specifications capture the function's complete behavior
- Preserve the existing method implementation unchanged

 


=============== ASSISTANT ===============
--- THINKING ---
Let me analyze the Python function and the Dafny specifications:

**Python function behavior:**
1. If the input list is empty, return an empty list
2. Otherwise, iterate through the list and maintain a running maximum
3. For each position i, the result[i] contains the maximum of all elements from index 0 to i (inclusive)
4. The result has the same length as the input

**Dafny specifications analysis:**

1. `ensures |result| == |numbers|` - This correctly captures that the result has the same length as input.

2. `ensures forall i :: 0 <= i < |result| ==> result[i] == max_up_to(numbers, i)` - This correctly captures that each element in the result is the maximum up to that position.

3. `ensures forall i :: 0 <= i < |result| - 1 ==> result[i] <= result[i+1]` - This captures that the sequence is non-decreasing, which is a property of rolling max.

4. The `max_up_to` function correctly defines what the maximum up to position i should be.

**Missing specifications:**
- There's no `requires` clause. The Python function handles empty lists, so there should be no preconditions needed.
- The ensures clauses seem to capture the behavior correctly.

Let me check if there are any edge cases:
- Empty input: Python returns [], Dafny specs should handle this correctly since |result| == |numbers| = 0
- Single element: Should work fine
- Multiple elements: The specs seem correct

Actually, let me double-check the specifications:

1. For empty sequence: |numbers| = 0, so |result| = 0, and the forall clauses are vacuously true. This matches Python behavior.

2. For non-empty sequence: Each result[i] should be max_up_to(numbers, i), which is the maximum from numbers[0] to numbers[i]. This matches the Python behavior.
 
The non-decreasing property ensures the rolling maximum increases or stays constant as we progress through the list. This specification guarantees that each subsequent element in the result will be greater than or equal to the previous one, accurately reflecting the cumulative maximum calculation.

--- RESPONSE ---
THE SCRIPT HAS PROPER SPECS

```dafny
method rolling_max(numbers: seq<int>) returns (result: seq<int>)
    ensures |result| == |numbers|
    ensures forall i :: 0 <= i < |result| ==> result[i] == max_up_to(numbers, i)
    ensures forall i :: 0 <= i < |result| - 1 ==> result[i] <= result[i+1]
{
    if |numbers| == 0 {
        return [];
    }
    
    result := [];
    var current_max := numbers[0];
    var index := 0;
    
    while index < |numbers|
        invariant 0 <= index <= |numbers|
        invariant |result| == index
        invariant index > 0 ==> current_max == max_up_to(numbers, index-1)
        invariant forall i :: 0 <= i < index ==> result[i] == max_up_to(numbers, i)
        invariant forall i :: 0 <= i < index - 1 ==> result[i] <= result[i+1]
        decreases |numbers| - index
    {
        if index == 0 {
            current_max := numbers[0];
        } else {
            current_max := if numbers[index] > current_max then numbers[index] else current_max;
        }
        result := result + [current_max];
        index := index + 1;
    }
}

function max_up_to(numbers: seq<int>, i: int): int
    requires 0 <= i < |numbers|
    decreases i
{
    if i == 0 then 
        numbers[0]
    else
        var prev_max := max_up_to(numbers, i-1);
        if numbers[i] > prev_max then numbers[i] else prev_max
}
```

