=============== SYSTEM ===============
You are an expert programmer specializing in translating Python code to the Dafny verification language. Your task is to translate the provided Python function into a Dafny method that is both verifiable and compilable. Pay close attention to types, specifications, and providing concrete implementations for all methods.



=============== USER ===============
I will provide you with a Python function and its documentation. Please translate the Python function into a Dafny method.

**Python Function and Documentation:**
```python

def is_bored(S):
    """
    You'll be given a string of words, and your task is to count the number
    of boredoms. A boredom is a sentence that starts with the word "I".
    Sentences are delimited by '.', '?' or '!'.
   
    For example:
    >>> is_bored("Hello world")
    0
    >>> is_bored("The sky is blue. The sun is shining. I love this weather")
    1
    """

def is_bored(S):
    """
    You'll be given a string of words, and your task is to count the number
    of boredoms. A boredom is a sentence that starts with the word "I".
    Sentences are delimited by '.', '?' or '!'.
   
    For example:
    >>> is_bored("Hello world")
    0
    >>> is_bored("The sky is blue. The sun is shining. I love this weather")
    1
    """
    import re
    
    # Split the string by sentence delimiters (., ?, !)
    sentences = re.split(r'[.?!]', S)
    
    boredom_count = 0
    
    for sentence in sentences:
        # Strip whitespace and check if sentence is not empty
        sentence = sentence.strip()
        if sentence:
            # Split into words and check if first word is "I"
            words = sentence.split()
            if words and words[0] == "I":
                boredom_count += 1
    
    return boredom_count
```

**Your Task:**
1.  **Reasoning (in a <thinking> block):**
    *   Analyze the Python code and its types. How will you map Python types (like lists of floats) to Dafny types (like `seq<real>`)?
    *   Analyze the function's logic. What are the pre-conditions (`requires`) and post-conditions (`ensures`)?
    *   Identify any loops and determine their invariants.
    *   Think about termination conditions for any recursive calls or loops.
2.  **Dafny Implementation (in a ```dafny ... ``` block):**
    *   Write the complete Dafny method, including its signature, `requires` clauses, `ensures` clauses, and the method body.
    *   **The return type of the main method must be a basic Dafny type.** Use `int`, `real`, `bool`, `string`, or a sequence of these types (e.g., `seq<int>`). Do not use custom `datatype`s in the return signature. If the Python code implies an optional return (e.g. returning `None`), you should return a sensible default for the basic type instead (e.g. `false`, `-1`, or an empty sequence `[]`).
    *   The Dafny method name must be exactly the same as the Python function name: `is_bored`. Do not change the casing.
    *   **All methods must have a concrete implementation (a body).** The `{:axiom}` attribute is forbidden for defining standard functions. However, if the problem's solution relies on an unproven mathematical conjecture (e.g., the Goldbach Conjecture, P vs NP), you may state the conjecture as an `axiom`. If you do so, you **must** include a comment identifying the conjecture (e.g., `// Axiom for the Twin Prime Conjecture`). Do not use axioms to avoid implementing solvable algorithms.
    *   **Provide explicit termination proofs.** For any recursive function, you must include a `decreases` clause. Do **not** use `decreases *`. For functions that operate on a sequence, the termination metric is almost always the length of the sequence (e.g., `decreases my_sequence`). For functions on integers, it is the integer itself (e.g., `decreases n`).
    *   **Do not use Dafny reserved keywords as variable names.** Avoid names like: `abstract, allocated, as, assert, assume, bool, break, by, calc, case, char, class, codatatype, const, constructor, datatype, decreases, else, ensures, exists, export, extends, false, forall, fresh, function, ghost, if, imap, import, in, include, int, invariant, is, iset, iterator, label, lemma, map, match, method, modifies, modify, module, multiset, nameonly, nat, new, newtype, null, object, object?, old, opened, ORDINAL, predicate, print, provides,reads, real, refines, requires, return, returns, reveal, reveals, seq, set, static, string, then, this, trait, true, twostate, type, unchanged, var, while, witness, yield, yields`. For example, instead of `var array`, use `var arr`.



=============== ASSISTANT ===============
--- THINKING ---
Let me analyze the Python code:

1. The function takes a string S as input
2. It splits the string by sentence delimiters (., ?, !)
3. For each sentence, it strips whitespace and checks if it's not empty
4. If the sentence is not empty, it splits it into words and checks if the first word is "I"
5. It counts how many sentences start with "I"
6. Returns the count

Now, let me think about how to translate this to Dafny:

1. Input: string (Dafny: `string`)
2. Output: integer count (Dafny: `int`)

I need to implement:
- Splitting the string by delimiters
- Trimming whitespace
- Splitting into words
- Checking if first word is "I"

For the splitting by delimiters, I'll need to iterate through the string and identify where the delimiters are, then extract substrings.

For trimming whitespace, I'll need to find the first and last non-whitespace characters.

For splitting into words, I'll need to split by spaces.

Let me think about the algorithm:
1. Iterate through the string and find all positions where delimiters occur
2. Extract substrings between these positions
3. For each substring, trim whitespace
4. Split into words by spaces
5. Check if first word is "I"

Actually, let me think of a simpler approach:
1. Iterate through the string character by character
2. When I encounter a delimiter, I process the current sentence
3. To process a sentence: trim it, split by spaces, check if first word is "I"

For the loop invariant, I need to think about what remains constant:
- The count of boredoms found so far
- The current position in the string
- The current sentence being built

Let me implement helper functions:
- isDelimiter(c: char): bool - checks if c is '.', '?', or '!'


- isWhitespace(c: char): bool - checks if c is a whitespace character
- trim(s: string): string - removes leading and trailing whitespace
- splitBySpaces(s: string): seq<string> - splits string by spaces
- startsWith(s: string, word: string): bool - checks if s starts with word

I'll create simple implementations for these helper functions to support my main algorithm. Each function will handle a specific task in processing the input string efficiently.

--- RESPONSE ---
<thinking>
Let me analyze the Python code:

1. The function takes a string S as input and returns an integer count
2. It splits the string by sentence delimiters (., ?, !)
3. For each sentence, it strips whitespace and checks if it's not empty
4. If the sentence is not empty, it splits it into words and checks if the first word is "I"
5. It counts how many sentences start with "I"

For the Dafny translation, I need to:
- Map Python's string type to Dafny's `string` type
- Map Python's integer return to Dafny's `int` type
- Implement string splitting functionality since Dafny doesn't have regex
- Handle whitespace trimming and word splitting

I'll need helper functions for:
- Checking if a character is a delimiter (., ?, !)
- Checking if a character is whitespace
- Trimming whitespace from a string
- Splitting a string into words by spaces
- Extracting sentences from the input string

For the main loop, I'll iterate through the string character by character, building sentences until I hit a delimiter, then process each sentence.

The loop invariant will track:
- Current position in the string
- Count of boredoms found so far
- Current sentence being built

Termination is guaranteed because we iterate through a finite string.
</thinking>

```dafny
method is_bored(S: string) returns (count: int)
    ensures count >= 0
{
    count := 0;
    var currentSentence := "";
    var i := 0;
    
    while i <= |S|
        invariant 0 <= i <= |S| + 1
        invariant count >= 0
        decreases |S| + 1 - i
    {
        if i == |S| || isDelimiter(S[i]) {
            // Process current sentence
            var trimmed := trim(currentSentence);
            if |trimmed| > 0 {
                var words := splitBySpaces(trimmed);
                if |words| > 0 && words[0] == "I" {
                    count := count + 1;
                }
            }
            currentSentence := "";
        } else {
            currentSentence := currentSentence + [S[i]];
        }
        i := i + 1;
    }
}

function isDelimiter(c: char): bool
{
    c == '.' || c == '?' || c == '!'
}

function isWhitespace(c: char): bool
{
    c == ' ' || c == '\t' || c == '\n' || c == '\r'
}

function trim(s: string): string
    ensures |trim(s)| <= |s|
{
    var start := findFirstNonWhitespace(s);
    var end := findLastNonWhitespace(s);
    if start == -1 then "" else s[start..end+1]
}

function findFirstNonWhitespace(s: string): int
    ensures -1 <= findFirstNonWhitespace(s) < |s|
    ensures findFirstNonWhitespace(s) == -1 ==> forall i :: 0 <= i < |s| ==> isWhitespace(s[i])
    ensures findFirstNonWhitespace(s) != -1 ==> !isWhitespace(s[findFirstNonWhitespace(s)])
{
    var i := 0;
    while i < |s|
        invariant 0 <= i <= |s|
        invariant forall j :: 0 <= j < i ==> isWhitespace(s[j])
        decreases |s| - i
    {
        if !isWhitespace(s[i]) {
            return i;
        }
        i := i + 1;
    }
    -1
}

function findLastNonWhitespace(s: string): int
    ensures -1 <= findLastNonWhitespace(s) < |s|
    ensures findLastNonWhitespace(s) == -1 ==> forall i :: 0 <= i < |s| ==> isWhitespace(s[i])
    ensures findLastNonWhitespace(s) != -1 ==> !isWhitespace(s[findLastNonWhitespace(s)])
{
    if |s| == 0 then return -1;
    var i := |s| - 1;
    while i >= 0
        invariant -1 <= i < |s|
        invariant forall j :: i < j < |s| ==> isWhitespace(s[j])
        decreases i + 1
    {
        if !isWhitespace(s[i]) {
            return i;
        }
        i := i - 1;
    }
    -1
}

function splitBySpaces(s: string): seq<string>
    ensures forall word :: word in splitBySpaces(s) ==> |word| > 0
{
    if |s| == 0 then []
    else splitBySpacesHelper(s, 0, [])
}

function splitBySpacesHelper(s: string, start: int, acc: seq<string>): seq<string>
    requires 0 <= start <= |s|
    ensures forall word :: word in splitBySpacesHelper(s, start, acc) ==> |word| > 0
    decreases |s| - start
{
    if start >= |s| then acc
    else if isWhitespace(s[start]) then
        splitBySpacesHelper(s, start + 1, acc)
    else
        var wordEnd := findNextWhitespace(s, start);
        var word := s[start..wordEnd];
        splitBySpacesHelper(s, wordEnd, acc + [word])
}

function findNextWhitespace(s: string, start: int): int
    requires 0 <= start <= |s|
    ensures start <= findNextWhitespace(s, start) <= |s|
    ensures findNextWhitespace(s, start) == |s| || isWhitespace(s[findNextWhitespace(s, start)])
    ensures forall i :: start <= i < findNextWhitespace(s, start) ==> !isWhitespace(s[i])
    decreases |s| - start
{
    if start >= |s| then |s|
    else if isWhitespace(s[start]) then start
    else findNextWhitespace(s, start + 1)
}
```


=============== USER ===============
Your previous attempt failed to compile. Here is the error message:
<compilation_error>
temp_compile.dfy(54,4): Error: invalid UnaryExpression
   |
54 |     while i < |s|
   |     ^

1 parse errors detected in temp_compile.dfy

</compilation_error>

Please analyze the error and provide the COMPLETE Dafny code again with the fix applied. 
Do not provide just the missing pieces - provide the entire solution including any helper functions, the main method, and all specifications. 


=============== ASSISTANT ===============
--- THINKING ---
The error is showing that there's a parse error at line 54, which seems to be in a while loop. Looking at my code, I see that I have a function `findFirstNonWhitespace` that uses a while loop, but functions in Dafny cannot have while loops - they need to be pure and terminating. I need to rewrite these as recursive functions or move the logic to methods.

Let me rewrite the solution to avoid while loops in functions and make sure everything compiles properly.

--- RESPONSE ---
```dafny
method is_bored(S: string) returns (count: int)
    ensures count >= 0
{
    count := 0;
    var currentSentence := "";
    var i := 0;
    
    while i <= |S|
        invariant 0 <= i <= |S| + 1
        invariant count >= 0
        decreases |S| + 1 - i
    {
        if i == |S| || isDelimiter(S[i]) {
            // Process current sentence
            var trimmed := trim(currentSentence);
            if |trimmed| > 0 {
                var words := splitBySpaces(trimmed);
                if |words| > 0 && words[0] == "I" {
                    count := count + 1;
                }
            }
            currentSentence := "";
        } else {
            currentSentence := currentSentence + [S[i]];
        }
        i := i + 1;
    }
}

function isDelimiter(c: char): bool
{
    c == '.' || c == '?' || c == '!'
}

function isWhitespace(c: char): bool
{
    c == ' ' || c == '\t' || c == '\n' || c == '\r'
}

function trim(s: string): string
    ensures |trim(s)| <= |s|
{
    var start := findFirstNonWhitespace(s, 0);
    var end := findLastNonWhitespace(s, |s| - 1);
    if start == -1 then "" else s[start..end+1]
}

function findFirstNonWhitespace(s: string, i: int): int
    requires 0 <= i <= |s|
    ensures -1 <= findFirstNonWhitespace(s, i) <= |s|
    ensures findFirstNonWhitespace(s, i) == -1 ==> forall j :: i <= j < |s| ==> isWhitespace(s[j])
    ensures findFirstNonWhitespace(s, i) != -1 ==> findFirstNonWhitespace(s, i) >= i && findFirstNonWhitespace(s, i) < |s| && !isWhitespace(s[findFirstNonWhitespace(s, i)])
    decreases |s| - i
{
    if i >= |s| then -1
    else if !isWhitespace(s[i]) then i
    else findFirstNonWhitespace(s, i + 1)
}

function findLastNonWhitespace(s: string, i: int): int
    requires -1 <= i < |s|
    ensures -1 <= findLastNonWhitespace(s, i) <= i
    ensures findLastNonWhitespace(s, i) == -1 ==> forall j :: 0 <= j <= i ==> isWhitespace(s[j])
    ensures findLastNonWhitespace(s, i) != -1 ==> findLastNonWhitespace(s, i) >= 0 && !isWhitespace(s[findLastNonWhitespace(s, i)])
    decreases i + 1
{
    if i < 0 then -1
    else if !isWhitespace(s[i]) then i
    else findLastNonWhitespace(s, i - 1)
}

function splitBySpaces(s: string): seq<string>
    ensures forall word :: word in splitBySpaces(s) ==> |word| > 0
{
    if |s| == 0 then []
    else splitBySpacesHelper(s, 0, [])
}

function splitBySpacesHelper(s: string, start: int, acc: seq<string>): seq<string>
    requires 0 <= start <= |s|
    ensures forall word :: word in splitBySpacesHelper(s, start, acc) ==> |word| > 0
    decreases |s| - start
{
    if start >= |s| then acc
    else if isWhitespace(s[start]) then
        splitBySpacesHelper(s, start + 1, acc)
    else
        var wordEnd := findNextWhitespace(s, start);
        var word := s[start..wordEnd];
        splitBySpacesHelper(s, wordEnd, acc + [word])
}

function findNextWhitespace(s: string, start: int): int
    requires 0 <= start <= |s|
    ensures start <= findNextWhitespace(s, start) <= |s|
    ensures findNextWhitespace(s, start) == |s| || isWhitespace(s[findNextWhitespace(s, start)])
    ensures forall i :: start <= i < findNextWhitespace(s, start) ==> !isWhitespace(s[i])
    decreases |s| - start
{
    if start >= |s| then |s|
    else if isWhitespace(s[start]) then start
    else findNextWhitespace(s, start + 1)
}
```

