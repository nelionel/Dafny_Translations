=============== SYSTEM ===============
You are an expert programmer specializing in translating Python tests to the Dafny verification language. Your task is to translate Python `assert` statements into Dafny test methods and provide a minimal dummy implementation for compilation checking.



=============== USER ===============
I need you to translate Python test assertions into Dafny test methods.

**The Method to Test:**
The Dafny method you need to test is named `is_bored`.

**Python Test Code:**
```python
def check(candidate):

    # Check some simple cases
    assert candidate("Hello world") == 0, "Test 1"
    assert candidate("Is the sky blue?") == 0, "Test 2"
    assert candidate("I love It !") == 1, "Test 3"
    assert candidate("bIt") == 0, "Test 4"
    assert candidate("I feel good today. I will be productive. will kill It") == 2, "Test 5"
    assert candidate("You and I are going for a walk") == 0, "Test 6"

    # Check some edge cases that are easy to work out by hand.
    assert True, "This prints if this assert fails 2 (also good for debugging!)"


```

**Dafny Solution Code (that these tests should test):**
```dafny
method is_bored(S: string) returns (count: int)
    ensures count >= 0
{
    count := 0;
    var currentSentence := "";
    var i := 0;
    
    while i <= |S|
        invariant 0 <= i <= |S| + 1
        invariant count >= 0
        decreases |S| + 1 - i
    {
        if i == |S| || isDelimiter(S[i]) {
            // Process current sentence
            var trimmed := trim(currentSentence);
            if |trimmed| > 0 {
                var words := splitBySpaces(trimmed);
                if |words| > 0 && words[0] == "I" {
                    count := count + 1;
                }
            }
            currentSentence := "";
        } else {
            currentSentence := currentSentence + [S[i]];
        }
        i := i + 1;
    }
}

function isDelimiter(c: char): bool
{
    c == '.' || c == '?' || c == '!'
}

function isWhitespace(c: char): bool
{
    c == ' ' || c == '\t' || c == '\n' || c == '\r'
}

function trim(s: string): string
    ensures |trim(s)| <= |s|
{
    var start := findFirstNonWhitespace(s, 0);
    var end := findLastNonWhitespace(s, |s| - 1);
    if start == -1 then "" else s[start..end+1]
}

function findFirstNonWhitespace(s: string, i: int): int
    requires 0 <= i <= |s|
    ensures -1 <= findFirstNonWhitespace(s, i) <= |s|
    ensures findFirstNonWhitespace(s, i) == -1 ==> forall j :: i <= j < |s| ==> isWhitespace(s[j])
    ensures findFirstNonWhitespace(s, i) != -1 ==> findFirstNonWhitespace(s, i) >= i && findFirstNonWhitespace(s, i) < |s| && !isWhitespace(s[findFirstNonWhitespace(s, i)])
    decreases |s| - i
{
    if i >= |s| then -1
    else if !isWhitespace(s[i]) then i
    else findFirstNonWhitespace(s, i + 1)
}

function findLastNonWhitespace(s: string, i: int): int
    requires -1 <= i < |s|
    ensures -1 <= findLastNonWhitespace(s, i) <= i
    ensures findLastNonWhitespace(s, i) == -1 ==> forall j :: 0 <= j <= i ==> isWhitespace(s[j])
    ensures findLastNonWhitespace(s, i) != -1 ==> findLastNonWhitespace(s, i) >= 0 && !isWhitespace(s[findLastNonWhitespace(s, i)])
    decreases i + 1
{
    if i < 0 then -1
    else if !isWhitespace(s[i]) then i
    else findLastNonWhitespace(s, i - 1)
}

function splitBySpaces(s: string): seq<string>
    ensures forall word :: word in splitBySpaces(s) ==> |word| > 0
{
    if |s| == 0 then []
    else splitBySpacesHelper(s, 0, [])
}

function splitBySpacesHelper(s: string, start: int, acc: seq<string>): seq<string>
    requires 0 <= start <= |s|
    ensures forall word :: word in splitBySpacesHelper(s, start, acc) ==> |word| > 0
    decreases |s| - start
{
    if start >= |s| then acc
    else if isWhitespace(s[start]) then
        splitBySpacesHelper(s, start + 1, acc)
    else
        var wordEnd := findNextWhitespace(s, start);
        var word := s[start..wordEnd];
        splitBySpacesHelper(s, wordEnd, acc + [word])
}

function findNextWhitespace(s: string, start: int): int
    requires 0 <= start <= |s|
    ensures start <= findNextWhitespace(s, start) <= |s|
    ensures findNextWhitespace(s, start) == |s| || isWhitespace(s[findNextWhitespace(s, start)])
    ensures forall i :: start <= i < findNextWhitespace(s, start) ==> !isWhitespace(s[i])
    decreases |s| - start
{
    if start >= |s| then |s|
    else if isWhitespace(s[start]) then start
    else findNextWhitespace(s, start + 1)
}
```

**Your Task:**
1. **Analyze the tests and solution:**
   - Note the exact name (`is_bored`) and signature of the Dafny method from the provided solution code.

2. **Create a minimal dummy implementation** (in a `<dummy>` block):
   - Create a dummy version of the `is_bored` Dafny method.
   - The dummy should have the same signature as the method in the full Dafny solution and return appropriate default values (0 for int, false for bool, [] for sequences, etc.).
   - This dummy is ONLY for validating that the test code compiles correctly.

3. **Translate the tests** (in a ```dafny ... ``` block):
   - For each `assert` statement in the Python code, create a Dafny test method with `{:test}` attribute.
   - **All generated test methods must have a complete body and be runnable.**
   - Name them `test_0`, `test_1`, etc.
   - Convert scientific notation (e.g., 1e-6) to decimal form (e.g., 0.000001).
   - Each test method should:
     a. Call the `is_bored` Dafny method and assign the result to a variable.
     b. Use `expect` to check if the result matches the expected value.

**Example:** If Python has `assert add(2, 3) == 5`, the method to test is `add`, and the Dafny solution has `function add(a: int, b: int): int`, then:
<dummy>
function add(a: int, b: int): int
{
    0
}
</dummy>

```dafny
method {:test} test_0()
{
    var result := add(2, 3);
    expect result == 5;
}
```



=============== ASSISTANT ===============
--- THINKING ---
Let me analyze this step by step:

1. **Analyze the tests and solution:**
   - The method to test is `is_bored` with signature `method is_bored(S: string) returns (count: int)`
   - Looking at the Python tests:
     - `candidate("Hello world") == 0` - no sentences starting with "I"
     - `candidate("Is the sky blue?") == 0` - sentence starts with "Is", not "I"
     - `candidate("I love It !") == 1` - sentence starts with "I"
     - `candidate("bIt") == 0` - sentence starts with "bIt", not "I"
     - `candidate("I feel good today. I will be productive. will kill It") == 2` - two sentences start with "I": "I feel good today" and "I will be productive"
     - `candidate("You and I are going for a walk") == 0` - sentence starts with "You", not "I"

2. **Create a minimal dummy implementation:**
   - The method signature is `method is_bored(S: string) returns (count: int)`
   - It should return an int, so I'll return 0 as default

3. **Translate the tests:**
   - Test 0: `is_bored("Hello world") == 0`
   - Test 1: `is_bored("Is the sky blue?") == 0`
   - Test 2: `is_bored("I love It !") == 1`
   - Test 3: `is_bored("bIt") == 0`
   - Test 4: `is_bored("I feel good today. I will be productive. will kill It") == 2`
   - Test 5: `is_bored("You and I are going for a walk") == 0`
   - The last assert is just `assert True` which always passes, so I can skip it or make a simple test that always passes.
   
I'll break down the problem into key requirements. The function needs to count sentences starting with "I", which means:
- Split the input string into sentences
- Check if each sentence begins with "I "
- Count and return the number of such sentences

--- RESPONSE ---
Looking at the provided Python tests and Dafny solution code:

1. **Method Analysis:** The method to test is `is_bored` with signature `method is_bored(S: string) returns (count: int)`

2. **Dummy Implementation:**

<dummy>
method is_bored(S: string) returns (count: int)
{
    count := 0;
}
</dummy>

3. **Test Translation:**

```dafny
method {:test} test_0()
{
    var result := is_bored("Hello world");
    expect result == 0;
}

method {:test} test_1()
{
    var result := is_bored("Is the sky blue?");
    expect result == 0;
}

method {:test} test_2()
{
    var result := is_bored("I love It !");
    expect result == 1;
}

method {:test} test_3()
{
    var result := is_bored("bIt");
    expect result == 0;
}

method {:test} test_4()
{
    var result := is_bored("I feel good today. I will be productive. will kill It");
    expect result == 2;
}

method {:test} test_5()
{
    var result := is_bored("You and I are going for a walk");
    expect result == 0;
}

method {:test} test_6()
{
    // This corresponds to "assert True" which always passes
    expect true;
}
```

