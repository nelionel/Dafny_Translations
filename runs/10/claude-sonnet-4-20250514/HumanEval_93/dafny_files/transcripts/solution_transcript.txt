=============== SYSTEM ===============
You are an expert programmer specializing in translating Python code to the Dafny verification language. Your task is to translate the provided Python function into a Dafny method that is both verifiable and compilable. Pay close attention to types, specifications, and providing concrete implementations for all methods.



=============== USER ===============
I will provide you with a Python function and its documentation. Please translate the Python function into a Dafny method.

**Python Function and Documentation:**
```python

def encode(message):
    """
    Write a function that takes a message, and encodes in such a 
    way that it swaps case of all letters, replaces all vowels in 
    the message with the letter that appears 2 places ahead of that 
    vowel in the english alphabet. 
    Assume only letters. 
    
    Examples:
    >>> encode('test')
    'TGST'
    >>> encode('This is a message')
    'tHKS KS C MGSSCGG'
    """

def encode(message):
    """
    Write a function that takes a message, and encodes in such a 
    way that it swaps case of all letters, replaces all vowels in 
    the message with the letter that appears 2 places ahead of that 
    vowel in the english alphabet. 
    Assume only letters. 
    
    Examples:
    >>> encode('test')
    'TGST'
    >>> encode('This is a message')
    'tHKS KS C MGSSCGG'
    """
    vowels = 'aeiouAEIOU'
    vowel_mapping = {
        'a': 'c', 'e': 'g', 'i': 'k', 'o': 'q', 'u': 'w',
        'A': 'C', 'E': 'G', 'I': 'K', 'O': 'Q', 'U': 'W'
    }
    
    result = []
    
    for char in message:
        if char == ' ':
            result.append(' ')
        elif char in vowels:
            # Replace vowel with letter 2 places ahead, then swap case
            new_char = vowel_mapping[char]
            result.append(new_char.swapcase())
        else:
            # Just swap case for consonants
            result.append(char.swapcase())
    
    return ''.join(result)
```

**Your Task:**
1.  **Reasoning (in a <thinking> block):**
    *   Analyze the Python code and its types. How will you map Python types (like lists of floats) to Dafny types (like `seq<real>`)?
    *   Analyze the function's logic. What are the pre-conditions (`requires`) and post-conditions (`ensures`)?
    *   Identify any loops and determine their invariants.
    *   Think about termination conditions for any recursive calls or loops.
2.  **Dafny Implementation (in a ```dafny ... ``` block):**
    *   Write the complete Dafny method, including its signature, `requires` clauses, `ensures` clauses, and the method body.
    *   **The return type of the main method must be a basic Dafny type.** Use `int`, `real`, `bool`, `string`, or a sequence of these types (e.g., `seq<int>`). Do not use custom `datatype`s in the return signature. If the Python code implies an optional return (e.g. returning `None`), you should return a sensible default for the basic type instead (e.g. `false`, `-1`, or an empty sequence `[]`).
    *   The Dafny method name must be exactly the same as the Python function name: `encode`. Do not change the casing.
    *   **All methods must have a concrete implementation (a body).** The `{:axiom}` attribute is forbidden for defining standard functions. However, if the problem's solution relies on an unproven mathematical conjecture (e.g., the Goldbach Conjecture, P vs NP), you may state the conjecture as an `axiom`. If you do so, you **must** include a comment identifying the conjecture (e.g., `// Axiom for the Twin Prime Conjecture`). Do not use axioms to avoid implementing solvable algorithms.
    *   **Provide explicit termination proofs.** For any recursive function, you must include a `decreases` clause. Do **not** use `decreases *`. For functions that operate on a sequence, the termination metric is almost always the length of the sequence (e.g., `decreases my_sequence`). For functions on integers, it is the integer itself (e.g., `decreases n`).
    *   **Do not use Dafny reserved keywords as variable names.** Avoid names like: `abstract, allocated, as, assert, assume, bool, break, by, calc, case, char, class, codatatype, const, constructor, datatype, decreases, else, ensures, exists, export, extends, false, forall, fresh, function, ghost, if, imap, import, in, include, int, invariant, is, iset, iterator, label, lemma, map, match, method, modifies, modify, module, multiset, nameonly, nat, new, newtype, null, object, object?, old, opened, ORDINAL, predicate, print, provides,reads, real, refines, requires, return, returns, reveal, reveals, seq, set, static, string, then, this, trait, true, twostate, type, unchanged, var, while, witness, yield, yields`. For example, instead of `var array`, use `var arr`.



=============== ASSISTANT ===============
--- THINKING ---
Let's analyze the Python code:

1. The function takes a message (string) and encodes it by:
   - Swapping case of all letters
   - Replacing vowels with letters 2 positions ahead in the alphabet
   - Keeping spaces unchanged

2. The vowel mapping is:
   - 'a' -> 'c', 'e' -> 'g', 'i' -> 'k', 'o' -> 'q', 'u' -> 'w'
   - 'A' -> 'C', 'E' -> 'G', 'I' -> 'K', 'O' -> 'Q', 'U' -> 'W'

3. The logic:
   - For each character:
     - If it's a space, keep it as space
     - If it's a vowel, replace it with the mapped character and swap case
     - If it's a consonant, just swap case

For Dafny:
- Input type: `string` (which is `seq<char>` in Dafny)
- Output type: `string`
- No preconditions needed since we assume only letters and spaces
- Post-condition: the length of the result equals the length of the input

I need to implement helper functions:
1. A function to check if a character is a vowel
2. A function to get the vowel mapping
3. A function to swap case of a character

Let me think about the loop invariant:
- The result sequence has the same length as the processed portion of the input
- Each character in the result is correctly encoded according to the rules

Let me write the Dafny code:

--- RESPONSE ---
<thinking>
Let me analyze the Python code:

1. **Types mapping**: The input is a string (message) and output is a string. In Dafny, strings are `seq<char>`.

2. **Logic analysis**: 
   - For each character in the message:
     - If it's a space, keep it unchanged
     - If it's a vowel (a,e,i,o,u,A,E,I,O,U), replace with letter 2 positions ahead and swap case
     - If it's a consonant, just swap case
   
3. **Pre/post conditions**:
   - No specific preconditions needed
   - Post-condition: result length equals input length
   
4. **Loop invariants**: 
   - The result built so far has correct length
   - Each processed character follows the encoding rules

5. **Helper functions needed**:
   - Function to check if character is vowel
   - Function to map vowels to their replacements
   - Function to swap case of characters

6. **Termination**: The main loop processes the input sequence, so `decreases |message|` works.
</thinking>

```dafny
method encode(message: string) returns (result: string)
  ensures |result| == |message|
{
  result := "";
  var i := 0;
  
  while i < |message|
    invariant 0 <= i <= |message|
    invariant |result| == i
    decreases |message| - i
  {
    var char := message[i];
    
    if char == ' ' {
      result := result + [' '];
    } else if isVowel(char) {
      var mappedChar := mapVowel(char);
      var swappedChar := swapCase(mappedChar);
      result := result + [swappedChar];
    } else {
      var swappedChar := swapCase(char);
      result := result + [swappedChar];
    }
    
    i := i + 1;
  }
}

function isVowel(c: char): bool
{
  c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u' ||
  c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U'
}

function mapVowel(c: char): char
  requires isVowel(c)
{
  match c
    case 'a' => 'c'
    case 'e' => 'g' 
    case 'i' => 'k'
    case 'o' => 'q'
    case 'u' => 'w'
    case 'A' => 'C'
    case 'E' => 'G'
    case 'I' => 'K'
    case 'O' => 'Q'
    case 'U' => 'W'
}

function swapCase(c: char): char
{
  if 'a' <= c <= 'z' then
    (c as int - 'a' as int + 'A' as int) as char
  else if 'A' <= c <= 'Z' then
    (c as int - 'A' as int + 'a' as int) as char
  else
    c
}
```


=============== USER ===============
Your previous attempt failed to compile. Here is the error message:
<compilation_error>
temp_compile.dfy(12,8): Error: invalid Ident
   |
12 |     var char := message[i];
   |         ^

temp_compile.dfy(14,7): Error: invalid IfStmt
   |
14 |     if char == ' ' {
   |        ^

2 parse errors detected in temp_compile.dfy

</compilation_error>

Please analyze the error and provide the COMPLETE Dafny code again with the fix applied. 
Do not provide just the missing pieces - provide the entire solution including any helper functions, the main method, and all specifications. 


=============== ASSISTANT ===============
--- THINKING ---
The error is that I used `char` as a variable name, but `char` is a reserved keyword in Dafny. I need to use a different variable name like `ch` or `character`.

Let me rewrite the complete solution:

--- RESPONSE ---
```dafny
method encode(message: string) returns (result: string)
  ensures |result| == |message|
{
  result := "";
  var i := 0;
  
  while i < |message|
    invariant 0 <= i <= |message|
    invariant |result| == i
    decreases |message| - i
  {
    var ch := message[i];
    
    if ch == ' ' {
      result := result + [' '];
    } else if isVowel(ch) {
      var mappedChar := mapVowel(ch);
      var swappedChar := swapCase(mappedChar);
      result := result + [swappedChar];
    } else {
      var swappedChar := swapCase(ch);
      result := result + [swappedChar];
    }
    
    i := i + 1;
  }
}

function isVowel(c: char): bool
{
  c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u' ||
  c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U'
}

function mapVowel(c: char): char
  requires isVowel(c)
{
  match c
    case 'a' => 'c'
    case 'e' => 'g' 
    case 'i' => 'k'
    case 'o' => 'q'
    case 'u' => 'w'
    case 'A' => 'C'
    case 'E' => 'G'
    case 'I' => 'K'
    case 'O' => 'Q'
    case 'U' => 'W'
}

function swapCase(c: char): char
{
  if 'a' <= c <= 'z' then
    (c as int - 'a' as int + 'A' as int) as char
  else if 'A' <= c <= 'Z' then
    (c as int - 'A' as int + 'a' as int) as char
  else
    c
}
```

