=============== SYSTEM ===============
You are an expert programmer specializing in translating Python code to the Dafny verification language. Your task is to translate the provided Python function into a Dafny method that is both verifiable and compilable. Pay close attention to types, specifications, and providing concrete implementations for all methods.



=============== USER ===============
I will provide you with a Python function and its documentation. Please translate the Python function into a Dafny method.

**Python Function and Documentation:**
```python

def check_dict_case(dict):
    """
    Given a dictionary, return True if all keys are strings in lower 
    case or all keys are strings in upper case, else return False.
    The function should return False is the given dictionary is empty.
    Examples:
    check_dict_case({"a":"apple", "b":"banana"}) should return True.
    check_dict_case({"a":"apple", "A":"banana", "B":"banana"}) should return False.
    check_dict_case({"a":"apple", 8:"banana", "a":"apple"}) should return False.
    check_dict_case({"Name":"John", "Age":"36", "City":"Houston"}) should return False.
    check_dict_case({"STATE":"NC", "ZIP":"12345" }) should return True.
    """

def check_dict_case(dict):
    """
    Given a dictionary, return True if all keys are strings in lower 
    case or all keys are strings in upper case, else return False.
    The function should return False is the given dictionary is empty.
    """
    # Return False if dictionary is empty
    if not dict:
        return False
    
    # Check if all keys are strings
    if not all(isinstance(key, str) for key in dict.keys()):
        return False
    
    # Get all keys as strings (we already verified they're all strings)
    keys = list(dict.keys())
    
    # Check if all keys are lowercase
    all_lower = all(key.islower() for key in keys)
    
    # Check if all keys are uppercase
    all_upper = all(key.isupper() for key in keys)
    
    # Return True if all keys are either all lowercase or all uppercase
    return all_lower or all_upper
```

**Your Task:**
1.  **Reasoning (in a <thinking> block):**
    *   Analyze the Python code and its types. How will you map Python types (like lists of floats) to Dafny types (like `seq<real>`)?
    *   Analyze the function's logic. What are the pre-conditions (`requires`) and post-conditions (`ensures`)?
    *   Identify any loops and determine their invariants.
    *   Think about termination conditions for any recursive calls or loops.
2.  **Dafny Implementation (in a ```dafny ... ``` block):**
    *   Write the complete Dafny method, including its signature, `requires` clauses, `ensures` clauses, and the method body.
    *   **The return type of the main method must be a basic Dafny type.** Use `int`, `real`, `bool`, `string`, or a sequence of these types (e.g., `seq<int>`). Do not use custom `datatype`s in the return signature. If the Python code implies an optional return (e.g. returning `None`), you should return a sensible default for the basic type instead (e.g. `false`, `-1`, or an empty sequence `[]`).
    *   The Dafny method name must be exactly the same as the Python function name: `check_dict_case`. Do not change the casing.
    *   **All methods must have a concrete implementation (a body).** The `{:axiom}` attribute is forbidden for defining standard functions. However, if the problem's solution relies on an unproven mathematical conjecture (e.g., the Goldbach Conjecture, P vs NP), you may state the conjecture as an `axiom`. If you do so, you **must** include a comment identifying the conjecture (e.g., `// Axiom for the Twin Prime Conjecture`). Do not use axioms to avoid implementing solvable algorithms.
    *   **Provide explicit termination proofs.** For any recursive function, you must include a `decreases` clause. Do **not** use `decreases *`. For functions that operate on a sequence, the termination metric is almost always the length of the sequence (e.g., `decreases my_sequence`). For functions on integers, it is the integer itself (e.g., `decreases n`).
    *   **Do not use Dafny reserved keywords as variable names.** Avoid names like: `abstract, allocated, as, assert, assume, bool, break, by, calc, case, char, class, codatatype, const, constructor, datatype, decreases, else, ensures, exists, export, extends, false, forall, fresh, function, ghost, if, imap, import, in, include, int, invariant, is, iset, iterator, label, lemma, map, match, method, modifies, modify, module, multiset, nameonly, nat, new, newtype, null, object, object?, old, opened, ORDINAL, predicate, print, provides,reads, real, refines, requires, return, returns, reveal, reveals, seq, set, static, string, then, this, trait, true, twostate, type, unchanged, var, while, witness, yield, yields`. For example, instead of `var array`, use `var arr`.



=============== ASSISTANT ===============
--- THINKING ---
Let me analyze the Python function first:

1. The function takes a dictionary as input
2. It returns False if the dictionary is empty
3. It returns False if not all keys are strings
4. It returns True if all keys are strings and they are either all lowercase or all uppercase
5. Otherwise it returns False

For Dafny, I need to think about how to represent a dictionary. In Dafny, I could use a map type `map<string, string>` since dictionaries in this context seem to have string keys and string values (though the values could be anything).

Actually, looking at the examples:
- `{"a":"apple", "b":"banana"}` - string keys, string values
- `{"a":"apple", "A":"banana", "B":"banana"}` - string keys, string values  
- `{"a":"apple", 8:"banana", "a":"apple"}` - mixed keys (string and int), string values
- `{"Name":"John", "Age":"36", "City":"Houston"}` - string keys, string values
- `{"STATE":"NC", "ZIP":"12345" }` - string keys, string values

The issue is that Dafny's map type is strongly typed, so I can't have a map with mixed key types like the third example. However, the function is checking if all keys are strings anyway, so I think I should model this as a map where the keys could be any type.

Actually, let me think about this differently. In Dafny, I could use a sequence of pairs to represent the dictionary, where each pair is a key-value pair. But that would be more complex.

Let me look at what the function actually needs:
1. Check if the dictionary is empty
2. Check if all keys are strings
3. If they are all strings, check if they are all lowercase or all uppercase

For simplicity, I think I'll model the dictionary as a map<string, string> and assume that the input has already been filtered to only contain string keys. 

I realize the Python function requires handling non-string keys, which complicates the Dafny implementation. Dafny's type system doesn't naturally support mixed-type keys like Python does. I'll need a more flexible approach to capture the function's exact behavior. 

A sequence of key-value pairs might work, but Dafny lacks direct support for union types. I'm considering adding a precondition to validate key types, but this doesn't fully replicate the Python function's dynamic type checking. The challenge is modeling Python's flexible dictionary type in Dafny's more rigid type system.

My current strategy involves using a string-to-string map with explicit assumptions about key validation, focusing on the core case-checking logic while acknowledging the type conversion complexity.

I'll define a method that first checks map emptiness, then systematically verifies whether all keys are uniformly lowercase or uppercase using predicates that examine each character's ASCII range.

The implementation will leverage Dafny's quantifier-based predicates to comprehensively validate character case across all keys, returning a boolean result that reflects the uniform case requirement.

The key predicates will ensure:
- At least one alphabetic character exists
- All alphabetic characters conform to a single case (lowercase or uppercase)

This approach provides a precise, mathematically rigorous way to determine key case uniformity in a dictionary. I'll verify the predicate definitions for uppercase and lowercase strings, ensuring they correctly validate character case constraints across the entire string. The predicates confirm that at least one character matches the target case, and all alphabetic characters conform to that specific case requirement.

--- RESPONSE ---
<thinking>
Let me analyze the Python function:

1. **Input/Output types**: The function takes a dictionary and returns a boolean. In Dafny, I'll model the dictionary as `map<string, string>` for simplicity, though the Python version can handle mixed key types.

2. **Logic analysis**:
   - Return False if dictionary is empty
   - Return False if not all keys are strings (this constraint is implicit in my Dafny map type)
   - Return True if all keys are either all lowercase OR all uppercase
   - Otherwise return False

3. **Key considerations**:
   - I need to implement `IsLowerCase` and `IsUpperCase` predicates that match Python's `islower()` and `isupper()` behavior
   - Python's `islower()`/`isupper()` require at least one cased character and all cased characters to be the right case
   - No loops are needed, but I'll use quantifiers over the map keys

4. **Specifications**:
   - Precondition: None needed
   - Postcondition: The result should match the expected logic

Note: I'm simplifying by using `map<string, string>` instead of handling mixed key types, as Dafny's type system makes the latter complex and the core logic is about string case checking.
</thinking>

```dafny
method check_dict_case(dict: map<string, string>) returns (result: bool)
    ensures result == (|dict| > 0 && (AllKeysLowerCase(dict) || AllKeysUpperCase(dict)))
{
    // Return False if dictionary is empty
    if |dict| == 0 {
        return false;
    }
    
    // Get all keys
    var keys := dict.Keys;
    
    // Check if all keys are lowercase
    var all_lower := forall k :: k in keys ==> IsLowerCase(k);
    
    // Check if all keys are uppercase  
    var all_upper := forall k :: k in keys ==> IsUpperCase(k);
    
    // Return True if all keys are either all lowercase or all uppercase
    return all_lower || all_upper;
}

predicate IsLowerCase(s: string)
{
    |s| > 0 && 
    (exists i :: 0 <= i < |s| && 'a' <= s[i] <= 'z') &&
    (forall i :: 0 <= i < |s| && IsLetter(s[i]) ==> 'a' <= s[i] <= 'z')
}

predicate IsUpperCase(s: string)
{
    |s| > 0 && 
    (exists i :: 0 <= i < |s| && 'A' <= s[i] <= 'Z') &&
    (forall i :: 0 <= i < |s| && IsLetter(s[i]) ==> 'A' <= s[i] <= 'Z')
}

predicate IsLetter(c: char)
{
    ('a' <= c <= 'z') || ('A' <= c <= 'Z')
}

predicate AllKeysLowerCase(dict: map<string, string>)
{
    forall k :: k in dict.Keys ==> IsLowerCase(k)
}

predicate AllKeysUpperCase(dict: map<string, string>)
{
    forall k :: k in dict.Keys ==> IsUpperCase(k)
}
```

