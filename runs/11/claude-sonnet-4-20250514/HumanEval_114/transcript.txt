======SYSTEM PROMPT======
You are a Python coding assistant. Your task is to write a Python script with the full implementation of the function described in the user prompt. The implementation should be inside a markdown code block.

======USER PROMPT======

def minSubArraySum(nums):
    """
    Given an array of integers nums, find the minimum sum of any non-empty sub-array
    of nums.
    Example
    minSubArraySum([2, 3, 4, 1, 2, 4]) == 1
    minSubArraySum([-1, -2, -3]) == -6
    """


======THINKING======


======MODEL OUTPUT======
Looking at this problem, I need to find the minimum sum of any contiguous subarray. This is similar to the maximum subarray problem (Kadane's algorithm) but we're looking for the minimum instead.

I'll use a modified version of Kadane's algorithm that tracks the minimum sum ending at each position.

```python
def minSubArraySum(nums):
    """
    Given an array of integers nums, find the minimum sum of any non-empty sub-array
    of nums.
    Example
    minSubArraySum([2, 3, 4, 1, 2, 4]) == 1
    minSubArraySum([-1, -2, -3]) == -6
    """
    if not nums:
        return 0
    
    # Initialize with the first element
    min_ending_here = nums[0]
    min_so_far = nums[0]
    
    # Iterate through the rest of the array
    for i in range(1, len(nums)):
        # Either extend the existing subarray or start a new one
        min_ending_here = min(nums[i], min_ending_here + nums[i])
        # Update the overall minimum
        min_so_far = min(min_so_far, min_ending_here)
    
    return min_so_far
```

The algorithm works as follows:

1. **Initialize**: Set both `min_ending_here` and `min_so_far` to the first element
2. **For each subsequent element**: 
   - `min_ending_here` represents the minimum sum of a subarray ending at the current position
   - We choose between starting a new subarray with just the current element (`nums[i]`) or extending the previous subarray (`min_ending_here + nums[i]`)
   - We take whichever gives us the smaller sum
3. **Track global minimum**: `min_so_far` keeps track of the overall minimum sum we've seen

**Time Complexity**: O(n) - single pass through the array
**Space Complexity**: O(1) - only using a constant amount of extra space

Let's trace through the examples:
- `[2, 3, 4, 1, 2, 4]`: The algorithm will find that the subarray `[1]` has the minimum sum of 1
- `[-1, -2, -3]`: The algorithm will find that the subarray `[-1, -2, -3]` has the minimum sum of -6