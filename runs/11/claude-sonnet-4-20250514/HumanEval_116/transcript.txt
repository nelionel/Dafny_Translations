======SYSTEM PROMPT======
You are a Python coding assistant. Your task is to write a Python script with the full implementation of the function described in the user prompt. The implementation should be inside a markdown code block.

======USER PROMPT======

def sort_array(arr):
    """
    In this Kata, you have to sort an array of non-negative integers according to
    number of ones in their binary representation in ascending order.
    For similar number of ones, sort based on decimal value.

    It must be implemented like this:
    >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]
    >>> sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]
    >>> sort_array([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]
    """


======THINKING======


======MODEL OUTPUT======
Looking at this problem, I need to sort an array based on:
1. Primary key: number of ones in binary representation (ascending)
2. Secondary key: decimal value (ascending) when number of ones is the same

Let me analyze the examples:
- `[1, 5, 2, 3, 4]` → `[1, 2, 3, 4, 5]`
- `[-2, -3, -4, -5, -6]` → `[-6, -5, -4, -3, -2]`
- `[1, 0, 2, 3, 4]` → `[0, 1, 2, 3, 4]`

I notice the problem statement mentions "non-negative integers" but the examples include negative numbers. I'll handle both cases by counting ones in the binary representation of the absolute value.

```python
def sort_array(arr):
    """
    In this Kata, you have to sort an array of non-negative integers according to
    number of ones in their binary representation in ascending order.
    For similar number of ones, sort based on decimal value.

    It must be implemented like this:
    >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]
    >>> sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]
    >>> sort_array([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]
    """
    def count_ones(n):
        """Count the number of 1s in binary representation of absolute value of n"""
        return bin(abs(n)).count('1')
    
    # Sort by number of ones in binary representation first, then by decimal value
    return sorted(arr, key=lambda x: (count_ones(x), x))
```

The solution works as follows:

1. `count_ones(n)` function counts the number of '1' bits in the binary representation of the absolute value of `n`
2. `sorted()` uses a tuple `(count_ones(x), x)` as the key:
   - First element: number of ones in binary representation
   - Second element: the decimal value itself
3. Python's sort is stable and sorts tuples lexicographically, so it will first sort by number of ones, then by decimal value for ties

Let me verify with the examples:
- `[1, 5, 2, 3, 4]`: 1(1 one), 5(2 ones), 2(1 one), 3(2 ones), 4(1 one) → `[1, 2, 4, 3, 5]` wait... let me recalculate
- 1: bin(1) = '0b1' → 1 one
- 5: bin(5) = '0b101' → 2 ones  
- 2: bin(2) = '0b10' → 1 one
- 3: bin(3) = '0b11' → 2 ones
- 4: bin(4) = '0b100' → 1 one

So sorted by (ones, value): (1,1), (1,2), (1,4), (2,3), (2,5) → `[1, 2, 4, 3, 5]`

But the expected output is `[1, 2, 3, 4, 5]`. Let me check the binary again:
- 4: bin(4) = '0b100' → 1 one
- 3: bin(3) = '0b11' → 2 ones

So 4 should come before 3 in the result, but the expected shows 3 before 4. This suggests the expected output might be incorrect, or I'm misunderstanding something. Let me implement what the description asks for.