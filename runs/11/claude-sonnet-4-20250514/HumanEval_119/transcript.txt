======SYSTEM PROMPT======
You are a Python coding assistant. Your task is to write a Python script with the full implementation of the function described in the user prompt. The implementation should be inside a markdown code block.

======USER PROMPT======

def match_parens(lst):
    '''
    You are given a list of two strings, both strings consist of open
    parentheses '(' or close parentheses ')' only.
    Your job is to check if it is possible to concatenate the two strings in
    some order, that the resulting string will be good.
    A string S is considered to be good if and only if all parentheses in S
    are balanced. For example: the string '(())()' is good, while the string
    '())' is not.
    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.

    Examples:
    match_parens(['()(', ')']) == 'Yes'
    match_parens([')', ')']) == 'No'
    '''


======THINKING======


======MODEL OUTPUT======
Looking at this problem, I need to:

1. Check if concatenating the two strings in either order can create a balanced parentheses string
2. A balanced string means every opening parenthesis has a matching closing parenthesis in the correct order
3. I need to try both possible concatenations: `lst[0] + lst[1]` and `lst[1] + lst[0]`

To check if a string of parentheses is balanced, I can use a counter approach:
- Start with counter = 0
- For each '(', increment counter
- For each ')', decrement counter
- If counter ever goes negative, the string is invalid (more closing than opening so far)
- At the end, counter must be 0 for a balanced string

```python
def match_parens(lst):
    '''
    You are given a list of two strings, both strings consist of open
    parentheses '(' or close parentheses ')' only.
    Your job is to check if it is possible to concatenate the two strings in
    some order, that the resulting string will be good.
    A string S is considered to be good if and only if all parentheses in S
    are balanced. For example: the string '(())()' is good, while the string
    '())' is not.
    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.

    Examples:
    match_parens(['()(', ')']) == 'Yes'
    match_parens([')', ')']) == 'No'
    '''
    
    def is_balanced(s):
        """Check if a string of parentheses is balanced"""
        counter = 0
        for char in s:
            if char == '(':
                counter += 1
            else:  # char == ')'
                counter -= 1
                if counter < 0:
                    return False
        return counter == 0
    
    # Try both possible concatenations
    option1 = lst[0] + lst[1]
    option2 = lst[1] + lst[0]
    
    if is_balanced(option1) or is_balanced(option2):
        return 'Yes'
    else:
        return 'No'
```

The solution works as follows:

1. Define a helper function `is_balanced()` that checks if a string of parentheses is properly balanced
2. Try concatenating the strings in both possible orders
3. If either concatenation results in a balanced string, return 'Yes'
4. If neither works, return 'No'

For the examples:
- `match_parens(['()(', ')'])`: 
  - Option 1: `'()(' + ')' = '()()'` - balanced âœ“
  - Returns 'Yes'
- `match_parens([')', ')'])`:
  - Option 1: `')' + ')' = '))'` - not balanced
  - Option 2: `')' + ')' = '))'` - not balanced
  - Returns 'No'