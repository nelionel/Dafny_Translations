======SYSTEM PROMPT======
You are a Python coding assistant. Your task is to write a Python script with the full implementation of the function described in the user prompt. The implementation should be inside a markdown code block.

======USER PROMPT======

def can_arrange(arr):
    """Create a function which returns the largest index of an element which
    is not greater than or equal to the element immediately preceding it. If
    no such element exists then return -1. The given array will not contain
    duplicate values.

    Examples:
    can_arrange([1,2,4,3,5]) = 3
    can_arrange([1,2,3]) = -1
    """


======THINKING======


======MODEL OUTPUT======
Looking at this problem, I need to find the largest index where an element is not greater than or equal to the element that comes before it. In other words, I'm looking for the rightmost position where `arr[i] < arr[i-1]`.

Let me trace through the examples:
- `[1,2,4,3,5]`: At index 3, we have 3 < 4 (the preceding element), so this violates the condition
- `[1,2,3]`: Each element is greater than or equal to the previous one, so no violation exists

Here's my implementation:

```python
def can_arrange(arr):
    """Create a function which returns the largest index of an element which
    is not greater than or equal to the element immediately preceding it. If
    no such element exists then return -1. The given array will not contain
    duplicate values.

    Examples:
    can_arrange([1,2,4,3,5]) = 3
    can_arrange([1,2,3]) = -1
    """
    # Start from the end of the array and work backwards
    # to find the largest index where arr[i] < arr[i-1]
    for i in range(len(arr) - 1, 0, -1):
        if arr[i] < arr[i-1]:
            return i
    
    # If no such element exists, return -1
    return -1
```

The algorithm works by:
1. Starting from the last index and moving backwards (since we want the largest index)
2. For each position `i` (starting from index 1), checking if `arr[i] < arr[i-1]`
3. If we find such a position, we return it immediately (this will be the largest index due to our backwards traversal)
4. If we complete the loop without finding any such position, we return -1

Time complexity: O(n) in the worst case
Space complexity: O(1)