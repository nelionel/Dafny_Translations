======SYSTEM PROMPT======
You are a Python coding assistant. Your task is to write a Python script with the full implementation of the function described in the user prompt. The implementation should be inside a markdown code block.

======USER PROMPT======

def order_by_points(nums):
    """
    Write a function which sorts the given list of integers
    in ascending order according to the sum of their digits.
    Note: if there are several items with similar sum of their digits,
    order them based on their index in original list.

    For example:
    >>> order_by_points([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]
    >>> order_by_points([]) == []
    """


======THINKING======


======MODEL OUTPUT======
Looking at this problem, I need to:

1. Sort integers by the sum of their digits in ascending order
2. For numbers with the same digit sum, maintain their original order (stable sort)
3. Handle negative numbers correctly when calculating digit sum

Let me think about how to calculate the sum of digits for negative numbers. From the example:
- For `-1`: the sum should be `-1` (negative sign affects the first digit)
- For `-11`: the sum should be `-1 + 1 = 0` 
- For `-12`: the sum should be `-1 + 2 = 1`

This suggests that for negative numbers, only the first digit carries the negative sign.

```python
def order_by_points(nums):
    """
    Write a function which sorts the given list of integers
    in ascending order according to the sum of their digits.
    Note: if there are several items with similar sum of their digits,
    order them based on their index in original list.

    For example:
    >>> order_by_points([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]
    >>> order_by_points([]) == []
    """
    def digit_sum(n):
        # Convert to string to work with digits
        s = str(abs(n))  # Get absolute value to work with digits
        
        # Calculate sum of digits
        total = sum(int(digit) for digit in s)
        
        # If original number was negative, make the first digit negative
        if n < 0:
            first_digit = int(s[0])
            total = total - 2 * first_digit  # Subtract twice to make first digit negative
        
        return total
    
    # Create list of (original_index, number, digit_sum) tuples
    indexed_nums = [(i, num, digit_sum(num)) for i, num in enumerate(nums)]
    
    # Sort by digit sum first, then by original index to maintain stable sort
    indexed_nums.sort(key=lambda x: (x[2], x[0]))
    
    # Return just the numbers in the new order
    return [num for _, num, _ in indexed_nums]
```

Wait, let me verify my digit sum calculation with the examples:
- `1`: sum = 1
- `11`: sum = 1 + 1 = 2  
- `-1`: sum = -1
- `-11`: sum = -1 + 1 = 0
- `-12`: sum = -1 + 2 = 1

So the order by digit sum would be: `-1` (-1), `-11` (0), `1` (1), `-12` (1), `11` (2)

Since `-12` and `1` have the same digit sum (1), we need to maintain original order, so `1` comes before `-12`.

Let me refine the implementation:

```python
def order_by_points(nums):
    """
    Write a function which sorts the given list of integers
    in ascending order according to the sum of their digits.
    Note: if there are several items with similar sum of their digits,
    order them based on their index in original list.

    For example:
    >>> order_by_points([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]
    >>> order_by_points([]) == []
    """
    def digit_sum(n):
        if n == 0:
            return 0
        
        # Convert to string to work with digits
        s = str(abs(n))
        digits = [int(d) for d in s]
        
        # If number is negative, make the first digit negative
        if n < 0:
            digits[0] = -digits[0]
        
        return sum(digits)
    
    # Sort using digit sum as primary key and original index as secondary key
    # to maintain stable sort for equal digit sums
    return sorted(nums, key=lambda x: (digit_sum(x), nums.index(x)))
```

Actually, using `nums.index(x)` is inefficient for duplicates. Let me use enumerate instead:

```python
def order_by_points(nums):
    """
    Write a function which sorts the given list of integers
    in ascending order according to the sum of their digits.
    Note: if there are several items with similar sum of their digits,
    order them based on their index in original list.

    For example:
    >>> order_by_points([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]
    >>> order_by_points([]) == []
    """
    def digit_sum(n):
        if n == 0:
            return 0
        
        # Convert to string to work with digits
        s = str(abs(n))
        digits = [int(d) for d in s]
        
        # If number is negative, make the first digit negative
        if n < 0:
            digits[0] = -digits[0]
        
        return sum(digits)
    
    # Create pairs of (index, number) and sort by digit sum then by index
    indexed_nums = list(enumerate(nums))
    indexed_nums.sort(key=lambda x: (digit_sum(x[1]), x[0]))
    
    # Return just the numbers
    return [num for _, num in indexed_nums]
```