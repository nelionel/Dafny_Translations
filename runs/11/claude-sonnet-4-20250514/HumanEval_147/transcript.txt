======SYSTEM PROMPT======
You are a Python coding assistant. Your task is to write a Python script with the full implementation of the function described in the user prompt. The implementation should be inside a markdown code block.

======USER PROMPT======

def get_max_triples(n):
    """
    You are given a positive integer n. You have to create an integer array a of length n.
        For each i (1 ≤ i ≤ n), the value of a[i] = i * i - i + 1.
        Return the number of triples (a[i], a[j], a[k]) of a where i < j < k, 
    and a[i] + a[j] + a[k] is a multiple of 3.

    Example :
        Input: n = 5
        Output: 1
        Explanation: 
        a = [1, 3, 7, 13, 21]
        The only valid triple is (1, 7, 13).
    """


======THINKING======


======MODEL OUTPUT======
Looking at this problem, I need to:

1. Create an array where `a[i] = i * i - i + 1` for i from 1 to n
2. Find all triples (a[i], a[j], a[k]) where i < j < k
3. Count how many of these triples have a sum divisible by 3

Let me first analyze the pattern of the formula `i * i - i + 1`:
- For i = 1: 1 - 1 + 1 = 1
- For i = 2: 4 - 2 + 1 = 3  
- For i = 3: 9 - 3 + 1 = 7
- For i = 4: 16 - 4 + 1 = 13
- For i = 5: 25 - 5 + 1 = 21

Now I need to check the pattern modulo 3:
- i² - i + 1 ≡ ? (mod 3)

Let me check for different values of i mod 3:
- If i ≡ 0 (mod 3): i² ≡ 0, so i² - i + 1 ≡ 0 - 0 + 1 ≡ 1 (mod 3)
- If i ≡ 1 (mod 3): i² ≡ 1, so i² - i + 1 ≡ 1 - 1 + 1 ≡ 1 (mod 3)  
- If i ≡ 2 (mod 3): i² ≡ 1, so i² - i + 1 ≡ 1 - 2 + 1 ≡ 0 (mod 3)

So the pattern is:
- If i ≡ 0 or 1 (mod 3), then a[i] ≡ 1 (mod 3)
- If i ≡ 2 (mod 3), then a[i] ≡ 0 (mod 3)

For three numbers to sum to a multiple of 3, their remainders mod 3 must sum to 0 mod 3.

```python
def get_max_triples(n):
    """
    You are given a positive integer n. You have to create an integer array a of length n.
        For each i (1 ≤ i ≤ n), the value of a[i] = i * i - i + 1.
        Return the number of triples (a[i], a[j], a[k]) of a where i < j < k, 
    and a[i] + a[j] + a[k] is a multiple of 3.
    """
    # Count elements by their remainder when divided by 3
    count_mod = [0, 0, 0]  # count_mod[r] = number of elements ≡ r (mod 3)
    
    for i in range(1, n + 1):
        val = i * i - i + 1
        count_mod[val % 3] += 1
    
    # For sum to be divisible by 3, we need:
    # Case 1: All three numbers ≡ 0 (mod 3) -> C(count_mod[0], 3)
    # Case 2: All three numbers ≡ 1 (mod 3) -> C(count_mod[1], 3)  
    # Case 3: All three numbers ≡ 2 (mod 3) -> C(count_mod[2], 3)
    # Case 4: One each of 0, 1, 2 (mod 3) -> count_mod[0] * count_mod[1] * count_mod[2]
    
    def combination(n, r):
        if n < r or r < 0:
            return 0
        if r == 0 or r == n:
            return 1
        # C(n,3) = n * (n-1) * (n-2) / 6
        if r == 3:
            return n * (n - 1) * (n - 2) // 6
        return 0
    
    result = 0
    
    # Case 1: Three numbers all ≡ 0 (mod 3)
    result += combination(count_mod[0], 3)
    
    # Case 2: Three numbers all ≡ 1 (mod 3)
    result += combination(count_mod[1], 3)
    
    # Case 3: Three numbers all ≡ 2 (mod 3)
    result += combination(count_mod[2], 3)
    
    # Case 4: One each of remainders 0, 1, 2
    result += count_mod[0] * count_mod[1] * count_mod[2]
    
    return result
```