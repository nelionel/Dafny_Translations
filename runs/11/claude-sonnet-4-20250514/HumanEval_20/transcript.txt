======SYSTEM PROMPT======
You are a Python coding assistant. Your task is to write a Python script with the full implementation of the function described in the user prompt. The implementation should be inside a markdown code block.

======USER PROMPT======
from typing import List, Tuple


def find_closest_elements(numbers: List[float]) -> Tuple[float, float]:
    """ From a supplied list of numbers (of length at least two) select and return two that are the closest to each
    other and return them in order (smaller number, larger number).
    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])
    (2.0, 2.2)
    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])
    (2.0, 2.0)
    """


======THINKING======


======MODEL OUTPUT======
Looking at this problem, I need to:

1. Find the two numbers in the list that have the smallest absolute difference between them
2. Return them as a tuple in ascending order (smaller first, larger second)

Here's my approach:
- Compare all pairs of numbers to find the minimum distance
- Keep track of the pair with the minimum distance
- Return the pair sorted in ascending order

```python
from typing import List, Tuple


def find_closest_elements(numbers: List[float]) -> Tuple[float, float]:
    """ From a supplied list of numbers (of length at least two) select and return two that are the closest to each
    other and return them in order (smaller number, larger number).
    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])
    (2.0, 2.2)
    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])
    (2.0, 2.0)
    """
    min_distance = float('inf')
    closest_pair = None
    
    # Compare all pairs of numbers
    for i in range(len(numbers)):
        for j in range(i + 1, len(numbers)):
            distance = abs(numbers[i] - numbers[j])
            if distance < min_distance:
                min_distance = distance
                closest_pair = (numbers[i], numbers[j])
    
    # Return the pair in ascending order
    return tuple(sorted(closest_pair))
```

The algorithm works as follows:
1. Initialize `min_distance` to infinity and `closest_pair` to None
2. Use nested loops to examine all unique pairs of numbers (avoiding duplicates by using `j = i + 1`)
3. For each pair, calculate the absolute difference
4. If this difference is smaller than the current minimum, update both the minimum distance and the closest pair
5. Finally, return the closest pair sorted in ascending order using `sorted()`

This handles the test cases correctly:
- `[1.0, 2.0, 3.0, 4.0, 5.0, 2.2]` → `(2.0, 2.2)` (difference of 0.2)
- `[1.0, 2.0, 3.0, 4.0, 5.0, 2.0]` → `(2.0, 2.0)` (difference of 0.0)