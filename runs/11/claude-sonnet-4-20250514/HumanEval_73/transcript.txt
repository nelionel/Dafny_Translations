======SYSTEM PROMPT======
You are a Python coding assistant. Your task is to write a Python script with the full implementation of the function described in the user prompt. The implementation should be inside a markdown code block.

======USER PROMPT======

def smallest_change(arr):
    """
    Given an array arr of integers, find the minimum number of elements that
    need to be changed to make the array palindromic. A palindromic array is an array that
    is read the same backwards and forwards. In one change, you can change one element to any other element.

    For example:
    smallest_change([1,2,3,5,4,7,9,6]) == 4
    smallest_change([1, 2, 3, 4, 3, 2, 2]) == 1
    smallest_change([1, 2, 3, 2, 1]) == 0
    """


======THINKING======


======MODEL OUTPUT======
Looking at this problem, I need to find the minimum number of changes to make an array palindromic.

For an array to be palindromic, elements at symmetric positions should be equal:
- `arr[0]` should equal `arr[n-1]`
- `arr[1]` should equal `arr[n-2]`
- And so on...

The key insight is that for each pair of symmetric positions, if the elements are different, I need to change one of them. I can count how many such pairs have different elements.

Let me trace through the examples:
- `[1,2,3,5,4,7,9,6]`: Compare (1,6), (2,9), (3,7), (5,4) - all 4 pairs are different, so 4 changes needed
- `[1,2,3,4,3,2,2]`: Compare (1,2), (2,2), (3,3), middle element 4 stays - 1 pair different, so 1 change needed
- `[1,2,3,2,1]`: Compare (1,1), (2,2), middle element 3 stays - 0 pairs different, so 0 changes needed

```python
def smallest_change(arr):
    """
    Given an array arr of integers, find the minimum number of elements that
    need to be changed to make the array palindromic. A palindromic array is an array that
    is read the same backwards and forwards. In one change, you can change one element to any other element.

    For example:
    smallest_change([1,2,3,5,4,7,9,6]) == 4
    smallest_change([1, 2, 3, 4, 3, 2, 2]) == 1
    smallest_change([1, 2, 3, 2, 1]) == 0
    """
    n = len(arr)
    changes = 0
    
    # Compare elements from both ends moving towards the center
    for i in range(n // 2):
        # Compare element at position i with element at position n-1-i
        if arr[i] != arr[n - 1 - i]:
            changes += 1
    
    return changes
```

The algorithm works by:
1. Iterating through the first half of the array (`range(n // 2)`)
2. For each position `i`, comparing `arr[i]` with its symmetric counterpart `arr[n-1-i]`
3. If they're different, incrementing the change counter
4. The middle element (if the array has odd length) doesn't need to be compared with anything

Time complexity: O(n/2) = O(n)
Space complexity: O(1)